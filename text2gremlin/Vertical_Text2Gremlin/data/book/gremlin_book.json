[
  {
    "level": "1",
    "title": "1. INTRODUCTION {#_introduction}",
    "content": "::: formalpara-title\n**This book is a work in progress. Feedback is very much encouraged and\nwelcomed!**\n:::\n\nThe title of this book could equally well be *\\\"A getting started guide\nfor users of graph databases and the Gremlin query language featuring\nhints, tips and sample queries\\\"*. It turns out that is a bit too long\nto fit on one line for a heading but in a single sentence that describes\nthe focus of this work pretty well.\n\nI have resisted the urge to try and cover every single feature of\nTinkerPop one after the other in a reference manual fashion. Instead,\nwhat I have tried to do is capture the learning process that I myself\nhave gone through using what I hope is a sensible flow from getting\nstarted to more advanced topics. To get the most from this book I\nrecommend having the Gremlin console open with my sample data loaded as\nyou follow along. I have not assumed that anyone reading this has any\nprior knowledge of Apache TinkerPop, the Gremlin query language or\nrelated tools. I will introduce everything you need to get started in\nChapter 2.\n\nI hope people find what follows useful. It definitely remains a work in\nprogress and more will be added in the coming weeks and months as time\npermits. I am hopeful that what is presented so far is of some use to\nanyone, who like me, is learning to use the Gremlin query and traversal\nlanguage and related technologies.\n\nA lot of additional material, including the book in many different\nformats such as PDF, HTML, ePub and MOBI as well as sample code and\ndata, can be found at the [project's home on\nGitHub](https://github.com/krlawrence/graph). You will find a summary of\neverything that is available in the \\\"[Introducing the book sources,\nsample programs and data](#samplesintro)\\\" section.",
    "children": [
      {
        "level": "1.1",
        "title": "1.1. How this book came to be {#_how_this_book_came_to_be}",
        "content": "I forget exactly when, but sometime early in 2016 I started compiling a\nlist of notes, hints and tips, initially for my own benefit. My notes\nwere full of things I had found poorly explained elsewhere while using\ngraph databases and especially while using Apache TinkerPop, Gremlin and\nJanusGraph. Over time that document continued to grow and had\neffectively become a book in all but name. After some encouragement from\ncolleagues I decided to release my notes as a *living book* in an open\nsource venue so that anyone who is interested can read it. It is\ndefinitely aimed at programmers and data scientists but I hope is also\nconsumable by anyone using the Gremlin graph query and traversal\nlanguage to work with graph databases.\n\nI have included a large number of code examples and sample queries along\nwith discussions of best practices and more than a few lessons I learned\nthe hard way, that I hope you will find informative. I call it a *living\nbook* as my goal is to regularly make updates as I discover things that\nneed adding while also trying to keep the content as up to date as\npossible as Apache TinkerPop itself evolves.\n\nI would like to say very heartfelt **Thank You** to all those that have\nencouraged me to keep going with this adventure! It has required quite a\nlot of work but also remains a lot of fun.\n\nKelvin R. Lawrence\\\nFirst draft: October 5th, 2017\\\nCurrent draft: May 4th 2022\\",
        "children": []
      },
      {
        "level": "1.2",
        "title": "1.2. Providing feedback {#_providing_feedback}",
        "content": "Please let me know about any mistakes you find in this material and also\nplease feel free to send me feedback of any sort. Suggested improvements\nare especially welcome. A good way to provide feedback is by opening an\nissue in the GitHub repository located at\n<https://github.com/krlawrence/graph>. You are currently reading\nrevision 283-preview of the book.\n\nI am grateful to those who have already taken the time to review the\nmanuscript and open issues or submit pull requests.",
        "children": []
      },
      {
        "level": "1.3",
        "title": "1.3. Some words of thanks {#thanks}",
        "content": "I would like to thank my former colleagues, Graham Wallis, Jason Plurad\nand Adam Holley for their help in refining and improving several of the\nqueries contained in this book. Gremlin is definitely a bit of a team\nsport. We spent many fun hours discussing the best way to handle\ndifferent types of queries and traversals!\n\nI would also be remiss if I did not give a big shout out to all of the\nfolks that spend a lot of time replying to questions and suggestions on\nthe [Gremlin Users Google\nGroup](https://groups.google.com/forum/#!forum/gremlin-users). Special\nthanks should go to Daniel Kuppitz, Marko Rodriguez and Stephen\nMallette, key members of the team that created and maintains Apache\nTinkerPop.\n\nLastly, I would like to thank everyone who has submitted feedback and\nideas via e-mail as well as GitHub issues and pull requests. That is the\nbest part about this being a *living book* we can continue to improve\nand evolve it just as the technology it is about continues to evolve.\nYour help and support is very much appreciated.",
        "children": []
      },
      {
        "level": "1.4",
        "title": "1.4. What is this book about? {#about}",
        "content": "This book introduces the Apache TinkerPop 3 *Gremlin* graph query and\ntraversal language via real examples featuring real-world graph data.\nThat data along with sample code and example applications is available\nfor download from the GitHub project as well as many other items. The\ngraph, *air-routes*, is a model of the world airline route network\nbetween 3,373 airports including 43,400 routes. The examples presented\nwill work unmodified with the `air-routes.graphml` file loaded into the\nGremlin console running with a TinkerGraph. How to set that environment\nup is covered in the [Downloading, installing and launching the\nconsole](#gremlininstall) section below.\n\n::: note\nThe examples in this book have been tested using Apache TinkerPop\nrelease 3.5.2. However, work remains to be done to add coverage of new\nfeatures in that release to the book.\n:::\n\nTinkerGraph is an *in-memory* graph, meaning nothing gets saved to disk\nautomatically. It is shipped as part of the Apache TinkerPop 3 download.\nThe goal of this tutorial is to allow someone with little to no prior\nknowledge to get up and going quickly using the Gremlin console and the\n*air-routes* graph. Later in the book I will discuss using additional\ntechnologies such as JanusGraph, Apache Cassandra, Gremlin Server and\nElasticsearch to build scalable and persisted graph stores that can\nstill be traversed using Gremlin queries. I will also discuss writing\nstandalone Java and Groovy applications as well as using the Gremlin\nConsole. I even slipped a couple of Ruby examples in too!\n\n::: note\nIn the first few sections of this book I have mainly focussed on showing\nthe different types of queries that you can issue using Gremlin. I have\nnot tried to show all of the output that you will get back from entering\nthese queries but have selectively shown examples of output. I go a lot\ndeeper into things in chapters 4, 5 and 6.\n:::\n\nChapter 1 - INTRODUCTION\n\n:   -   I start off by briefly doing a recap on why Graph databases are\n        of interest to us and discuss some good use cases for graphs. I\n        also provide pointers to the sample programs and other\n        additional materials referenced by the book.\n\nChapter 2 - GETTING STARTED\n\n:   -   In Chapter two I introduce several of the components of Apache\n        TinkerPop and also introduce the `air-routes.graphml` file that\n        will be used as the graph the majority of examples shown in this\n        book are based on.\n\nChapter 3 - WRITING GREMLIN QUERIES\n\n:   -   In Chapter three things start to get a lot more interesting! I\n        start discussing how to use the Gremlin graph traversal and\n        query language to interrogate the *air-routes* graph. I begin by\n        comparing how we could have built the *air-routes* graph using a\n        more traditional relational database and then look at how SQL\n        and Gremlin are both similar in some ways and very different in\n        others. For the rest of the Chapter, I introduce several of the\n        key Gremlin methods, or as they are often called, *\\\"steps\\\"*. I\n        mostly focus on reading the graph (not adding or deleting\n        things) in this Chapter.\n\nChapter 4 - BEYOND BASIC QUERIES\n\n:   -   In Chapter four the focus moves beyond just reading the graph\n        and I describe how to add vertices (nodes), edges and properties\n        as well as how to delete and update them. I also present a\n        discussion of various best practices. I also start to explore\n        some slightly more advanced topics in this chapter.\n\nChapter 5 - MISCELLANEOUS QUERIES AND THE RESULTS THEY GENERATE\n\n:   -   In Chapter five I focus on using what has been covered in the\n        prior Chapters to write queries that have a more real-world\n        feel. I present a lot more examples of the output from running\n        queries in this Chapter. I also start to discuss topics such as\n        analyzing distances, route distribution and writing geospatial\n        queries.\n\nChapter 6 - MOVING BEYOND THE CONSOLE AND TINKERGRAPH\n\n:   -   In Chapter six I start to expand the focus to concepts beyond\n        using the Gremlin Console and a TinkerGraph. I start by looking\n        at how you can write standalone Java and Groovy applications\n        that can work with a graph. I then introduce JanusGraph and take\n        a fairly detailed look at its capabilities such as support for\n        transactions, schemas and indexes. Various technology choices\n        for back end persistent stores and indexes are explored along\n        the way.\n\nChapter 7 - INTRODUCING GREMLIN SERVER\n\n:   -   In Chapter seven, Gremlin Server is introduced. I begin to\n        explore connecting to and working with a remote graph both from\n        the Gremlin Console and the command line as well as from code.\n        When this book was first released, the majority of \\\"real\n        world\\\" use cases focussed on directly attached or even in\n        memory graphs. As Apache TinkerPop has evolved, it has become a\n        lot more common to connect to a graph remotely via a Gremlin\n        Server.\n\nChapter 8 - COMMON GRAPH SERIALIZATION FORMATS\n\n:   -   In Chapter eight a discussion is presented of some common Graph\n        serialization file formats along with coverage of how to use\n        them in the context of TinkerPop 3 enabled graphs.\n\nChapter 9 - FURTHER READING\n\n:   -   I finish up by providing several links to useful web sites where\n        you can find tools and documentation for many of the topics and\n        technologies covered in this book.",
        "children": []
      },
      {
        "level": "1.5",
        "title": "1.5. Introducing the book sources, sample programs and data {#samplesintro}",
        "content": "All work related to this project is being done in the open at GitHub. A\nlist of where to find the key components is provided below. The examples\nin this book make use of a sample graph called *air-routes* which\ncontains a graph based on the world airline route network between over\n3,370 airports. The sample graph data, quite a bit of sample code and\nsome larger demo applications can all be found at the same GitHub\nlocation that hosts the book manuscript. You will also find releases of\nthe the book in various formats (HTML, PDF, DocBook/XML, MOBI and EPUB)\nat the same GitHub location. The sample programs include standalone\nJava, Groovy, Python and Ruby examples as well as many examples that can\nbe run from the Gremlin Console. There are some differences between\nusing Gremlin from a standalone program and from the Gremlin Console.\nThe sample programs demonstrate several of these differences. The sample\napplications area contains a full example HTML and JavaScript\napplication that lets you explore the *air-routes* graph visually. The\nhome page for the GitHub project includes a README.md file to help you\nnavigate the site. Below are some links to various resources included\nwith this book.\n\nProject home\n\n:   -   <https://github.com/krlawrence/graph>\n\nBook manuscript in Asciidoc format\n\n:   -   This file can be viewed using the GitHub web interface. It will\n        always represent the very latest updates.\n\n    -   <https://github.com/krlawrence/graph/tree/main/book>\n\nLatest PDF and HTML snapshots\n\n:   -   These files are regularly updated to reflect any significant\n        changes. These are the only generated formats that are updated\n        outside of the full release cycle. The PDF version includes\n        pagination as well as page numbering and is produced using an A4\n        page size. The HTML version does not include these features.\n        Otherwise they are more or less identical.\n\n    -   <http://kelvinlawrence.net/book/PracticalGremlin.pdf>\n\n    -   <http://kelvinlawrence.net/book/PracticalGremlin.html>\n\nOfficial book releases in multiple formats\n\n:   -   Official releases include Asciidoc, HTML, PDF, ePub, MOBI and\n        DocBook versions as well as snapshots of all the samples and\n        other materials in a single package. My goal is to have an\n        official release about once a month providing enough new\n        material has been created to justify doing it. The eBook and\n        MOBI versions are really intended to be read using e-reader\n        devices and for that reason use a white background for all\n        source code highlighting to make it easier to read on monochrome\n        devices.\n\n    -   I recommend using the PDF version if possible as it has page\n        numbering. If you prefer reading the book as if it were web page\n        then by all means use the HTML version. You will just not get\n        any pagination or page numbers. The DocBook format can be read\n        using tools such as Yelp on Linux systems but is primarily\n        included so that people can use it to generate other formats\n        that I do not already provide. There is currently an issue with\n        the MOBI and ePub versions that causes links to have the wrong\n        text. Other than that they should work although you may need to\n        change the font size you use on your device to make things\n        easier to read.\n\n    -   <https://github.com/krlawrence/graph/releases>\n\nSample data (`air-routes.graphml`)\n\n:   -   <https://github.com/krlawrence/graph/tree/main/sample-data>\n\nSample code\n\n:   -   <https://github.com/krlawrence/graph/tree/main/sample-code>\n\nExample applications\n\n:   -   <https://github.com/krlawrence/graph/tree/main/demos>\n\nChange history\n\n:   -   If you want to keep up with the changes being made this is the\n        file to keep an eye on.\n\n    -   <https://github.com/krlawrence/graph/blob/main/ChangeHistory.md>",
        "children": []
      },
      {
        "level": "1.6",
        "title": "1.6. A word about TinkerPop 3.4 {#tp34intro}",
        "content": "A major update to Apache TinkerPop, version 3.4.0, was released in\nJanuary 2019 and a number of point releases followed. The examples in\nthis book have been tested with all releases of the 3.4.x line. New\nexamples have also been added as necessitated by those updates.\n\n::: note\nThe change history contains details of everything that has been added\nover time and can be found at this location:\n<https://github.com/krlawrence/graph/blob/main/ChangeHistory.md>\n:::\n\nGraph database engines that support Apache TinkerPop often take a while\nto move up to new releases and it's always a good idea to verify the\nexact level the database you are using supports.\n\n::: note\nFull details of all the new features added in the TinkerPop 3.4.x\nreleases can be found at the following link:\n<https://github.com/apache/tinkerpop/blob/master/CHANGELOG.asciidoc>\n:::\n\nAs well as updating the book, I continue incrementally adding coverage\nof these features to the `sample-code` folder. Samples currently added\ninclude `nested-repeat.groovy` that demonstrates the use of the new\nnested repeat step capability. It can be loaded and run from the Gremlin\nconsole.",
        "children": []
      },
      {
        "level": "1.7",
        "title": "1.7. Introducing TinkerPop 3.5 {#tp35intro}",
        "content": "Apache TinkerPop 3.5.0 was released in May 2021. This update introduced\na number of improvements in areas such as Gremlin client drivers, the\nGremlin Server and overall bug fixes. The release also improved the\nGremlin query language in some key areas. Some features that had been\ndeclared deprecated in earlier releases were finally removed as part of\nthe 3.5.0 update. If you have queries and code that still use these\ndeprecated features, as part of an upgrade to the 3.5.x level, you will\nneed to make the appropriate changes.\n\nThe main breaking change to be aware of is that *Order.incr* and\n*Order.decr* were removed from the Gremlin language. The newer\n*Order.asc* and *Order.desc* must be used instead. The examples in this\nbook and those in the `sample-code` folder have been updated to reflect\nthese changes.\n\nIn January 2022, the TinkerPop 3.5.2 release added a native `datetime`\noperator to the Gremlin language such that dates can be added without\nneeding programming language specific constructs. This is useful when\nsending Gremlin queries as text strings.\n\n::: note\nFull details of all the new features added in the TinkerPop 3.5.x\nreleases can be found at the following link:\n<https://github.com/apache/tinkerpop/blob/master/CHANGELOG.asciidoc>\n:::",
        "children": []
      },
      {
        "level": "1.8",
        "title": "1.8. Introducing TinkerPop 3.6 {#tp36intro}",
        "content": "Apache TinkerPop 3.6.0 was released in April 2022. Coming almost exactly\na year after the initial 3.5.0 release, this is one of the most\nsignificant TinkerPop releases since TinkerPop 3.4.0 appeared in January\n2019. The release contains many improvements, including several new\nGremlin steps, designed to make commonly performed tasks much easier.\nNotable improvements include:\n\n-   New *mergeV* and *mergeE* steps that make \\\"create if not exist\\\"\n    type queries, sometimes referred to as \\\"upserts\\\", much easier to\n    write. Over time, these steps will replace use of the\n    *fold...​coalesce* pattern, and will also replace the various \\\"map\n    injection\\\" patterns that can be used to create multiple vertices\n    and edges in a single query.\n\n-   A new *TextP.regex* predicate that allows regular expressions to be\n    used when comparing strings.\n\n-   The *property* step can now be given a map of key/value pairs so\n    that several properties can be created at once.\n\n-   A new *element* step that can be used to find the parent element\n    (vertex or edge) of a property.\n\n-   A new *call* step that lays the foundation enabling Gremlin queries\n    to call other endpoints. This opens up many types of interesting use\n    cases such as query federation, and looking up values from other\n    services.\n\n-   A lot of effort has been put into removing unnecessary exceptions by\n    filtering out parts of traversals instead of failing with an error.\n    This is especially so in the case of *by* modulators that now filter\n    when a value does not exist rather than throw an exception. This\n    work began as part of the TinkerPop 3.5.2 update and is completed as\n    of TinkerPop 3.6.0.\n\n-   A new *fail* step that can be used to abort a query in a controlled\n    way.\n\nOver time, new sections will be added to this book that cover each of\nthese features in detail.\n\nAs always, check the level of ApacheTinkerPop the graph database you are\nusing supports before trying to use these new features.\n\n::: note\nFull details of all the new features added in the TinkerPop 3.6.x\nreleases can be found at the following link:\n<https://github.com/apache/tinkerpop/blob/master/CHANGELOG.asciidoc>\n:::",
        "children": []
      },
      {
        "level": "1.9",
        "title": "1.9. So what is a graph database and why should I care? {#whygraph}",
        "content": "This book is mainly intended to be a tutorial in working with graph\ndatabases and related technology using the Gremlin query language.\nHowever, it is worth spending just a few moments to summarize why it is\nimportant to understand what a graph database is, what some good use\ncases for graphs are and why you should care in a world that is already\nfull of all kinds of SQL and NoSQL databases. In this book we are going\nto be discussing *directed property graphs*. At the conceptual level\nthese types of graphs are quite simple to understand. You have three\nbasic building blocks. Vertices (often referred to as nodes), edges and\nproperties. Vertices represent \\\"things\\\" such as people or places.\nEdges represent connections between those vertices, and properties are\ninformation added to the vertices and edges as needed. The *directed*\npart of the name means that any edge has a direction. It goes *out* from\none vertex and *in* to another. You will sometimes hear people use the\nword *digraph* as shorthand for *directed graph*. Consider the\nrelationship \\\"Kelvin knows Jack\\\". This could be modeled as a vertex\nfor each of the people and an edge for the relationship as follows.\n\nKelvin --- knows → Jack\n\nNote the arrow which implies the direction of the relationship. If we\nwanted to record the fact that Jack also admits to knowing Kelvin we\nwould need to add a second edge from Jack to Kelvin. Properties could be\nadded to each person to give more information about them. For example,\nmy age might be a property on my vertex.\n\nIt turns out that Jack really likes cats. We might want to store that in\nour graph as well so we could create the relationship:\n\nJack --- likes → Cats\n\nNow that we have a bit more in our graph we could answer the question\n\\\"who does Kelvin know that likes cats?\\\"\n\nKelvin --- knows → Jack --- likes → Cats\n\nThis is a simple example but hopefully you can already see that we are\nmodelling our data the way we think about it in the real world. Armed\nwith this knowledge you now have all of the basic building blocks you\nneed in order to start thinking about how you might model things you are\nfamiliar with as a graph.\n\nSo getting back to the question \\\"why should I care?\\\", well, if\nsomething looks like a graph, then wouldn't it be great if we could\nmodel it that way. Many things in our everyday lives center around\nthings that can very nicely be represented in a graph. Things such as\nyour social and business networks, the route you take to get to work,\nthe phone network, airline route choices for trips you need to take are\nall great candidates. There are also many great business applications\nfor graph databases and algorithms. These include recommendation\nsystems, crime prevention and fraud detection to name but three.\n\nThe reverse is also true. If something does not feel like a graph then\ndon't try to force it to be. Your videos are probably doing quite nicely\nliving in the object store where you currently have them. A sales ledger\nsystem built using a relational database is probably doing just fine\nwhere it is and likewise a document store is quite possibly just the\nright place to be storing your documents. So \\\"use the right tool for\nthe job\\\" remains as valid a phrase here as elsewhere. Where graph\ndatabases come into their own is when the data you are storing is\nintrinsically linked by its very nature, the air routes network used as\nthe basis for all of the examples in this book being a perfect example\nof such a situation.\n\nThose of you that looked at graphs as part of a computer science course\nare correct if your reaction was \\\"Surely graphs have been around for\nages, why is this considered new?\\\". Indeed, Leonard Euler is credited\nwith demonstrating the first graph problem and inventing the whole\nconcept of \\\"Graph Theory\\\" all the way back in 1763 when he\ninvestigated the now famous \\\"Seven Bridges of Koenigsberg\\\" problem.\n\nIf you want to read a bit more about graph theory and its present-day\napplication, you can find a lot of good information online. Here's a\nWikipedia link to get you started:\n<https://en.wikipedia.org/wiki/Graph_theory>\n\nSo, given Graph Theory is anything but a new idea, why is it that only\nrecently we are seeing a massive growth in the building and deployment\nof graph database systems and applications? At least part of the answer\nis that computer hardware and software has reached the point where you\ncan build large big data systems that scale well for a reasonable price.\nIn fact, it's even easier than ever to build the large systems because\nyou don't have to buy the hardware that your system will run on when you\nuse the cloud.\n\nWhile you can certainly run a graph database on your laptop---​I do just\nthat every day---​the reality is that in production, at scale, they are\nbig data systems. Large graphs commonly have many billions of vertices\nand edges in them, taking up petabytes of data on disk. Graph algorithms\ncan be both compute- and memory-intensive, and it is only fairly\nrecently that deploying the necessary resources for such big data\nsystems has made financial sense for more everyday uses in business, and\nnot just in government or academia. Graph databases are becoming much\nmore broadly adopted across the spectrum, from high-end scientific\nresearch to financial networks and beyond.\n\nAnother factor that has really helped start this graph database\nrevolution is the availability of high-quality open source technology.\nThere are a lot of great open source projects addressing everything from\nthe databases you need to store the graph data, to the query languages\nused to traverse them, all the way up to visually displaying graphs as\npart of the user interface layer. In particular, it is so-called\n*property graphs* where we are seeing the broadest development and\nuptake. In a property graph, both vertices and edges can have properties\n(effectively, key-value pairs) associated with them. There are many\nstyles of graph that you may end up building and there have been whole\nbooks written on these various design patterns, but the property graph\ntechnology we will focus on in this book can support all of the most\ncommon usage patterns. If you hear phrases such as *directed graph* and\n*undirected graph*, or *cyclic* and *acyclic* graph, and many more as\nyou work with graph databases, a quick online search will get you to a\nplace where you can get familiar with that terminology. A deep\ndiscussion of these patterns is beyond the scope of this book, and it's\nin no way essential to have a full background in graph theory to get\nproductive quickly.\n\nA third, and equally important, factor in the growth we are seeing in\ngraph database adoption is the low barrier of entry for programmers. As\nyou will see from the examples in this book, someone wanting to\nexperiment with graph technology can download the Apache TinkerPop\npackage and as long as Java 8 is installed, be up and running with zero\nconfiguration (other than doing an unzip of the files), in as little as\nfive minutes. Graph databases do not force you to define schemas or\nspecify the layout of tables and columns before you can get going and\nstart building a graph. Programmers also seem to find the graph style of\nprogramming quite intuitive as it closely models the way they think of\nthe world.\n\nGraph database technology should not be viewed as a \\\"rip and replace\\\"\ntechnology, but as very much complementary to other databases that you\nmay already have deployed. One common use case is for the graph to be\nused as a form of smart index into other data stores. This is sometimes\ncalled having a polyglot data architecture.",
        "children": []
      },
      {
        "level": "1.10",
        "title": "1.10. A word about terminology {#nodevert}",
        "content": "The words *node* and *vertex* are synonymous when discussing a graph.\nThroughout this book you may find both words used. However, as the\nApache TinkerPop documentation almost exclusively uses the word\n*vertex*, as much as possible when discussing Gremlin queries and other\nconcepts, I endeavor to stick to the word *vertex* or the plural form\n*vertices*. As this book has evolved, I realized my use of these terms\nhad become inconsistent and as I continue to make updates, I plan, with\na few exceptions, such as when discussing binary trees, to standardize\non *vertex* rather than *node*. In that way, this book will be\nconsistent with the official TinkerPop documentation. Similarly, when\ndiscussing the connections between vertices I use the term *edge* or the\nplural form, *edges*. In other books and articles you may also see terms\nlike *relationship* or *arc* used. Again these terms are synonymous in\nthe context of graphs.",
        "children": []
      }
    ]
  },
  {
    "level": "2",
    "title": "2. GETTING STARTED {#gs}",
    "content": "Let's take a look at what you will need to have installed and what tools\nyou will need available to make best use of the examples contained in\nthis tutorial. The key thing that you will need is the Apache TinkerPop\nproject's Gremlin Console download. In the sections below I will walk\nyou through a discussion of what you need to download and how to set it\nup.",
    "children": [
      {
        "level": "2.1",
        "title": "2.1. What is Apache TinkerPop? {#tpintro}",
        "content": "Apache TinkerPop is a graph computing framework and top level project\nhosted by the Apache Software Foundation. The homepage for the project\nis located at this URL: <http://tinkerpop.apache.org/>\n\nGremlin\n\n:   -   A graph traversal (query) language\n\nGremlin Console\n\n:   -   An interactive shell for working with local or remote graphs.\n\n    -   <http://tinkerpop.apache.org/docs/current/reference/#gremlin-console>\n\nGremlin Server\n\n:   -   Allows hosting of graphs remotely via an HTTP/Web Sockets\n        connection.\n\n    -   <http://tinkerpop.apache.org/docs/current/reference/#gremlin-server>\n\nTinkerGraph\n\n:   -   A small in-memory graph implementation that is great for\n        learning.\n\n    -   <http://tinkerpop.apache.org/docs/current/reference/#tinkergraph-gremlin>\n\nProgramming Interfaces\n\n:   -   A set of programming interfaces written in Java\n\n    -   <http://tinkerpop.apache.org/javadocs/current/full/>\n\nDocumentation\n\n:   -   A user guide, a tutorial and programming API documentation.\n\n    -   <http://tinkerpop.apache.org/docs/current/>\n\n    -   <http://tinkerpop.apache.org/docs/current/reference/>\n\nUseful Recipes\n\n:   -   A set of examples or \\\"recipes\\\" showing how to perform common\n        graph oriented tasks using Gremlin queries.\n\n    -   <http://tinkerpop.apache.org/docs/current/recipes/>\n\nThe programming interfaces allow providers of graph databases to build\nsystems that are TinkerPop enabled and allow application programmers to\nwrite programs that talk to those systems.\n\nAny such TinkerPop enabled graph databases can be accessed using the\nGremlin query language and corresponding API. We can also use the\nTinkerPop API to write client code in languages like Java that can talk\nto a TinkerPop enabled graph. For most of this book we will be working\nwithin the Gremlin console with a local graph. However in Chapter 6 we\nwill take a look at Gremlin Server and some other TinkerPop 3 enabled\nenvironments. Most of Apache Tinkerpop has been developed using Java 8\nbut there are also bindings available for many other programming\nlanguages such as Groovy and Python. Parts of TinkerPop are themselves\ndeveloped in Groovy, most notably the Gremlin Console. The nice thing\nabout that is that we can use Groovy syntax along with Gremlin when\nentering queries into the Console or sending them via REST API to a\nGremlin Server. All of these topics are covered in detail in this book.\n\nThe queries used as examples in this book have been tested with Apache\nTinkerPop version 3.5.2 as well as many prior releases. Tests were\nperformed using the TinkerGraph in memory graph and the Gremlin console,\nas well as other TinkerPop 3 enabled graph stores.",
        "children": []
      },
      {
        "level": "2.2",
        "title": "2.2. The Gremlin console {#gconsole}",
        "content": "The Gremlin Console is a fairly standard REPL (Read Eval Print Loop)\nshell. It is based on the Groovy console and if you have used any of the\nother console environments such as those found with Scala, Python and\nRuby you will feel right at home here. The Console offers a low overhead\n(you can set it up in seconds) and low barrier of entry way to start to\nplay with graphs on your local computer. The console can actually work\nwith graphs that are running locally or remotely but for the majority of\nthis book we will keep things simple and focus on local graphs.\n\nTo follow along with this tutorial you will need to have installed the\nGremlin console or have access to a TinkerPop3/Gremlin enabled graph\nstore such as TinkerGraph or JanusGraph.\n\nRegardless of the environment you use, if you work with Apache TinkerPop\nenabled graphs, the Gremlin console should always be installed on your\nmachine!",
        "children": [
          {
            "level": "2.2.1",
            "title": "2.2.1. Downloading, installing and launching the console {#gremlininstall}",
            "content": "You can download the Gremlin console from the official Apache TinkerPop\nwebsite:\n\n<http://tinkerpop.apache.org/>\n\nIt only takes a few minutes to get the Gremlin Console installed and\nrunning. You just download the ZIP file and *unzip* it and you are all\nset. TinkerPop 3 also requires a recent version of Java 8 being\ninstalled. I have done all of my testing using Java 8 version 1.8.0_131.\nThe Gremlin Console will not work with versions prior to 1.8.0_45. If\nyou do not have Java 8 installed it is easy to find and download off the\nWeb. The download also includes all of the JAR files that are needed to\nwrite a standalone Java or Groovy TinkerPop application but that is a\ntopic for later!\n\nWhen you start the Gremlin console you will be presented with a\nbanner/logo and a prompt that will look something like this. Don't worry\nabout the plugin messages yet we will talk about those a bit later.\n\n    $ ./gremlin.sh\n\n             \\,,,/\n             (o o)\n    -----oOOo-(3)-oOOo-----\n    plugin activated: tinkerpop.server\n    plugin activated: tinkerpop.utilities\n    plugin activated: tinkerpop.tinkergraph\n    gremlin>\n\nYou can get a list of the available commands by typing *:help*. Note\nthat all commands to the console itself are prefixed by a colon *\\\":\\\"*.\nThis enables the console to distinguish them as special and different\nfrom actual Gremlin and Groovy commands.\n\n    gremlin> :help\n\n    For information about Groovy, visit:\n        http://groovy-lang.org\n\n    Available commands:\n      :help       (:h  ) Display this help message\n      ?           (:?  ) Alias to: :help\n      :exit       (:x  ) Exit the shell\n      :quit       (:q  ) Alias to: :exit\n      import      (:i  ) Import a class into the namespace\n      :display    (:d  ) Display the current buffer\n      :clear      (:c  ) Clear the buffer and reset the prompt counter\n      :show       (:S  ) Show variables, classes or imports\n      :inspect    (:n  ) Inspect a variable or the last result with the GUI object browser\n      :purge      (:p  ) Purge variables, classes, imports or preferences\n      :edit       (:e  ) Edit the current buffer\n      :load       (:l  ) Load a file or URL into the buffer\n      .           (:.  ) Alias to: :load\n      :save       (:s  ) Save the current buffer to a file\n      :record     (:r  ) Record the current session to a file\n      :history    (:H  ) Display, manage and recall edit-line history\n      :alias      (:a  ) Create an alias\n      :grab       (:g  ) Add a dependency to the shell environment\n      :register   (:rc ) Register a new command with the shell\n      :doc        (:D  ) Open a browser window displaying the doc for the argument\n      :set        (:=  ) Set (or list) preferences\n      :uninstall  (:-  ) Uninstall a Maven library and its dependencies from the Gremlin Console\n      :install    (:+  ) Install a Maven library and its dependencies into the Gremlin Console\n      :plugin     (:pin) Manage plugins for the Console\n      :remote     (:rem) Define a remote connection\n      :submit     (:>  ) Send a Gremlin script to Gremlin Server\n      :bytecode   (:bc ) Gremlin bytecode helper commands\n      :cls        (:C  ) Clear the screen.\n\n    For help on a specific command type:\n        :help command\n\n::: tip\nOf all the commands listed above :clear (:c for short) is an important\none to remember. If the console starts acting strangely or you find\nyourself stuck with a prompt like \\\"...​...​1\\>\\\" , typing *:clear* will\nreset things nicely.\n:::\n\nIt is worth noting that as mentioned above, the Gremlin console is based\non the Groovy console and as such you can enter valid Groovy code\ndirectly into the console. So as well as using it to experiment with\nGraphs and Gremlin you can use it as, for example, a desktop calculator\nshould you so desire!\n\n``` java\ngremlin> 2+3\n==>5\n\ngremlin> a = 5\n==>5\n\ngremlin> println \"The number is ${a}\"\nThe number is 5\n\ngremlin> for (a in 1..5) {print \"${a} \"};println()\n1 2 3 4 5\n```\n\n::: note\nThe Gremlin Console does a very nice job of only showing you a nice and\ntidy set of query results. If you are working with a graph system that\nsupports TinkerPop 3 but not via the Gremlin console (an example of this\nwould be talking to a Gremlin Server using the HTTP REST API) then what\nyou will get back is going to be a JSON document that you will need to\nwrite some code to parse. We will explore that topic much later in the\nbook.\n:::\n\nIf you want to see lots of examples of the output from running various\nqueries you will find plenty in the \\\"[MISCELLANEOUS QUERIES AND THEIR\nRESULTS](#msc)\\\" section of this book where we have tried to go into\nmore depth on various topics.\n\nMostly you will run the Gremlin console in its interactive mode. However\nyou can also pass the name of a file as a command line parameter,\npreceded by the *-e* flag and Gremlin will execute the file and exit.\nFor example if you had a file called \\\"mycode.groovy\\\" you could execute\nit directly from your command line window or terminal window as follows:\n\n    $ ./gremlin.sh -e mycode.groovy\n\nIf you wanted to have the console run your script and not exit\nafterwards, you can use the *-i* option instead of *-e*.\n\nYou can get help on all of the command line options for the Gremlin\nconsole by typing *gremlin \\--help*. You should get back some help text\nthat looks like this\n\n    $ ./gremlin.sh --help\n\n    Usage: gremlin.sh [-CDhlQvV] [-e=<SCRIPT ARG1 ARG2 ...>]... [-i=<SCRIPT ARG1\n                      ARG2 ...>...]...\n      -C, --color     Disable use of ANSI colors\n      -D, --debug     Enabled debug Console output\n      -e, --execute=<SCRIPT ARG1 ARG2 ...>\n                      Execute the specified script (SCRIPT ARG1 ARG2 ...) and close\n                        the console on completion\n      -h, --help      Display this help message\n      -i, --interactive=<SCRIPT ARG1 ARG2 ...>...\n                      Execute the specified script and leave the console open on\n                        completion\n      -l              Set the logging level of components that use standard logging\n                        output independent of the Console\n      -Q, --quiet     Suppress superfluous Console output\n      -v, --version   Display the version\n      -V, --verbose   Enable verbose Console output\n\nIf you ever want to check which version of TinkerPop you have installed\nyou can enter the following command from inside the Gremlin console.\n\n``` java\n// What version of Gremlin console am I running?\ngremlin>  Gremlin.version()\n==>3.4.10\n```\n\nOne thing that is not at all obvious or apparent is that the Gremlin\nconsole quietly imports a large number of Java Classes and Enums on your\nbehalf as it starts up. This makes writing queries within the console\nsimpler. However, as we shall explore in the \\\"[Important Classes and\nEnums to be aware of](#javastatics)\\\" section later, once you start\nwriting standalone programs in Java or other languages, you need to\nactually know what the console did on your behalf. As a teaser for what\ncomes later, try typing *:show imports* when using the Gremlin Console\nand see what it returns.",
            "children": []
          },
          {
            "level": "2.2.2",
            "title": "2.2.2. Saving output from the console to a file {#gremlinsave}",
            "content": "Sometimes it is useful to save part or all of a console session to a\nfile. You can turn recording to a file on and off using the *:record*\ncommand.\n\nIn the following example, we turn recording on using *:record start\nmylog.txt* which will force all commands entered and their output to be\nwritten to the file *mylog.txt* until the command *:record stop* is\nentered. The command *g.V().count().next()* just counts how many\nvertices (nodes) are in the graph. We will explain the Gremlin graph\ntraversal and query language in detail starting in the next section.\n\n``` java\ngremlin> :record start mylog.txt\nRecording session to: \"mylog.txt\"\n\ngremlin> g.V().count().next()\n==>3618\ngremlin> :record stop\nRecording stopped; session saved as: \"mylog.txt\" (157 bytes)\n```\n\nIf we were to look at the *mylog.txt* file, this is what it now\ncontains.\n\n    // OPENED: Tue Sep 12 10:43:40 CDT 2017\n    // RESULT: mylog.txt\n    g.V().count().next()\n    // RESULT: 3618\n    :record stop\n    // CLOSED: Tue Sep 12 10:43:50 CDT 2017\n\nFor the remainder of this book I am not going to show the *gremlin\\>*\nprompt or the *=⇒* output identifier as part of each example, just to\nreduce clutter a bit. You can assume that each command was entered and\ntested using the Gremlin console however.\n\n::: tip\nIf you want to learn more about the console itself you can refer to the\nofficial TinkerPop documentation and, even better, have a play with the\nconsole and the built in help.\n:::",
            "children": []
          }
        ]
      },
      {
        "level": "2.3",
        "title": "2.3. Introducing TinkerGraph {#tgintro}",
        "content": "As well as the Gremlin Console, the TinkerPop 3 download includes an\nimplementation of an in-memory graph store called TinkerGraph. This book\nwas mostly developed using TinkerGraph but I also tested everything\nusing JanusGraph. I will introduce JanusGraph later in the\n\\\"[Introducing JanusGraph](#janusintro)\\\" section. The nice thing about\nTinkerGraph is that for learning and testing things you can run\neverything you need on your laptop or desktop computer and be up and\nrunning very quickly. I will also explain how to get started with the\nGremlin Console and TinkerGraph a bit later in this section.\n\nTinkerpop 3 defines a number of capabilities that a graph store should\nsupport. Some are optional others are not. If supported, you can query\nany TinkerPop 3 enabled graph store to see which features are supported\nusing a command such as *graph.features()* once you have established the\n*graph* object. We will look at how to do that soon. The following list\nshows the features supported by TinkerGraph. This is what you would get\nback should you call the *features* method provided by TinkerGraph. I\nhave arranged the list in two columns to aid readability. Don't worry if\nnot all of these terms make sense right away - we'll get there soon!\n\n::: formalpara-title\n**Output from graph.features()**\n:::\n\n    > GraphFeatures                          > VertexPropertyFeatures\n    >-- ConcurrentAccess: false              >-- UserSuppliedIds: true\n    >-- ThreadedTransactions: false          >-- StringIds: true\n    >-- Persistence: true                    >-- RemoveProperty: true\n    >-- Computer: true                       >-- AddProperty: true\n    >-- Transactions: false                  >-- NumericIds: true\n    > VariableFeatures                       >-- CustomIds: false\n    >-- Variables: true                      >-- AnyIds: true\n    >-- LongValues: true                     >-- UuidIds: true\n    >-- SerializableValues: true             >-- Properties: true\n    >-- FloatArrayValues: true               >-- LongValues: true\n    >-- UniformListValues: true              >-- SerializableValues: true\n    >-- ByteArrayValues: true                >-- FloatArrayValues: true\n    >-- MapValues: true                      >-- UniformListValues: true\n    >-- BooleanArrayValues: true             >-- ByteArrayValues: true\n    >-- MixedListValues: true                >-- MapValues: true\n    >-- BooleanValues: true                  >-- BooleanArrayValues: true\n    >-- DoubleValues: true                   >-- MixedListValues: true\n    >-- IntegerArrayValues: true             >-- BooleanValues: true\n    >-- LongArrayValues: true                >-- DoubleValues: true\n    >-- StringArrayValues: true              >-- IntegerArrayValues: true\n    >-- StringValues: true                   >-- LongArrayValues: true\n    >-- DoubleArrayValues: true              >-- StringArrayValues: true\n    >-- FloatValues: true                    >-- StringValues: true\n    >-- IntegerValues: true                  >-- DoubleArrayValues: true\n    >-- ByteValues: true                     >-- FloatValues: true\n    > VertexFeatures                         >-- IntegerValues: true\n    >-- AddVertices: true                    >-- ByteValues: true\n    >-- DuplicateMultiProperties: true       > EdgePropertyFeatures\n    >-- MultiProperties: true                >-- Properties: true\n    >-- RemoveVertices: true                 >-- LongValues: true\n    >-- MetaProperties: true                 >-- SerializableValues: true\n    >-- UserSuppliedIds: true                >-- FloatArrayValues: true\n    >-- StringIds: true                      >-- UniformListValues: true\n    >-- RemoveProperty: true                 >-- ByteArrayValues: true\n    >-- AddProperty: true                    >-- MapValues: true\n    >-- NumericIds: true                     >-- BooleanArrayValues: true\n    >-- CustomIds: false                     >-- MixedListValues: true\n    >-- AnyIds: true                         >-- BooleanValues: true\n    >-- UuidIds: true                        >-- DoubleValues: true\n    > EdgeFeatures                           >-- IntegerArrayValues: true\n    >-- RemoveEdges: true                    >-- LongArrayValues: true\n    >-- AddEdges: true                       >-- StringArrayValues: true\n    >-- UserSuppliedIds: true                >-- StringValues: true\n    >-- StringIds: true                      >-- DoubleArrayValues: true\n    >-- RemoveProperty: true                 >-- FloatValues: true\n    >-- AddProperty: true                    >-- IntegerValues: true\n    >-- NumericIds: true                     >-- ByteValues: true\n    >-- CustomIds: false\n    >-- AnyIds: true\n    >-- UuidIds: true\n\nTinkerGraph is really useful while learning to work with Gremlin and\ngreat for testing things out. One common use case where TinkerGraph can\nbe very useful is to create a sub-graph of a large graph and work with\nit locally. TinkerGraph can even be used in production deployments if an\nall in memory graph fits the bill. Typically, TinkerGraph is used to\nexplore static (unchanging) graphs but you can also use it from a\nprogramming language like Java and mutate its contents if you want to.\nHowever, TinkerGraph does not support some of the more advanced features\nyou will find in implementations like JanusGraph such as transactions\nand external indexes. I will cover these topics as part of the\ndiscussion of JanusGraph in the [Introducing JanusGraph](#janusintro)\nsection later on. One other thing worth noting in the list above is that\n*UserSuppliedIds* is set to true for vertex and edge ID values. This\nmeans that if you load a graph file, such as a GraphML format file, that\nspecifies ID values for vertices and edges then TinkerGraph will honor\nthose IDs and use them. As we shall see later this is not the case with\nsome other graph database systems.\n\nWhen running in the Gremlin Console, support for TinkerGraph should be\non by default. If for any reason you find it to be off you, can enable\nit by issuing the following command.\n\n``` java\n:plugin use tinkerpop.tinkergraph\n```\n\nOnce the TinkerGraph plugin is enabled you will need to close and\nre-load the Gremlin console. After doing that, you can create a new\nTinkerGraph instance from the console as follows.\n\n``` java\ngraph = TinkerGraph.open()\n```\n\nIn many cases you will want to pass parameters to the *open* method that\ngive more information on how the graph is to be configured. We will\nexplore those options later on. Before you can start to issue Gremlin\nqueries against the graph you also need to establish a graph traversal\nsource object by calling the new graph's *traversal* method as follows.\n\n``` java\ng = graph.traversal()\n```\n\n::: note\nThroughout the remainder of this book the following convention will be\nused. The variable name *graph* will be used for any object that\nrepresents a graph instance and the variable name *g* will be used for\nany object that represents an instance of a graph traversal source\nobject.\n:::",
        "children": []
      },
      {
        "level": "2.4",
        "title": "2.4. Introducing the air-routes graph {#air}",
        "content": "Along with this book I have provided what is, in big data terms, a very\nsmall, but nonetheless real-world graph that is stored in GraphML, a\nstandard XML format for describing graphs that can be used to move\ngraphs between applications. The graph, *air-routes* is a model I built\nof the world airline route network that is fairly accurate.\n\n::: note\nThe `air-routes.graphml` file can be downloded from the `sample-data`\nfolder located in the GitHub repository at the following URL:\n<https://github.com/krlawrence/graph/tree/main/sample-data>\n:::\n\nOf course, in the real world, routes are added and deleted by airlines\nall the time so please don't use this graph to plan your next vacation\nor business trip! However, as a learning tool I hope you will find it\nuseful and easy to relate to. If you feel so inclined you can load the\nfile into a text editor and examine how it is laid out. As you work with\ngraphs you will want to become familiar with popular graph serialization\nformats. Two common ones are GraphML and GraphSON. The latter is a JSON\nformat that is defined by Apache TinkerPop and heavily used in that\nenvironment. GraphML is widely recognized by TinkerPop and many other\ntools as well such as Gephi, a popular open source tool for visualizing\ngraph data. A lot of graph ingestion tools also still use comma\nseparated values (CSV) format files.\n\nWe will briefly look at loading and saving graph data in Sections 2 and\n4. I take a look at different ways to work with graph data stored in\ntext format files including importing and exporting graph data in the\n\\\"[COMMON GRAPH SERIALIZATION FORMATS](#serialize)\\\" section towards the\nend of the book.\n\nThe *air-routes* graph contains several vertex types that are specified\nusing labels. The most common ones being *airport* and *country*. There\nare also vertices for each of the seven continents (*continent*) and a\nsingle *version* vertex that I provided as a way to test which version\nof the graph you are using.\n\nRoutes between airports are modeled as edges. These edges carry the\n*route* label and include the distance between the two connected airport\nvertices as a property called *dist*. Connections between countries and\nairports are modelled using an edge with a *contains* label.\n\nEach airport vertex has many properties associated with it giving\nvarious details about that airport including its IATA and ICAO codes,\nits description, the city it is in and its geographic location.\n\nSpecifically, each airport vertex has a unique ID, a label of *airport*\nand contains the following properties. The word in parenthesis indicates\nthe type of the property.\n\n     type    (string) : Vertex type. Will be 'airport' for airport vertices\n     code    (string) : The three letter IATA code like AUS or LHR\n     icao    (string) : The four letter ICAO code or none. Example KAUS or EGLL\n     desc    (string) : A text description of the airport\n     region  (string) : The geographical region like US-TX or GB-ENG\n     runways (int)    : The number of available runways\n     longest (int)    : Length of the longest runway in feet\n     elev    (int)    : Elevation in feet above sea level\n     country (string) : Two letter ISO country code such as US, FR or DE.\n     city    (string) : The name of the city the airport is in\n     lat     (double) : Latitude of the airport\n     lon     (double) : Longitude of the airport\n\nWe can use Gremlin once the air route graph is loaded to show us what\nproperties an airport vertex has. As an example here is what the Austin\nairport vertex looks like. I will explain the steps that make up the\nGremlin query shortly. First we need to dig a little bit into how to\nload the data and configure a few preferences.\n\n``` java\n// Query the properties of vertex 3\ng.V().has('code','AUS').valueMap(true).unfold()\n\nid=3\nlabel=airport\ntype=[airport]\ncode=[AUS]\nicao=[KAUS]\ndesc=[Austin Bergstrom International Airport]\nregion=[US-TX]\nrunways=[2]\nlongest=[12250]\nelev=[542]\ncountry=[US]\ncity=[Austin]\nlat=[30.1944999694824]\nlon=[-97.6698989868164]\n```\n\nEven though the airport vertex label is *airport* I chose to also have a\nproperty called *type* that also contains the string *airport*. This was\ndone to aid with indexing when working with other graph database systems\nand is explained in more detail later in this book.\n\nYou may have noticed that the values for each property are represented\nas lists (or arrays if you prefer), even though each list only contains\none element. The reasons for this will be explored later in this book\nbut the quick explanation is that this is because TinkerPop allows us to\nassociate a list of values with any vertex property. We will explore\nways that you can take advantage of this capability in the \\\"[Attaching\nmultiple values (lists or sets) to a single property](#listprop)\\\"\nsection.\n\nThe full details of all the features contained in the *air-routes* graph\ncan be learned by reading the comments at the start of the\n`air-routes.graphml` file or reading the `README.txt` file.\n\nThe graph currently contains a total of 3,619 vertices and 50,148 edges.\nOf these 3,374 vertices are airports, and 43,400 of the edges represent\nroutes. While in big data terms this is really a tiny graph, it is\nplenty big enough for us to build up and experiment with some very\ninteresting Gremlin queries.\n\nLastly, here are some statistics and facts about the *air-routes* graph.\nIf you want to see a lot more statistics check the `README.txt` file\nthat is included with the *air-routes* graph.\n\n    Air Routes Graph (v0.77, 2017-Oct-06) contains:\n      3,374 airports\n      43,400 routes\n      237 countries (and dependent areas)\n      7 continents\n      3,619 total nodes\n      50,148 total edges\n\n    Additional observations:\n      Longest route is between DOH and AKL (9,025 miles)\n      Shortest route is between WRY and PPW (2 miles)\n      Average route distance is 1,164.747 miles.\n      Longest runway is 18,045ft (BPX)\n      Shortest runway is 1,300ft (SAB)\n      Furthest North is LYR (latitude: 78.2461013793945)\n      Furthest South is USH (latitude: -54.8433)\n      Furthest East is SVU (longitude: 179.341003418)\n      Furthest West is TVU (longitude: -179.876998901)\n      Closest to the Equator is MDK (latitude: 0.0226000007242)\n      Closest to the Greenwich meridian is LDE (longitude: -0.006438999902457)\n      Highest elevation is DCY (14,472 feet)\n      Lowest elevation is GUW (-72 feet)\n      Maximum airport node degree (routes in and out) is 544 (FRA)\n      Country with the most airports: United States (579)\n      Continent with the most airports: North America (978)\n      Average degree (airport nodes) is 25.726\n      Average degree (all nodes) is 25.856\n\nHere are the Top 15 airports sorted by overall number of routes (in and\nout). In graph terminology this is often called the degree of the vertex\nor just *vertex degree*.\n\n        POS   ID  CODE  TOTAL     DETAILS\n\n         1    52   FRA  (544)  out:272 in:272\n         2    70   AMS  (541)  out:269 in:272\n         3   161   IST  (540)  out:270 in:270\n         4    51   CDG  (524)  out:262 in:262\n         5    80   MUC  (474)  out:237 in:237\n         6    64   PEK  (469)  out:234 in:235\n         7    18   ORD  (464)  out:232 in:232\n         8     1   ATL  (464)  out:232 in:232\n         9    58   DXB  (458)  out:229 in:229\n        10     8   DFW  (442)  out:221 in:221\n        11   102   DME  (428)  out:214 in:214\n        12    67   PVG  (402)  out:201 in:201\n        13    50   LGW  (400)  out:200 in:200\n        14    13   LAX  (390)  out:195 in:195\n        15    74   MAD  (384)  out:192 in:192\n\nThroughout this book you will find Gremlin queries that can be used to\ngenerate many of these statistics.\n\n::: note\nThere is a sample script called *graph-stats.groovy* in the GitHub\nrepository located in the *sample-code* folder that shows how to\ngenerate some statistics about the graph. The script can be found at the\nfollowing URL:\n<https://github.com/krlawrence/graph/tree/main/sample-code>\n:::",
        "children": [
          {
            "level": "2.4.1",
            "title": "2.4.1. Updated versions of the air-route data {#airrouteupdates}",
            "content": "To keep things consistent, all of the examples presented in this book\nwere produced using the same version of the air-routes data set. That\ndata set was generated in October 2017. While I felt it was important\nthat the examples remained consistent that does also mean that some of\nthe examples shown in the book, such as the longest airline route\ncurrently being flown, are out of date.\n\n::: tip\nYou can download the very latest air-routes data set from\n<https://github.com/krlawrence/graph/blob/main/sample-data/air-routes-latest.graphml>\n:::\n\nIf you want to get the most up to date results there is a newer version\nof the data set available. That file can be found in the *sample-data*\nfolder. Look for a file called `air-routes-latest.graphml`. There is\nalso a README file to go along with the updated data set called\n`README-air-routes-latest.txt` in the same folder.",
            "children": []
          }
        ]
      },
      {
        "level": "2.5",
        "title": "2.5. TinkerPop 3 migration notes {#mn}",
        "content": "There are still a large number of examples on the internet that show the\nTinkerPop 2 way of doing things. Quite a lot of things changed between\nTinkerPop 2 and TinkerPop 3. If you were an early adopter and are coming\nfrom a TinkerPop 2 environment to a TinkerPop 3 environment you may find\nsome of the tips in this section helpful. As explained below, using the\n*sugar* plugin will make the migration from TinkerPop 2 easier but it is\nrecommended to learn the full TinkerPop 3 Gremlin syntax and get used to\nusing that as soon as possible. Using the full syntax will make your\nqueries a lot more portable to other TinkerPop 3 enabled graph systems.\n\nTinkerPop 3 requires a minimum of Java 8 v45. It will not run on earlier\nversions of Java 8 based on my testing.",
        "children": [
          {
            "level": "2.5.1",
            "title": "2.5.1. Creating a TinkerGraph TP2 vs TP3 {#cr}",
            "content": "The way that you create a TinkerGraph changed between TinkerPop 2 and 3.\n\n``` java\ngraph = new TinkerGraph()  // TinkerPop 2\ngraph = TinkerGraph.open() // TinkerPop 3\n```",
            "children": []
          },
          {
            "level": "2.5.2",
            "title": "2.5.2. Loading a graphML file TP2 vs TP3 {#ld2}",
            "content": "If you have previous experience with TinkerPop 2 you may also have\nnoticed that the way a graph is loaded has changed in TinkerPop 3.\n\n``` java\ngraph.loadGraphML('air-routes.graphml') // TinkerPop 2\ngraph.io(graphml()).readGraph('air-routes.graphml') // TinkerPop 3\n```\n\nThe Gremlin language itself changed quite a bit between TinkerPop 2 and\nTinkerPop 3. The remainder of this book only shows TinkerPop 3 examples.",
            "children": []
          },
          {
            "level": "2.5.3",
            "title": "2.5.3. A word about the TinkerPop.sugar plugin {#sugarplugin}",
            "content": "The Gremlin console has a set of plug in modules that can be\nindependently enabled or disabled. Depending upon your use case you may\nor may not need to manage plugins.\n\nTinkerPop 2 supported by default some syntactic *sugar* that allowed\nshorthand forms of queries to be entered when using the Gremlin console.\nIn TinkerPop 3 that support has been moved to a plugin and is off by\ndefault. It has to be enabled if you want to continue to use the same\nshortcuts that TinkerPop 2 allowed by default.\n\nYou can enable *sugar* support from the Gremlin console as follows:\n\n``` java\n:plugin use tinkerpop.sugar\n```\n\n::: tip\nThe Gremlin Console remembers which plugins are enabled between\nrestarts.\n:::\n\nIn the current revision of this book I have tried to remove any\ndependence on the *TinkerPop.sugar* plugin from the examples presented.\nBy not using Sugar, queries shown in this book should port very easily\nto other TinkerPop 3 enabled graph platforms. A few of the queries may\nnot work on versions of TinkerPop prior to 3.2 as TinkerPop continues to\nevolve and new features are being added fairly regularly.\n\nThe *Tinkerpop.sugar* plugin allows some queries to be expressed in a\nmore shorthand or lazy form, often leaving out references to *values()*\nand leaving out parenthesis. For example:\n\n``` java\n// With Sugar enabled\ng.V.hasLabel('airport').code\n\n// Without Sugar enabled\ng.V().hasLabel('airport').values('code')\n```\n\nPeople Migrating from TinkerPop 2 will find the Sugar plugin helps get\nyour existing queries running more easily but as a general rule it is\nrecommended to become familiar with the longhand way of writing queries\nas that will enable your queries to run as efficiently as possible on\ngraph stores that support TinkerPop 3. Also, due to changes introduced\nwith TinkerPop 3, using sugar will not be as performant as using the\nnormal Gremlin syntax.\n\n::: note\n*In earlier versions of this book many of the examples showed the\n*sugar* form. In the current revision I have tried to remove all use of\nthat form. It's possible that I may have missed a few and I will\ncontinue to check for, and fix, any that got missed. Please let me know\nif you find any that slipped through the net!*\n:::",
            "children": []
          }
        ]
      },
      {
        "level": "2.6",
        "title": "2.6. Loading the air-routes graph using the Gremlin console {#ld}",
        "content": "Here is some code you can load the air routes graph using the gremlin\nconsole by putting it into a file and using *:load* to load and run it\nor by entering each line into the console manually. These commands will\nsetup the console environment, create a TinkerGraph graph and load the\n`air-routes.graphml` file into it. Some extra console features are also\nenabled.\n\n::: note\nThere is a file called `load-air-routes-graph.groovy`, that contains the\ncommands shown below, available in the `/sample-data` directory.\n<https://github.com/krlawrence/graph/tree/main/sample-data>\n:::\n\nThese commands create an in-memory TinkerGraph which will use LONG\nvalues for the vertex, edge and vertex property IDs. TinkerPop 3\nintroduced the concept of a *traversal* so as part of loading a *graph*\nwe also setup a graph traversal source object called *g* which we will\nthen refer to in our subsequent queries of the graph. The\n*max-iteration* option tells the Gremlin console the maximum number of\nlines of output that we ever want to see in return from a query. The\ndefault, if this is not specified, is 100.\n\n::: tip\nYou can use the *max-iteration* setting to control how much output the\nGremlin Console displays.\n:::\n\nIf you are using a different graph environment and GraphML import is\nsupported, you can still load the `air-routes.graphml` file by following\nthe instructions specific to that system. Once loaded, the queries below\nshould still work either unchanged or with minor modifications.\n\n::: formalpara-title\n**load-air-routes-graph.groovy**\n:::\n\n``` java\nconf = new BaseConfiguration()\nconf.setProperty(\"gremlin.tinkergraph.vertexIdManager\",\"LONG\")\nconf.setProperty(\"gremlin.tinkergraph.edgeIdManager\",\"LONG\")\nconf.setProperty(\"gremlin.tinkergraph.vertexPropertyIdManager\",\"LONG\");[]\ngraph = TinkerGraph.open(conf)\ngraph.io(graphml()).readGraph('air-routes.graphml')\ng=graph.traversal()\n:set max-iteration 1000\n```\n\n::: note\nSetting the ID manager as shown above is important. If you do not do\nthis, by default, when using TinkerGraph, ID values will have to be\nspecified as strings such as *\\\"3\\\"* rather than just the numeral *3*.\n:::\n\nIf you download the `load-air-routes-graph.groovy` file, once the\nconsole is up and running you can load that file by entering the command\nbelow. Doing this will save you a fair bit of time as each time you\nrestart the console you can just reload your configuration file and the\nenvironment will be configured and the graph loaded and you can get\nstraight to writing queries.\n\n``` java\n:load load-air-routes-graph.groovy\n```\n\n::: tip\nAs a best practice you should use the full path to the location where\nthe GraphML file resides if at all possible to make sure that the\nGraphML reading code can find it.\n:::\n\nOnce you have the Gremlin Console up and running and have the graph\nloaded, if you feel like it you can cut and paste queries from this book\ndirectly into the console to see them run.\n\nOnce the *air-routes* graph is loaded you can enter the following\ncommand and you will get back information about the graph. In the case\nof a TinkerGraph you will get back a useful message telling you how many\nvertices and edges the graph contains. Note that the contents of this\nmessage will vary from one graph system to another and should not be\nrelied upon as a way to keep track of vertex and edge counts. We will\nlook at some other ways of counting things a bit later.\n\n``` java\n// Tell me something about my graph\ngraph.toString()\n```\n\nWhen using TinkerGraph, the message you get back will look something\nlike this.\n\n``` java\ntinkergraph[vertices:3610 edges:49490]\n```",
        "children": []
      },
      {
        "level": "2.7",
        "title": "2.7. Turning off some of the Gremlin console's output {#off}",
        "content": "Sometimes, especially when assigning a result to a variable and you are\nnot interested in seeing all the steps that Gremlin took to get there,\nthe Gremlin console displays more output than is desirable. An easy way\nto prevent this is to just add an empty list \\\";\\[\\]\\\" to the end of\nyour query as follows.\n\n``` java\na=g.V().has('code','AUS').out().toList();[]\n```",
        "children": []
      },
      {
        "level": "2.8",
        "title": "2.8. A word about indexes and schemas {#indexschema}",
        "content": "Some graph implementations have strict requirements on the use of an\n*index*. This means that a schema and an index must be in place before\nyou can work with a graph and that you can only begin a traversal by\nreferencing a property in the graph that is included in the index. While\nthat is, for the most part, outside the scope of this book, it should be\npointed out that some of the queries included in this material will not\nwork on any graph system that requires all queries to be backed by an\nindex. Such graph stores tend not to allow what are sometimes called\n*full graph searches* for cases where a particular item in a graph is\nnot backed by an index. One example of this is vertex and edge *labels*\nwhich are typically not indexed but are sometimes very useful items to\nspecify at the start of a query. As most of the examples in this book\nare intended to work just fine with only a basic TinkerGraph the subject\nof indexes is not covered in detail until Chapter 6 \\\"[MOVING BEYOND THE\nCONSOLE AND TINKERGRAPH](#beyond)\\\" . However, as TinkerGraph does have\nsome indexing capability I have also included some discussion of it in\nthe \\\"[Introducing TinkerGraph indexes](#tinkerindex)\\\" section. In\nChapter 6 where I start to look at additional technologies such as\nJanusGraph I have included a more in depth discussion of indexing as\npart of that coverage. You should always refer to the specific\ndocumentation for the graph system you are using to decide what you need\nto do about creating an index and schema for your graph. I will explain\nwhat TinkerGraph is in the next section. I won't be discussing the\ncreation of an explicit schema again until Chapter 6. When working with\nTinkerGraph there is no need to define a schema ahead of time. The types\nof each property are derived at creation time. This is a really\nconvenient feature and allows us to get productive and do some\nexperimenting really quickly.\n\n::: note\nIn production systems, especially those where the graphs are large, the\ntask of creating and managing the parts of the index is often handed to\nan additional software component such as Apache Solr or Elasticsearch.\n:::\n\nIn general for any graph database, regardless of whether it is optional\nor not, use of an index should be considered a best practice. As I\nmentioned, even TinkerGraph has a way to create an index should you want\nto.",
        "children": []
      }
    ]
  },
  {
    "level": "3",
    "title": "3. WRITING GREMLIN QUERIES {#gq}",
    "content": "Now that you hopefully have the *air-routes* graph loaded it's time to\nstart writing some queries!\n\n::: note\nChapter 3 is focussed on queries that simply read from an existing\ngraph. If you are more interested in adding new vertices, edges and\nproperties or modifying existing properties you may want to jump to\nChapter 4 and in particular the \\\"[Adding vertices, edges and\nproperties](#addnodes)\\\" section.\n:::\n\nIn this chapter we will begin to look at the Gremlin query language. I\nwill start off with a quick look at how Gremlin and SQL differ and are\nyet in some ways similar, then present some fairly basic queries and\nfinally get into some more advanced concepts. Hopefully each set of\nexamples presented, building upon things previously discussed, will be\neasy to understand.",
    "children": [
      {
        "level": "3.1",
        "title": "3.1. Introducing Gremlin {#gremlinintro}",
        "content": "Gremlin is the name of the graph traversal and query language that\nTinkerPop provides for working with property graphs. Gremlin can be used\nwith any graph store that is Apache TinkerPop enabled. Gremlin is a\nfairly imperative language but also has some more declarative constructs\nas well. Using Gremlin we can traverse a graph looking for values,\npatterns and relationships we can add or delete vertices and edges, we\ncan create sub-graphs and lots more.",
        "children": [
          {
            "level": "3.1.1",
            "title": "3.1.1. A quick look at Gremlin and SQL {#gremlinandsql}",
            "content": "While it is not required to know SQL in order to be productive with\nGremlin, if you do have some experience with SQL you will notice many of\nthe same keywords and phrases being used in Gremlin. As a simple example\nthe SQL and Gremlin examples below both show how we might count the\nnumber of airports there are in each country using firstly a relational\ndatabase and secondly a property graph.\n\nWhen working with a relational database, we might decide to store all of\nthe airport data in a single table called *airports*. In a very simple\ncase (the air routes graph actually stores a lot more data than this\nabout each airport) we could setup our airports table so that it had\nentries for each airport as follows.\n\n    ID   CODE  ICAO  CITY             COUNTRY\n    ---  ----  ----  ---------------  ----------\n    1    ATL   KATL  Atlanta          US\n    3    AUS   KAUS  Austin           US\n    8    DFW   KDFW  Dallas           US\n    47   YYZ   CYYZ  Toronto          CA\n    49   LHR   EGLL  London           UK\n    51   CDG   LFPG  Paris            FR\n    52   FRA   EDDF  Frankfurt        DE\n    55   SYD   YSSY  Sydney           AU\n\nWe could then use a SQL query to count the distribution of airports in\neach country as follows.\n\n``` sql\nselect country,count(country) from airports group by country;\n```\n\nWe can do this in Gremlin using the *air-routes* graph with a query like\nthe one below (I will explain what all of this means later on in the\nbook).\n\n``` java\ng.V().hasLabel('airport').groupCount().by('country')\n```\n\nYou will discover that Gremlin provides its own flavor of several\nconstructs that you will be familiar with if you have used SQL before,\nbut again, prior knowledge of SQL is in no way required to learn\nGremlin.\n\nOne thing you will not find when working with a graph using Gremlin is\nthe concept of a SQL *join*. Graph databases by their very nature avoid\nthe need to join things together (as things that need to be connected\nalready are connected) and this is a core reason why, for many use\ncases, Graph databases are a very good choice and can be more performant\nthan relational databases.\n\nGraph databases are usually a good choice for storing and modelling\nnetworks. The *air-routes* graph is an example of a network graph. A\nsocial network is of course another good example. Networks can be\nmodelled using relational databases too but as you explore the network\nand ask questions like \\\"who are my friends\\' friends?\\\" in a social\nnetwork or \\\"where can I fly to from here with a maximum of two stops?\\\"\nthings rapidly get complicated and result in the need for multiple\n*joins*.\n\nAs an example, imagine adding a second table to our relational database\ncalled routes. It will contain three columns representing the source\nairport, the destination airport and the distance between them in miles\n(SRC,DEST and DIST). It would contain entries that looked like this (the\nreal table would of course have thousands of rows but this gives a good\nidea of what the table would look like).\n\n    SRC  DEST  DIST\n    ---  ----  ----\n    ATL  DFW   729\n    ATL  FRA   4600\n    AUS  DFW   190\n    AUS  LHR   4901\n    BOM  AGR   644\n    BOM  LHR   4479\n    CDG  DFW   4933\n    CDG  FRA   278\n    CDG  LHR   216\n    DFW  FRA   5127\n    DFW  LHR   4736\n    LHR  BOM   4479\n    LHR  FRA   406\n    YYZ  FRA   3938\n    YYZ  LHR   3544\n\nIf we wanted to write a SQL query to calculate the ways of travelling\nfrom Austin (AUS) to Agra (AGR) with two stops, we would end up writing\na query that looked something like this:\n\n``` sql\nselect a1.code,r1.dest,r2.dest,r3.dest from airports a1\n  join routes r1 on a1.code=r1.src\n  join routes r2 on r1.dest=r2.src\n  join routes r3 on r2.dest=r3.src\n  where a1.code='AUS' and r3.dest='AGR';\n```\n\nUsing our *air-routes* graph database the query can be expressed quite\nsimply as follows:\n\n``` java\ng.V().has('code','AUS').out().out().out().has('code','AGR').path().by('code')\n```\n\nAdding or removing hops is as simple as adding or removing one or more\nof the *out()* steps which is a lot simpler than having to add\nadditional *join* clauses to our SQL query. This is a simple example,\nbut as queries get more and more complicated in heavily connected data\nsets like networks, the SQL queries get harder and harder to write\nwhereas, because Gremlin is designed for working with this type of data,\nexpressing a traversal remains fairly straightforward.\n\nWe can go one step further with Gremlin and use *repeat* to express the\nconcept of *three times* as follows.\n\n``` java\ng.V().has('code','AUS').repeat(out()).times(3).has('code','AGR').path().by('code')\n```\n\nGremlin also has a *repeat ...​ until* construct that we will see used\nlater in this book. When combined with the *emit* step, *repeat*\nprovides a nice way of getting back any routes between a source and\ndestination no matter how many hops it might take to get there.\n\nAgain, don't worry if some of the Gremlin steps shown here are\nconfusing, we will cover them all in detail a bit later. The key point\nto take away from this discussion of SQL and Gremlin is that for data\nthat is very connected, Graph databases provide a very good way to store\nthat data and Gremlin provides a nice and fairly intuitive way to\ntraverse that data efficiently.\n\nOne other point worthy of note is that every vertex and every edge in a\ngraph has a unique ID. Unlike in the relational world where you may or\nmay not decide to give a table an ID column this is not optional with\ngraph databases. In some cases the ID can be a user provided ID but more\ncommonly it will be generated by the graph system when a vertex or edge\nis first created. If you are familiar with SQL, you can think of the ID\nas a primary key of sorts if you want to. Every vertex and edge can be\naccessed using its ID. Just as with relational databases, graph\ndatabases can be indexed and any of the properties contained in a vertex\nor an edge can be added to the index and can be used to find things\nefficiently. In large graph deployments this greatly speeds up the\nprocess of finding things as you would expect. We look more closely at\nIDs in the [Working with IDs](#wid) section.",
            "children": []
          }
        ]
      },
      {
        "level": "3.2",
        "title": "3.2. Some fairly basic Gremlin queries {#bq}",
        "content": "A graph *query* is often referred to as a *traversal* as that is what we\nare in fact doing. We are traversing the graph from a starting point to\nan ending point. Traversals consist of one or more *steps* (essentially\nmethods) that are chained together.\n\nAs we start to look at some simple traversals here are a few *steps*\nthat you will see used a lot. Firstly, you will notice that almost all\ntraversals start with either a *g.V()* or a *g.E()*. Sometimes there\nwill be parameters specified along with those steps but we will get into\nthat a little later. You may remember from when we looked at how to load\nthe *air-routes* graph in Section 2 we used the following instruction to\ncreate a graph traversal source object for our loaded *graph*.\n\n``` java\ng = graph.traversal()\n```\n\nOnce we have a graph traversal source object we can use it to start\nexploring the graph. The *V* step returns vertices and the *E* step\nreturns edges. You can also use a *V* step in the middle of a traversal\nas well as at the start but we will examine those uses a little later.\nThe *V* and *E* steps can also take parameters indicating which set of\nvertices or edges we are interested in. That usage is explained in the\n\\\"[Working with IDs](#wid)\\\" section.\n\n::: tip\nIf it helps with remembering you can think of *g.V()* as meaning\n\\\"looking at all of the vertices in the graph\\\" and *g.E()* as meaning\n\\\"looking at all of the edges in the graph\\\". We then add additional\nsteps to narrow down our search criteria.\n:::\n\nThe other steps we need to introduce are the *has* and *hasLabel* steps.\nThey can be used to test for a certain label or property having a\ncertain value. We will encounter a lot of different Gremlin steps as we\nexplore various Gremlin queries throughout the book, including many\nother forms of the *has* step, but these few are enough to get us\nstarted.\n\nYou can refer to the official Apache TinkerPop documentation for full\ndetails on all of the graph traversal steps that are used in this\ntutorial. With this tutorial I have not tried to teach every possible\nusage of every Gremlin step and method, rather, I have tried to provide\na good and approachable foundation in writing many different types of\nGremlin query using an interesting and real-world graph.\n\n::: note\nThe latest TinkerPop 3 documentation is always available at this URL:\n<http://tinkerpop.apache.org/docs/current/reference/>\n:::\n\nBelow are some simple queries against the *air-routes* graph to get us\nstarted. It is assumed that the *air-routes* graph has been loaded\nalready per the instructions above. The query below will return any\nvertices (nodes) that have the *airport* label.\n\n``` java\n// Find vertices that are airports\ng.V().hasLabel('airport')\n```\n\nThis query will return the vertex that represents the Dallas Fort Worth\n(DFW) airport.\n\n``` java\n// Find the DFW vertex\ng.V().has('code','DFW')\n```\n\nThe next two queries combine the previous two into a single query. The\nfirst one just chains the queries together. The second shows a form of\nthe *has* step that we have not looked at before that takes an\nadditional label value as its first parameter.\n\n``` java\n// Combining those two previous queries (two ways that are equivalent)\ng.V().hasLabel('airport').has('code','DFW')\n\ng.V().has('airport','code','DFW')\n```\n\nHere is what we get back from the query. Notice that this is the Gremlin\nConsole's way of telling us we got back the *Vertex* with an ID of 8.\n\n``` java\nv[8]\n```\n\nSo, what we actually got back from these queries was a TinkerPop\n*Vertex* data structure. Later in this book we will look at ways to\nstore that value into a variable for additional processing. Remember\nthat even though we are working with a Groovy environment while inside\nthe Gremlin Console, everything we are working with here, at its core,\nis Java code. So we can use the *getClass* method from Java to\nintrospect the object. Note the call to *next* which turns the result of\nthe traversal into an object we can work with further.\n\n``` java\ng.V().has('airport','code','DFW').next().getClass()\n\nclass org.apache.tinkerpop.gremlin.tinkergraph.structure.TinkerVertex\n```\n\nThe *next* step that we used above is one of a series of steps that the\nTinkerpop documentation describes as *terminal steps*. We will see more\nof these *terminal steps* in use throughout this book. As mentioned\nabove, a terminal step essentially ends the graph traversal and returns\na concrete object that you can work with further in your application.\nYou will see *next* and other related steps used in this way when we\nstart to look at using Gremlin from a standalone program a bit later on.\nWe could even add a call to *getMethods()* at the end of the query above\nto get back a list of all the methods and their types supported by the\n*TinkerVertex* class.",
        "children": [
          {
            "level": "3.2.1",
            "title": "3.2.1. Retrieving property values from a vertex {#values}",
            "content": "There are several different ways of working with vertex properties. We\ncan add, delete and query properties for any vertex or edge in the\ngraph. We will explore each of these topics in detail over the course of\nthis book. Initially, let's look at a couple of simple ways that we can\nlook up the property values of a given vertex.\n\n``` java\n// What property values are stored in the DFW vertex?\ng.V().has('airport','code','DFW').values()\n```\n\nHere is the output that the query returns. Note that we just get back\nthe values of the properties when using the *values* step, we do not get\nback the associated keys. We will see how to do that later in the book.\n\n``` java\nUS\nDFW\n13401\nDallas\n607\nKDFW\n-97.0380020141602\nairport\nUS-TX\n7\n32.896800994873\nDallas/Fort Worth International Airport\n```\n\nThe *values* step can take parameters that tell it to only return the\nvalues for the provided key names. The queries below return the values\nof some specific properties.\n\n``` java\n// Return just the city name property\ng.V().has('airport','code','DFW').values('city')\n\nDallas\n\n// Return the 'runways' and 'icao' property values.\ng.V().has('airport','code','DFW').values('runways','icao')\n\nKDFW\n7\n```",
            "children": []
          },
          {
            "level": "3.2.2",
            "title": "3.2.2. Does a specific property exist on a given vertex or edge? {#exist}",
            "content": "You can simply test to see if a property exists as well as testing for\nit containing a specific value. To do this we can just provide *has*\nwith the name of the property we are interested in. This works equally\nwell for both vertex and edge properties.\n\n``` java\n// Find all edges that have a 'dist' property\ng.E().has('dist')\n\n// Find all vertices that have a 'region' property\ng.V().has('region')\n\n// Find all the vertices that do not have a 'region' property\ng.V().hasNot('region')\n\n// The above is shorthand for\n g.V().not(has('region'))\n```",
            "children": []
          },
          {
            "level": "3.2.3",
            "title": "3.2.3. Counting things {#count}",
            "content": "A common need when working with graphs is to be able to count how \\\"many\nof something\\\" there are in the graph. We will look in the next section\nat other ways to count groups of things but first of all let's look at\nsome examples of using the *count* step to count how many of various\nthings there are in our *air-routes* graph. First of all lets find out\nhow many vertices in the graph represent airports.\n\n``` java\n// How many airports are there in the graph?\ng.V().hasLabel('airport').count()\n\n3374\n```\n\nNow, looking at edges that have a *route* label, let's find out how many\nflight routes are stored in the graph. Note that the *outE* step looks\nat outgoing edges. In this case we could also have used the *out* step\ninstead. The various ways that you can look at outgoing and incoming\nedges is discussed in the \\\"[Starting to walk the graph](#walk)\\\"\nsection that is coming up soon.\n\n``` java\n// How many routes are there?\ng.V().hasLabel('airport').outE('route').count()\n\n43400\n```\n\nYou could shorten the above a little as follows but this would cause\nmore edges to get looked at as we do not first filter out all vertices\nthat are not airports.\n\n``` java\n// How many routes are there?\ng.V().outE('route').count()\n\n43400\n```\n\nYou could also do it this way but generally starting by looking at all\nthe Edges in the graph is considered bad form as property graphs tend to\nhave a lot more edges than vertices.\n\n``` java\n// How many routes are there?\ng.E().hasLabel('route').count()\n\n43400\n```\n\nWe have not yet looked at the *outE* step used above. We will look at it\nvery soon however in the \\\"[Starting to walk the graph](#walk)\\\"\nsection.",
            "children": []
          },
          {
            "level": "3.2.4",
            "title": "3.2.4. Counting groups of things {#countgroup}",
            "content": "Sometimes it is useful to count how many of each type (or group) of\nthings there are in the graph. This can be done using the *group* and\n*groupCount* steps. While for a very large graph it is not recommended\nto run queries that look at all of the vertices or all of the edges in a\ngraph, for smaller graphs this can be quite useful. For the air routes\ngraph we could easily count the number of different vertex and edge\ntypes in the graph as follows.\n\n``` java\n// How many of each type of vertex are there?\ng.V().groupCount().by(label)\n```\n\nIf we were to run the query we would get back a map where the keys are\nlabel names and the values are the counts for the occurrence of each\nlabel in the graph.\n\n``` java\n[continent:7,country:237,version:1,airport:3374]\n```\n\nThere are other ways we could write the query above that will yield the\nsame result. One such example is shown below.\n\n``` java\n// How many of each type of vertex are there?\ng.V().label().groupCount()\n\n[continent:7,country:237,version:1,airport:3374]\n```\n\nWe can also run a similar query to find out the distribution of edge\nlabels in the graph. An example of the type of result we would get back\nis also shown.\n\n``` java\n// How many of each type of edge are there?\ng.E().groupCount().by(label)\n\n[contains:6748,route:43400]\n```\n\nAs before we could rewrite the query as follows.\n\n``` java\n// How many of each type of edge are there?\ng.E().label().groupCount()\n\n[contains:6748,route:43400]\n```\n\nBy way of a side note, the examples above are shorthand ways of writing\nsomething like this example which also counts vertices by label.\n\n``` java\n// As above but using group()\ng.V().group().by(label).by(count())\n\n[continent:7,country:237,version:1,airport:3374]\n```\n\nWe can be more selective in how we specify the groups of things that we\nwant to count. In the examples below we first count how many airports\nthere are in each country. This will return a map of key:value pairs\nwhere the key is the country code and the value is the number of\nairports in that country. As the fourth and fifth examples show, we can\nuse *select* to pick just a few values from the whole group that got\ncounted. Of course if we only wanted a single value we could just count\nthe airports connected to that country directly but the last two\nexamples are intended to show that you can count a group of things and\nstill selectively only look at part of that group.\n\n``` java\n// How many airports are there in each country?\ng.V().hasLabel('airport').groupCount().by('country')\n\n// How many airports are there in each country? (look at country first)\ng.V().hasLabel('country').group().by('code').by(out().count())\n```\n\nWe can easily find out how many airports there are in each continent\nusing *group* to build a map of continent codes and the number of\nairports in that continent. The output from running the query is shown\nbelow also.\n\n``` java\n// How many airports are there in each continent?\ng.V().hasLabel('continent').group().by('code').by(out().count())\n\n[EU:583,AS:932,NA:978,OC:284,AF:294,AN:0,SA:303]\n```\n\nThese queries show how *select* can be used to extract specific values\nfrom the map that we have created. Again you can see the results we get\nfrom running the query.\n\n``` java\n// How many airports are there in France (having first counted all countries)\ng.V().hasLabel('airport').groupCount().by('country').select('FR')\n\n58\n\n// How many airports are there in France, Greece and Belgium respectively?\ng.V().hasLabel('airport').groupCount().by('country').select('FR','GR','BE')\n\n[FR:58,GR:39,BE:5]\n```\n\nThe *group* and *groupCount* steps are very useful when you want to\ncount groups of things or collect things into a group using a selection\ncriteria. You will find a lot more examples of grouping and counting\nthings in the section called \\\"[Counting more things](#countmore)\\\".",
            "children": []
          }
        ]
      },
      {
        "level": "3.3",
        "title": "3.3. Starting to walk the graph {#walk}",
        "content": "So far we have mostly just explored queries that look at properties on a\nvertex or count how many things we can find of a certain type. Where the\npower of a graph really comes into play is when we start to *walk* or\n*traverse* the graph by looking at the connections (edges) between\nvertices. The term *walking the graph* is used to describe moving from\none vertex to another vertex via an edge. Typically when using the\nphrase *walking a graph* the intent is to describe starting at a vertex\ntraversing one or more vertices and edges and ending up at a different\nvertex or sometimes, back where you started in the case of a *circular\nwalk*. It is very easy to traverse a graph in this way using Gremlin.\nThe journey we took while on our *walk* is often referred to as our\n*path*. There are also cases when all you want to do is return edges or\nsome combination of vertices and edges as the result of a query and\nGremlin allows this as well. We will explore a lot of ways to modify the\nway a graph is traversed in the upcoming sections.\n\nThe table below gives a brief summary of all the steps that can be used\nto *walk* or *traverse* a graph using Gremlin. You will find all of\nthese steps used in various ways throughout the book. Think of a graph\ntraversal as moving through the graph from one place to one or more\nother places. These steps tell Gremlin which places to move to next as\nit traverses a graph for you.\n\nIn order to better understand these steps it is worth defining some\nterminology. One vertex is considered to be *adjacent* to another vertex\nif there is an edge connecting them. A vertex and an edge are considered\n*incident* if they are connected to each other.\n\n+-------------+--------------------------------------------------------+\n| out \\*      | Outgoing adjacent vertices.                            |\n+-------------+--------------------------------------------------------+\n| in \\*       | Incoming adjacent vertices.                            |\n+-------------+--------------------------------------------------------+\n| both \\*     | Both incoming and outgoing adjacent vertices.          |\n+-------------+--------------------------------------------------------+\n| outE \\*     | Outgoing incident edges.                               |\n+-------------+--------------------------------------------------------+\n| inE \\*      | Incoming incident edges.                               |\n+-------------+--------------------------------------------------------+\n| bothE \\*    | Both outgoing and incoming incident edges.             |\n+-------------+--------------------------------------------------------+\n| outV        | Outgoing vertex.                                       |\n+-------------+--------------------------------------------------------+\n| inV         | Incoming vertex.                                       |\n+-------------+--------------------------------------------------------+\n| otherV      | The vertex that was not the vertex we came from.       |\n+-------------+--------------------------------------------------------+\n\n: Where to move next while traversing a graph\n\nNote that the steps labelled with an *\\** can optionally take the name\nof one or more edge labels as a parameter. If omitted, all relevant\nedges will be traversed.",
        "children": [
          {
            "level": "3.3.1",
            "title": "3.3.1. Some simple graph traversal examples {#_some_simple_graph_traversal_examples}",
            "content": "To get us started, in this section we will look at some simple graph\ntraversal examples that use some of the steps that were just introduced.\nThe *out* step is used to find vertices connected by an outgoing edge to\nthat vertex and the *outE* *step* is used when you want to examine the\noutgoing edges from a given vertex. Conversely the *in* and *inE* steps\ncan be used to look for incoming vertices and edges. The *outE* and\n*inE* steps are especially useful when you want to look at the\nproperties of an edge as we shall see in the \\\"[Examining the edge\nbetween two vertices](#exedge)\\\" section. There are several other steps\nthat we can use when traversing a graph to move between vertices and\nedges. These include *bothE*, *bothV* and *otherV*. We will encounter\nthose in the \\\"[Other ways to explore vertices and edges using , , and\n](#otherv)\\\" section.\n\nSo let's use a few examples to help better understand these graph\ntraversal steps. The first query below does a few interesting things.\nFirstly we find the vertex representing the Austin airport (the airport\nwith a property of *code* containing the value *AUS*). Having found that\nvertex we then go *out* from there. This will find all of the vertices\nconnected to Austin by an outgoing edge. Having found those airports we\nthen ask for the values of their *code* properties using the *values*\nstep. Finally the *fold* step puts all of the results into a list for\nus. This just makes it easier for us to inspect the results in the\nconsole.\n\n``` java\n// Where can I fly to from Austin?\ng.V().has('airport','code','AUS').out().values('code').fold()\n```\n\nHere is what you might get back if you were to run this query in your\nconsole.\n\n``` java\n[YYZ, LHR, FRA, MEX, PIT, PDX, CLT, CUN, MEM, CVG, IND, MCI, DAL, STL, ABQ, MDW, LBB, HRL, GDL, PNS, VPS, SFB, BKG, PIE, ATL, BNA, BOS, BWI, DCA, DFW, FLL, IAD, IAH, JFK, LAX, MCO, MIA, MSP, ORD, PHX, RDU, SEA, SFO, SJC, TPA, SAN, LGB, SNA, SLC, LAS, DEN, MSY, EWR, HOU, ELP, CLE, OAK, PHL, DTW]\n```\n\nAll edges in a graph have a label. However, one thing we did not do in\nthe previous query was specify a label for the *out* step. If you do not\nspecify a label you will get back any connected vertex regardless of its\nedge label. In this case it does not cause us a problem as airports only\nhave one type of outgoing edge, labeled *route*. However, in many cases,\nin graphs you create or are working with, your vertices may be connected\nto other vertices by edges with differing labels so it is good practice\nto get into the habit of specifying edge labels as part of your Gremlin\nqueries. So we could change our query just a bit by adding a label\nreference on the *out* step as follows.\n\n``` java\n// Where can I fly to from Austin?\ng.V().has('airport','code','AUS').out('route').values('code').fold()\n```\n\nDespite having just stated that consistently using edge labels in\nqueries is a good idea, unless you truly do want to get back all edges\nor all connected vertices, I will break my own rule quite a bit in this\nbook. The reason for this is purely to save space and make the queries I\npresent shorter.\n\nHere are a few more simple queries similar to the previous one. The\nfirst example can be used to answer the question \\\"Where can I fly to\nfrom Austin, with one stop on the way?\\\". Note that, as written, coming\nback to Austin will be included in the results as this query does not\nrule it out!\n\n``` java\n// Where can I fly to from Austin, with one stop on the way?\ng.V().has('airport','code','AUS').out('route').out('route').values('code')\n```\n\nThis query uses an *in* step to find all the routes that come into the\nLondon City Airport (LCY) and returns their IATA codes.\n\n``` java\n// What routes come in to LCY?\ng.V().has('airport','code','LCY').in('route').values('code')\n```\n\nThis query is perhaps a bit more interesting. It finds all the routes\nfrom London Heathrow airport in England that go to an airport in the\nUnited States and returns their IATA codes.\n\n``` java\n// Flights from London Heathrow (LHR) to airports in the USA\ng.V().has('code','LHR').out('route').has('country','US').values('code')\n```",
            "children": []
          },
          {
            "level": "3.3.2",
            "title": "3.3.2. What vertices and edges did I visit? - Introducing *path* {#pathintro}",
            "content": "A Gremlin method (often called a step) that you will see used a lot in\nthis book is *path*. After you have done some graph walking using a\nquery you can use *path* to get a summary back of where you went. A\nsimple example of a *path* step being used is shown below. Throughout\nthe book you will see numerous examples of *path* being used including\nin conjunction with one or more *by* steps to specify how the path\nresult should be formatted.\n\nThis particular query will return the vertices and outgoing edges\nstarting at the London City (LCY) airport vertex. You can read this\nquery like this: \\\"Start at the LCY vertex, find all outgoing edges and\nalso find all of the vertices that are on the other ends of those\nedges\\\". The *inV* step gives us the vertex at the other end of the\noutgoing edge.\n\n``` java\n// This time, for each route, return both vertices and the edge that connects them.\ng.V().has('airport','code','LCY').outE().inV().path()\n```\n\nIf you run that query as-is you will get back a series of results that\nlook like this. This shows that there is a route from vertex 88 to\nvertex 77 via an edge with an ID of 13698.\n\n``` java\n[v[88],e[13698][88-route->77],v[77]]\n```\n\nWhile this result is useful, we might want to return something more\nhuman readable such as the IATA codes for each airport and perhaps the\ndistance property from the edge that tells us how far apart the airports\nare. We could add some *by* modulators to our query to do this. The\nApache TinkerPop documentation uses the phrase *modulator* to describe\nsteps that are not really independent steps but instead alter the\nbehavior of the steps that they are associated with.\n\n::: tip\nA *modulator* is a step that influences the behavior of the step that it\nis associated with. Examples of such modulator steps are *by* and *as*.\n:::\n\nTake a look at the modified form of the query shown below and an example\nof the results that it will now return. If this is not fully clear yet\ndon't panic. Both *path* and *by* are used a lot throughout this book.\n\n``` java\ng.V().has('airport','code','LCY').outE().inV().\n      path().by('code').by('dist')\n```\n\nWhen you run this modified version of the query, you will receive a set\nof results that look like the following line.\n\n``` java\n[LCY,456,GVA]\n```\n\nThe *by* modulator steps are processed in a round robin fashion. If\nthere are not enough modulators specified for the total number of\nelements in the path, Gremlin just loops back around to the first *by*\nstep and so on. So even though there were three elements in the path\nthat we wanted to have formatted, we only needed to specify two *by*\nmodulators. This is because the first and third elements in the path are\nof the same type, namely airport vertices, and we wanted to use the same\nproperty name, *code*, in each of those cases. If we instead wanted to\nreference a different property name for each element of the path result,\nwe would need to specify three explicit *by* modulator steps. This would\nbe required if, for example, we wanted to reference the *city* property\nof the third element in the path rather than its *code*.\n\n::: tip\nThe *by* modulator steps are processed in a round robin fashion in cases\nwhere there are more results to apply them to than *by* modulators\nspecified.\n:::\n\nThe example above is equivalent to this longer form of the same query.\n\n``` java\ng.V().has('airport','code','LCY').outE().inV().\n      path().by('code').by('dist').by('code')\n```\n\nThe example below shows a case where three different *by* modulators are\nused. This time the third *by* modulator step references the *city*\nproperty rather than the airport *code*. As you can see from the sample\noutput, this time the city name *Geneva* appears rather than the airport\ncode *GVA*.\n\n``` java\ng.V().has('airport','code','LCY').outE().inV().\n      path().by('code').by('dist').by('city')\n\n\n[LCY,456,Geneva]\n```\n\nSometimes it is necessary to use a *by* modulator that has no parameter\nas shown below. This is because the element in the path is not a vertex\nor edge containing multiple properties but rather a single value, in\nthis case, an integer.\n\n``` java\ng.V().has('airport','code','LCY').out().limit(5).\n      values('runways').\n      path().by('code').by('code').by()\n```\n\nThe results show the codes for the airports we visited along with a\nnumber representing the number of runways the second airport has.\n\n``` java\n[LCY,AGP,2]\n[LCY,ABZ,4]\n[LCY,JER,1]\n[LCY,BSL,2]\n[LCY,BHD,1]\n```\n\nIt is also possible to use a traversal inside of a *by* modulator. Such\ntraversals are known as *\\\"anonymous traversals\\\"* as they do not\ninclude a beginning *V* or *E* step.\n\n::: note\nTraversals that do not start with a *V* or *E* step are referred to as\n*\\\"anonymous traversals\\\"*.\n:::\n\nThis capability allows us to do things like combine multiple values\ntogether as part of a path result. The example below finds five routes\nthat start in Austin and creates a path result containing the airport\ncode and city name for both the source and destination airports. In this\ncase, the anonymous traversal contained within the *by* modulator is\napplied to each element in the path.\n\n``` java\ng.V(3).out().limit(5).path().by(values('code','city').fold())\n\n[[AUS,Austin],[YYZ,Toronto]]\n[[AUS,Austin],[LHR,London]]\n[[AUS,Austin],[FRA,Frankfurt]]\n[[AUS,Austin],[MEX,Mexico City]]\n[[AUS,Austin],[PIT,Pittsburgh]]\n```\n\nTo demonstrate that just about any arbitrary traversal can be placed\ninside the *by* modulator here is one more example that counts the\nnumber of outgoing routes for the source and destination airports as\npart of generating the *path* result.\n\n``` java\ng.V(3).out().limit(5).path().by(out().count())\n\n[59,181]\n[59,191]\n[59,272]\n[59,105]\n[59,54]\n```",
            "children": []
          },
          {
            "level": "3.3.3",
            "title": "3.3.3. Modifying a *path* using *from* and *to* modulators {#pathfromto}",
            "content": "In Apache TinkerPop version 3.2.5 the ability to limit what is returned\nby the *path* step using *from* and *to* modulators was added. This\nenables us to not return the entire path of a traversal but instead to\nbe more selective.\n\nFirst of all, look at the example below. In this case I have just used\nthe same *path* constructs used in the prior examples. The query returns\nthe first 10 routes found starting at Austin (AUS) with one stop on the\nway.\n\n``` java\ng.V().has('airport','code','AUS').out().out().path().by('code').limit(10)\n```\n\nAs expected the results show each airport that was visited.\n\n``` java\n[AUS,EWR,YYZ]\n[AUS,EWR,YVR]\n[AUS,EWR,LHR]\n[AUS,EWR,CDG]\n[AUS,EWR,FRA]\n[AUS,EWR,NRT]\n[AUS,EWR,DEL]\n[AUS,EWR,DUB]\n[AUS,EWR,HKG]\n[AUS,EWR,PEK]\n```\n\nGiven that every journey starts in Austin, we might not actually want\nthe AUS airport code to be part of the returned results. We might just\nwant to capture the places that we ended up visiting after leaving\nAustin. This can be achieved by labelling the parts of the traversal\nthat we care about using *as* steps and then using *from* and *to*\nmodulators to tell the *path* step what we are interested in. Take a\nlook at the modified version of the query below.\n\n``` java\ng.V().has('airport','code','AUS').out().as('a').out().as('b').\n      path().by('code').from('a').to('b').limit(10)\n```\n\nThis time AUS is not included in the *path* results.\n\n``` java\n[EWR,YYZ]\n[EWR,YVR]\n[EWR,LHR]\n[EWR,CDG]\n[EWR,FRA]\n[EWR,NRT]\n[EWR,DEL]\n[EWR,DUB]\n[EWR,HKG]\n[EWR,PEK]\n```\n\nBecause after skipping the AUS part of the path we did in fact want the\nrest of the results we could have left off the *to* modulator and\nwritten the query as follows.\n\n``` java\ng.V().has('airport','code','AUS').out().as('a').out().\n      path().by('code').from('a').limit(10)\n```\n\nAs you can see the results are the same as before.\n\n``` java\n[EWR,YYZ]\n[EWR,YVR]\n[EWR,LHR]\n[EWR,CDG]\n[EWR,FRA]\n[EWR,NRT]\n[EWR,DEL]\n[EWR,DUB]\n[EWR,HKG]\n[EWR,PEK]\n```\n\nObviously there are a lot of ways that *from* and *to* can be used. By\nway of one final example, let's create a version of the query with three\n*out* steps. Note that a bit later we will see how *repeat* can be used\nwhen the same steps need to be used repeatedly like this but that is not\nimportant to this specific example.\n\n``` java\ng.V().has('airport','code','AUS').out().out().out().\n      path().by('code').limit(10)\n```\n\nAs expected we now have an additional stop added to each of the\njourneys.\n\n``` java\n[AUS,EWR,YYZ,ATL]\n[AUS,EWR,YYZ,AUS]\n[AUS,EWR,YYZ,BNA]\n[AUS,EWR,YYZ,BOS]\n[AUS,EWR,YYZ,BWI]\n[AUS,EWR,YYZ,DCA]\n[AUS,EWR,YYZ,DFW]\n[AUS,EWR,YYZ,FLL]\n[AUS,EWR,YYZ,IAD]\n[AUS,EWR,YYZ,IAH]\n```\n\nLet's now modify the query to limit which parts of the path are\nreturned.\n\n``` java\ng.V().has('airport','code','AUS').out().as('a').out().as('b').out().\n      path().by('code').from('a').to('b').limit(10)\n```\n\nAs you can see, only the parts of the journey that we selected have been\nreturned.\n\n``` java\n[EWR,YYZ]\n[EWR,YYZ]\n[EWR,YYZ]\n[EWR,YYZ]\n[EWR,YYZ]\n[EWR,YYZ]\n[EWR,YYZ]\n[EWR,YYZ]\n[EWR,YYZ]\n[EWR,YYZ]\n```\n\nWe could also have written the query as shown below to only show the\nresults of each path up to a certain point.\n\n``` java\ng.V().has('airport','code','AUS').out().out().as('b').out().\n      path().by('code').to('b').limit(10)\n```\n\nThis time only the first three airports visited are included in each\nresult.\n\n``` java\n[AUS,EWR,YYZ]\n[AUS,EWR,YYZ]\n[AUS,EWR,YYZ]\n[AUS,EWR,YYZ]\n[AUS,EWR,YYZ]\n[AUS,EWR,YYZ]\n[AUS,EWR,YYZ]\n[AUS,EWR,YYZ]\n[AUS,EWR,YYZ]\n[AUS,EWR,YYZ]\n```\n\nBy way of a side note, in cases like this where more than one of the\nresults is identical, you may want to remove the duplicates. That is\nwhere the *dedup* step is useful. You will find coverage of *dedup* in\nthe \\\"[Removing duplicates - introducing ](#dedup)\\\" section. However,\nas a little taste test, let's add a *dedup* step to the end of our\nprevious query and see what happens.\n\n``` java\ng.V().has('airport','code','AUS').out().out().as('b').out().\n      path().by('code').to('b').limit(10).dedup()\n\n[AUS,EWR,YYZ]\n```\n\nAs you can see all of the duplicate results have now been removed.\nHopefully this gives you a good basic understanding of the *path* step.\nYou will see it used a lot throughout the remainder of this book.\nHowever, there are a few things to be aware of when using *path*. Those\nconcerns are explained in the [A warning that path finding can be memory\nand CPU intensive](#pathwarn) section a bit later.",
            "children": []
          },
          {
            "level": "3.3.4",
            "title": "3.3.4. Does an edge exist between two vertices? {#edgeexist}",
            "content": "You can use the *hasNext* step to check if an edge exists between two\nvertices and get a Boolean (true or false) value back. The first query\nbelow will return **true** because there is an edge (a route) between\nAUS and DFW. The second query will return **false** because there is no\nroute between AUS and SYD.\n\n``` java\ng.V().has('code','AUS').out('route').has('code','DFW').hasNext()\n\ntrue\n\ng.V().has('code','AUS').out('route').has('code','SYD').hasNext()\n\nfalse\n```",
            "children": []
          },
          {
            "level": "3.3.5",
            "title": "3.3.5. Using *as*, *select* and *project* to refer to traversal steps {#aselproj}",
            "content": "Sometimes it is useful to be able to remember a point of a traversal by\ngiving it a name (label) and refer to it later on in the same query.\nThis ability was more essential in TinkerPop 2 than it is in TinkerPop 3\nbut it still has many uses. The query below uses an *as* step to attach\na label at two different parts of the traversal, each representing\ndifferent vertices that were found. A *select* step is later used to\nrefer back to them.\n\n``` java\ng.V().has('code','DFW').as('from').out().\n      has('region','US-CA').as('to').\n      select('from','to')\n```\n\nThis query, while a bit contrived, and in this case probably a poor\nsubstitute for using *path*, returns the following results.\n\n``` java\n[from:v[8],to:v[13]]\n[from:v[8],to:v[23]]\n[from:v[8],to:v[24]]\n[from:v[8],to:v[26]]\n[from:v[8],to:v[28]]\n[from:v[8],to:v[42]]\n[from:v[8],to:v[151]]\n[from:v[8],to:v[181]]\n[from:v[8],to:v[244]]\n[from:v[8],to:v[384]]\n[from:v[8],to:v[877]]\n```\n\nIn the example above only the vertices themselves were selected. We can\nalso use a *by* modulator to specify which property to retrieve from the\nselected vertices.\n\n``` java\ng.V().has('code','DFW').as('from').out().\n      has('region','US-CA').as('to').\n      select('from','to').by('code')\n```\n\nThis time the results contain the airport codes.\n\n``` java\n[from:DFW,to:LAX]\n[from:DFW,to:SFO]\n[from:DFW,to:SJC]\n[from:DFW,to:SAN]\n[from:DFW,to:SNA]\n[from:DFW,to:OAK]\n[from:DFW,to:ONT]\n[from:DFW,to:PSP]\n[from:DFW,to:SMF]\n[from:DFW,to:FAT]\n[from:DFW,to:SBA]\n```\n\nWhile the prior example was perhaps not ideal, it does show how *as* and\n*select* work. For completeness, here is the same query but using\n*path*. You will see both the *select* and *path* steps used a lot\nthroughout this book.\n\n``` java\ng.V().has('code','DFW').out().\n      has('region','US-CA').\n      path().by('code')\n```\n\nWhich would produce the following results. Notice that this time the\nresults do not have labels associated with them but are otherwise the\nsame.\n\n``` java\n[DFW,LAX]\n[DFW,ONT]\n[DFW,PSP]\n[DFW,SFO]\n[DFW,SJC]\n[DFW,SAN]\n[DFW,SNA]\n[DFW,OAK]\n[DFW,SMF]\n[DFW,FAT]\n[DFW,SBA]\n```\n\nWhile the *path* step is a lot more convenient, in some cases it can be\nvery expensive in terms of memory and CPU usage so it is worth\nremembering these alternative techniques using *as* and *select*. That\ntopic is discussed in more detail in the \\\"[A warning that path finding\ncan be memory and CPU intensive](#pathwarn) section.\n\nYou can also give a point of a traversal multiple names and refer to\neach later on in the traversal/query as shown below.\n\n``` java\ng.V().has('type','airport').limit(10).as('a','b','c').\n      select('a','b','c').\n        by('code').by('region').by(out().count())\n```\n\nIn the most recent releases of TinkerPop you can also use the new\n*project* step and achieve the same results that you can get from the\ncombination of *as* and *select* steps. The example below shows the\nprevious query, rewritten to use *project* instead of *as* and *select*.\n\n``` java\ng.V().has('type','airport').limit(10).\n      project('a','b','c').\n        by('code').by('region').by(out().count())\n```\n\nThis query, and the prior query, would return the following results.\n\n``` java\n[a:ATL,b:US-GA,c:232]\n[a:ANC,b:US-AK,c:39]\n[a:AUS,b:US-TX,c:59]\n[a:BNA,b:US-TN,c:55]\n[a:BOS,b:US-MA,c:129]\n[a:BWI,b:US-MD,c:89]\n[a:DCA,b:US-DC,c:93]\n[a:DFW,b:US-TX,c:221]\n[a:FLL,b:US-FL,c:141]\n[a:IAD,b:US-VA,c:136]\n```\n\nIn the prior example we gave our variables simple names like *a* and\n*b*. However, it is sometimes useful to give our traversal variables and\nnamed steps more meaningful names and it is perfectly OK to do that.\nLet's rewrite the query to use some more descriptive variable names.\n\n``` java\n g.V().has('type','airport').limit(10).\n       project('IATA','Region','Routes').\n         by('code').by('region').by(out().count())\n```\n\nWhen we run the modified query, here is the output we get.\n\n``` java\n[IATA:ATL,Region:US-GA,Routes:232]\n[IATA:ANC,Region:US-AK,Routes:39]\n[IATA:AUS,Region:US-TX,Routes:59]\n[IATA:BNA,Region:US-TN,Routes:55]\n[IATA:BOS,Region:US-MA,Routes:129]\n[IATA:BWI,Region:US-MD,Routes:89]\n[IATA:DCA,Region:US-DC,Routes:93]\n[IATA:DFW,Region:US-TX,Routes:221]\n[IATA:FLL,Region:US-FL,Routes:141]\n[IATA:IAD,Region:US-VA,Routes:136]\n```",
            "children": []
          },
          {
            "level": "3.3.6",
            "title": "3.3.6. Using multiple *as* steps with the same label {#multias}",
            "content": "It is actually possible using an *as* step to give more than one part of\na traversal the same label (name). In the example below, the label\n*\\'a\\'* is used twice but you will notice that when the label is\nselected only the last item added is returned.\n\n``` java\ng.V(1).as('a').V(2).as('a').select('a')\n\nv[2]\n```\n\nThere are some special keywords that can be used in conjunction with the\n*select* step in cases like this one. These keywords are *first*, *last*\nand *all* and their usage is shown below.\n\n``` java\ng.V(1).as('a').V(2).as('a').select(first,'a')\n\nv[1]\n\ng.V(1).as('a').V(2).as('a').select(last,'a')\n\nv[2]\n\ng.V(1).as('a').V(2).as('a').select(all,'a')\n\n[v[1],v[2]]\n```\n\nHere is another example of a query that labels two different parts of a\ntraversal with the same *\\'a\\'* label. As you can see from the results,\nonly the second one is used because of the *last* keyword that is\nprovided on the *select* step.\n\n``` java\ng.V().has('code','AUS').as('a').\n      out().as('a').limit(10).\n      select(last,'a').by('code').fold()\n\n[YYZ,LHR,FRA,MEX,PIT,PDX,CLT,CUN,MEM,CVG]\n```\n\nHere is the same query but using the *first* keyword this time as part\nof the *select* step.\n\n``` java\ng.V().has('code','AUS').as('a').\n      out().as('a').limit(10).\n      select(first,'a').by('code').fold()\n\n[AUS,AUS,AUS,AUS,AUS,AUS,AUS,AUS,AUS,AUS]\n```\n\nNote that when the same name is used to label a step, the data structure\ncreated by Gremlin is essentially a List. As such, the *by* modulator\ncannot be used when the *all* keyword is used on the *select* step. To\nget the values of each element in the list we can use an *unfold* step\nas shown below.\n\n``` java\ng.V().has('code','AUS').as('a').\n      out().as('a').limit(10).\n      select(all,'a').unfold().values('code').fold()\n\n[AUS,AUS,AUS,AUS,AUS,AUS,AUS,AUS,AUS,AUS,\n YYZ,LHR,FRA,MEX,PIT,PDX,CLT,CUN,MEM,CVG]\n```\n\nKeywords such as *all*, *first* and *last* are discussed further in the\n\\\"[Important Classes and Enums to be aware of](#javastatics)\\\" section\nlater on in the book.",
            "children": []
          },
          {
            "level": "3.3.7",
            "title": "3.3.7. Returning selected parts of a path {#pathselect}",
            "content": "Sometimes, even using the *from* and *to* modulating steps along with a\n*path* step will not give you the results you are interested in. Using a\n*select* step and some *as* steps in a similar way to the example in the\nprevious section we can select specific parts of a traversal's \\\"path\\\".\nConsider the query below that finds a route from Los Angeles (LAX) and\nreturns the path.\n\n``` java\ng.V().has('code','LAX').\n      out().\n      out().\n      out().\n      out().\n      out().\n      limit(1).\n      path().by('code')\n\n[LAX,YYC,BNA,BWI,YYZ,ZRH]\n```\n\nNow, imagine we want to just return every other stop as the result from\nour query. The example below shows how to do just that.\n\n``` java\ng.V().has('code','LAX').\n      out().as('stop').\n      out().\n      out().as('stop').\n      out().\n      out().as('stop').\n      limit(1).\n      select(all,'stop').\n      unfold().\n      values('code').fold()\n\n[YYC,BWI,ZRH]\n```",
            "children": []
          },
          {
            "level": "3.3.8",
            "title": "3.3.8. Examining the edge between two vertices {#exedge}",
            "content": "Sometimes, it is the edge between two vertices that we are interested in\nexamining and not the vertices themselves. Typically this is because we\nwant to look at one or more properties associated with that edge. By way\nof an example, let's imagine we wanted to know how many miles the flight\nis between Miami (MIA) and Dallas Fort Worth (DFW). In our air routes\ngraph, the distances between vertices are stored using a property called\n*dist* on any edge that has a *route* label. We can use the *outE* and\n*inV* steps to find the edge connecting Miami and Dallas. We can also\nuse the *select* and *as* steps that we just learned about to help with\nthis task. Take a look at the query below. This will find the outgoing\n*route* edge from MIA to DFW, store it in the traversal variable *e* and\nat the end of the query use *select* to return it as the result of the\nquery.\n\n``` java\ng.V().has('code','MIA').outE().as('e').inV().has('code','DFW').select('e')\n```\n\nIf we were to run the query, we would get back something similar to this\n\n``` java\ne[4127][16-route->8]\n```\n\nSo we found the *route* edge that connects the vertex with an ID of 16\n(MIA) with the airport that has an ID of 8 (DFW). While interesting,\nthis is not exactly what we set out to achieve. What we actually are\ninterested in is the distance property of that edge so we can see how\nfar it is from Miami to Dallas Fort Worth. We need to add one additional\nstep to our query that will look at the *dist* property of the edge.\nLet's modify our query to do that.\n\n``` java\ng.V().has('code','MIA').outE().as('e').\n      inV().has('code','DFW').select('e').values('dist')\n```\n\nIf we run the query again we get back what we were looking for. We can\nsee that it is 1,120 miles from Miami to Dallas Fort Worth.\n\n``` java\n1120\n```\n\nAs a side note, we could have written the query using *inE* and *outV*\nand achieved the same result by looking at the edge from Dallas to\nMiami.\n\n``` java\ng.V().has('code','MIA').inE().as('e').\n      outV().has('code','DFW').select('e').values('dist')\n\n1120\n```\n\nThroughout the remainder of the book you will find lots of examples that\nuse steps such as *outE*, *inE*, *outV* and *inV*.",
            "children": []
          }
        ]
      },
      {
        "level": "3.4",
        "title": "3.4. Limiting the amount of data returned {#limit}",
        "content": "It is sometimes useful, especially when dealing with large graphs, to\nlimit the amount of data that is returned from a query. As shown in the\nexamples below, this can be done using the *limit* and *tail* steps. A\nlittle later in this book we also introduce the *coin* step that allows\na pseudo random sample of the data to be returned.\n\n``` java\n// Only return the FIRST 20 results\ng.V().hasLabel('airport').values('code').limit(20)\n\n// Only return the LAST 20 results\ng.V().hasLabel('airport').values('code').tail(20)\n```\n\nDepending upon the implementation, it is probably more efficient to\nwrite the query like this, with *limit* coming before *values* to\nguarantee fewer airports are initially returned but it is also possible\nthat an implementation would optimize both the same way.\n\n``` java\n// Only return the FIRST 20 results\ng.V().hasLabel('airport').limit(20).values('code')\n```\n\nNote that *limit* provides a shorthand alternative to *range*. The first\nof the two examples above could have been written as follows.\n\n``` java\n// Only return the FIRST 20 results\ng.V().hasLabel('airport').range(0,20).values('code')\n```\n\nWe can also limit a traversal by specifying a maximum amount of time\nthat it is allowed to run for. The following query is restricted to a\nmaximum limit of ten milliseconds. The query looks for routes from\nAustin (AUS) to London Heathrow (LHR). All the parts of this query are\nexplained in detail later on in this book but I think what they do is\nfairly clear. The *repeat* step is explained in detail in the\n\\\"[Shortest paths (between airports) - introducing ](#sp)\\\" section.\n\n``` java\n// Limit the query to however much can be processed within 10 milliseconds\ng.V().has('airport','code','AUS').\n      repeat(timeLimit(10).out()).until(has('code','LHR')).path().by('code')\n```\n\nHere is what the query above returned when run on my laptop.\n\n``` java\n[AUS,LHR]\n[AUS,YYZ,LHR]\n[AUS,FRA,LHR]\n[AUS,MEX,LHR]\n```\n\nIf we give the query another 10 milliseconds to run, so 20 in total, you\ncan see that a few more routes were found.\n\n``` java\n// Limit the query to 20 milliseconds\ng.V().has('airport','code','AUS').\n      repeat(timeLimit(20).out()).until(has('code','LHR')).path().by('code')\n\n[AUS,LHR]\n[AUS,YYZ,LHR]\n[AUS,FRA,LHR]\n[AUS,MEX,LHR]\n[AUS,PDX,LHR]\n[AUS,CLT,LHR]\n```",
        "children": [
          {
            "level": "3.4.1",
            "title": "3.4.1. Retrieving a range of vertices {#retrrange}",
            "content": "Gremlin provides various ways to return a sequence of vertices. We have\nalready seen the *limit* and *range* steps used in the previous section\nto return the first 20 elements of a query result. We can also use the\n*range* step to select different range of vertices by giving a non zero\nstarting offset and an ending offset. The *range* offsets are zero\nbased, and while the official documentation states that the ranges are\ninclusive/inclusive it actually appears from my testing that they are\ninclusive/exclusive.\n\n``` java\n// Return the first two airport vertices found\ng.V().hasLabel('airport').range(0,2)\n\nv[1]\nv[2]\n```\n\nThe starting value given to a *range* step does not have to be *0*. In\nthe example below we ask for the 3rd, 4th and 5th results found by\nspecifying a range of *\\\"(3,6)\\\"*.\n\n``` java\n// Return the fourth, fifth and sixth airport vertices found (zero based)\ng.V().hasLabel('airport').range(3,6)\n\nv[4]\nv[5]\nv[6]\n```\n\nHere is an example of how we can use the index *-1* to mean *\\\"until the\nend of the list\\\"*. This is similar to the convention used in many\nprogramming languages when working with arrays and list.\n\n``` java\n// Return all the remaining vertices starting at the 3500th one\ng.V().range(3500,-1)\n```\n\nHere is another example that uses the *range* step, this time looking\nonly at vertices with a label of *country*. Notice how this time we\nfound vertices with much higher ID values.\n\n``` java\ng.V().hasLabel('country').range(0,2)\n\nv[3376]\nv[3377]\n```\n\n::: note\nThere is no guarantee as to which airport vertices will be selected as\nthis depends upon how they are stored by the back end graph. Using\nTinkerGraph the airports will most likely come back in the order they\nare put into the graph. This is not likely to be the case with other\ngraph stores such as JanusGraph. So do not rely on any sort of\nexpectation of order when using *range* to process sets of vertices.\n:::\n\nIn TinkerPop 3.3 a new *skip* step was introduced which can be used as\nan alternative to *range* in some cases. The *skip* step can be used\nwhenever you would otherwise use *range* where the second parameter\nwould be *-1* meaning \\\"all remaining\\\".\n\nThe two examples below will produce the same results.\n\n``` java\ng.V().has('region','US-TX').skip(5).fold()\n\ng.V().has('region','US-TX').range(5,-1).fold()\n```\n\nHere is the output you might get from running either query.\n\n``` java\n[v[39],v[186],v[273],v[278],v[289],v[314],v[356],v[357],v[358],v[361],v[368],v[370],v[390],v[394],v[404],v[405],v[423],v[426],v[428],v[1118],v[3313]]\n```\n\nTo prove that the *skip* and *range* steps used above worked again, we\ncan run the query again with *skip* removed and look at the results. You\nwill notice, the first five vertices listed were not included as part of\nthe results from the prior queries.\n\n``` java\ng.V().has('region','US-TX').fold()\n\n[v[3],v[8],v[11],v[33],v[38],v[39],v[186],v[273],v[278],v[289],v[314],v[356],v[357],v[358],v[361],v[368],v[370],v[390],v[394],v[404],v[405],v[423],v[426],v[428],v[1118],v[3313]]\n```\n\nYou can also use the *local* keyword to have *skip* work on an incoming\ncollection within a traversal. The example below, while contrived,\napplies skip to the list generated by the *fold* step.\n\n``` java\ng.V().has('region','US-TX').fold().skip(local,3)\n\n[v[33],v[38],v[39],v[186],v[273],v[278],v[289],v[314],v[356],v[357],v[358],v[361],v[368],v[370],v[390],v[394],v[404],v[405],v[423],v[426],v[428],v[1118],v[3313]]\n```\n\nThere are many other ways to specify a range of values using Gremlin.\nYou will find several additional examples in the \\\"[Testing values and\nranges of values](#tranges)\\\" section.",
            "children": []
          },
          {
            "level": "3.4.2",
            "title": "3.4.2. Removing duplicates - introducing *dedup* {#dedup}",
            "content": "It is often desirable to remove duplicate values from query results. The\n*dedup* step allows us to do this. If you are already familiar with\nGroovy collections, the *dedup* step is similar to the *unique* method\nthat Groovy provides. In the example below, the number of runways for\nevery airport in England is queried. Note that in the returned results\nthere are many duplicate values.\n\n``` java\ng.V().has('region','GB-ENG').values('runways').fold()\n\n[2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,2,1,2,2,1,3,1,3,3,4,1,1]\n```\n\nIf we only wanted a set of unique values in the result we could rewrite\nthe query to include a *dedup* step. This time the query results only\ninclude one of each value.\n\n``` java\ng.V().has('region','GB-ENG').values('runways').dedup().fold()\n\n[2,1,3,4]\n```\n\nIt is also possible to use a *by* modulator to specify how *dedup*\nshould be applied. In the example below we only return one airport for\neach unique number of runways.\n\n``` java\ng.V().has('region','GB-ENG').dedup().by('runways').\n      values('code','runways').fold()\n\n[LHR,2,LCY,1,BLK,3,LEQ,4]\n```\n\nThere is one more form of the *dedup* step. In this form, one or more\nstrings representing labelled steps are provided as parameters. Take a\nlook first of all at the query below. It finds vertex *V(3)* and labels\nit *\\'a\\'*. It then finds vertex *V(4)* and labels it *\\'c\\'*. Next it\nfinds all the vertices connected to V(4) and labels those *\\'b\\'*. Only\nthe first 10 are retrieved. Lastly a *select* step is used to return the\nresults. As expected vertices 3 and 4 are present in all of the results.\n\n``` java\ng.V(3).as('a').V(4).as('c').both().as('b').limit(10).\n  select('a','b','c')\n\n[a:v[3],b:v[1],c:v[4]]\n[a:v[3],b:v[3],c:v[4]]\n[a:v[3],b:v[5],c:v[4]]\n[a:v[3],b:v[6],c:v[4]]\n[a:v[3],b:v[7],c:v[4]]\n[a:v[3],b:v[8],c:v[4]]\n[a:v[3],b:v[9],c:v[4]]\n[a:v[3],b:v[10],c:v[4]]\n[a:v[3],b:v[11],c:v[4]]\n[a:v[3],b:v[12],c:v[4]]\n```\n\nTaking the same query but adding a *dedup* step that references the\n*\\'a\\'* and *\\'c\\'* labels, removes all duplicate references that\ninclude those vertices from the results so this time even though a\n*limit* of 10 is used we only actually get one result back.\n\n``` java\ng.V(3).as('a').V(4).as('c').both().as('b').limit(10).\n  dedup('a','c').select('a','b','c')\n\n[a:v[3],b:v[1],c:v[4]]\n```\n\nA bit later we will take a look at the concept of *local* scope when\nworking with traversals. There are some examples of *local* scope being\nused in conjunction with *dedup* in the \\\"[Using scope with\ncollections](#localcollect)\\\" section.\n\nIt is also possible to use *sets* to achieve similar results as we shall\nsee in some of the following sections such as the \\\"[Introducing , , and\n](#setsandlists) section that is coming up soon.",
            "children": []
          }
        ]
      },
      {
        "level": "3.5",
        "title": "3.5. Using *valueMap* to explore the properties of a vertex or edge {#vm}",
        "content": "A call to *valueMap* will return all of the properties of a vertex or\nedge as an array of key:value pairs. Basically what in Java terms is\ncalled a HashMap. You can also select which properties you want\n*valueMap* to return if you do not want them all. Each element in the\nmap can be addressed using the name of the key. By default the ID and\nlabel are not included in the map unless a parameter of *true* is\nprovided.\n\nThe query below will return the keys and values for all properties\nassociated with the Austin airport vertex.\n\n``` java\n// Return all the properties and values the AUS vertex has\ng.V().has('code','AUS').valueMap().unfold()\n```\n\nIf you are using the Gremlin console, the output from running the\nprevious command should look something like this. The unfold step at the\nend of the query is used to make the results easier to read.\n\n``` java\ncountry=[US]\ncode=[AUS]\nlongest=[12250]\ncity=[Austin]\nelev=[542]\nicao=[KAUS]\nlon=[-97.6698989868164]\ntype=[airport]\nregion=[US-TX]\nrunways=[2]\nlat=[30.1944999694824]\ndesc=[Austin Bergstrom International Airport]\n```\n\n::: note\nNotice how each key, like *country*, is followed by a value that is\nreturned as an element of a list. This is because it is possible (for\nvertices but not for edges) to provide more than one property value for\na given key by encoding them as a list or as a set. In the Apache\nTinkerPop release 3.4 some changes were introduced to make it easier to\ncontrol how these results are returned. Those changes are discussed in\nthe next section.\n:::\n\nHere are some more examples of how *valueMap* can be used. If a\nparameter of *true* is provided, then the results returned will include\nthe ID and label of the element being examined.\n\n``` java\n// If you also want the ID and label, add a parameter of true\ng.V().has('code','AUS').valueMap(true).unfold()\n\nid=3\nlabel=airport\ncountry=[US]\ncode=[AUS]\nlongest=[12250]\ncity=[Austin]\nelev=[542]\nicao=[KAUS]\nlon=[-97.6698989868164]\ntype=[airport]\nregion=[US-TX]\nrunways=[2]\nlat=[30.1944999694824]\ndesc=[Austin Bergstrom International Airport]\n```\n\nYou can also mix use of *true* along with requesting the map for\nspecific properties. The next example will just return the ID, label and\n*region* property.\n\n``` java\n// If you want the ID, label and a specific field like the region, you can do this\ng.V().has('code','AUS').valueMap(true,'region')\n\n[id:3,region:[US-TX],label:airport]\n```\n\n::: tip\nIf you only need the keys and values for specific properties to be\nreturned it is recommended to pass the names of those properties as\nparameters to the *valueMap* step so it does not return a lot more data\nthan you need. Think of this as the difference, in the SQL world,\nbetween selecting just the columns you are interested in from a table\nrather than doing a *SELECT \\**.\n:::\n\nAs shown above, you can specify which properties you want returned by\nsupplying their names as parameters to the *valueMap* step. For\ncompleteness, it is worth noting that you can also use a *select* step\nto refine the results of a *valueMap*.\n\n``` java\n// You can 'select' specific fields from a value map\ng.V().has('code','AUS').valueMap().select('code','icao','desc')\n\n[code:[AUS],icao:[KAUS],desc:[Austin Bergstrom International Airport]]\n```\n\nIf you are reading the output of queries that use *valueMap* on the\nGremlin console, it is sometimes easier to read the output if you add an\n*unfold* step to the end of the query as follows. The *unfold* step will\nunbundle a collection for us. You will see it used in many parts of this\nbook.\n\n``` java\ng.V().has('code','AUS').valueMap(true,'code','icao','desc','city').unfold()\n\ncode=[AUS]\ncity=[Austin]\nicao=[KAUS]\nid=3\nlabel=airport\ndesc=[Austin Bergstrom International Airport]\n```\n\nYou can also use *valueMap* to inspect the properties associated with an\nedge. In this simple example, the edge with an ID of 5161 is examined.\nAs you can see the edge represents a route and has a distance (*dist*)\nproperty with a value of 1357 miles.\n\n``` java\ng.E(5161).valueMap(true)\n\n[id:5161,dist:1357,label:route]\n```",
        "children": [
          {
            "level": "3.5.1",
            "title": "3.5.1. Changes to *valueMap* introduced in TinkerPop 3.4 {#tp34vm}",
            "content": "Starting with the Apache TinkerPop 3.4 release, a few changes have been\nintroduced that allow easier control of the results that a *valueMap*\nstep returns. Further, the use of *true* to return the ID and label\nproperties of a Vertex or an Edge was deprecated and replaced by the use\nof a *with* modulator.\n\n::: note\nThe new valueMap configuration options are described in the official\ndocumentation at the following link\n<http://tinkerpop.apache.org/docs/current/reference/#valuemap-step>.\n:::\n\nThe previous ways of using *valueMap* will still work but over time as\nGraph DB providers adopt TinkerPop 3.4 the examples shown below will\nbecome the preferred way of controlling the results returned by\n*valueMap*.\n\nInstead of using *valueMap(true)* to include the ID and label of an\nelement (a vertex or an edge) in the results, the new\n*with(WithOptions.tokens)* construct can now be used as shown below.\n\n``` java\ng.V().has('code','SFO').valueMap().with(WithOptions.tokens).unfold()\n\nid=23\nlabel=airport\ncountry=[US]\ncode=[SFO]\nlongest=[11870]\ncity=[San Francisco]\nelev=[13]\nicao=[KSFO]\nlon=[-122.375]\ntype=[airport]\nregion=[US-CA]\nrunways=[4]\nlat=[37.6189994812012]\ndesc=[San Francisco International Airport]\n```\n\n::: tip\nAll of the possible values that can be specified using WithOptions can\nbe found in the official Apache TinkerPop JavaDoc documentation [at this\nlocation](http://tinkerpop.apache.org/javadocs/current/full/org/apache/tinkerpop/gremlin/process/traversal/step/util/WithOptions.html).\n:::\n\nYou can still include the ID and label in the results, along with a\nsubset of the properties, by explicitly naming the property keys you are\ninterested in. In the example below only the *code* property is\nrequested.\n\n``` java\ng.V().has('code','SFO').valueMap('code').with(WithOptions.tokens).unfold()\n\nid=23\nlabel=airport\ncode=[SFO]\n```\n\nYou can use additional *WithOptions* qualifiers to select just the\nlabels.\n\n``` java\ng.V().has('code','SFO').\n      valueMap('code').with(WithOptions.tokens,WithOptions.labels).\n      unfold()\n\nlabel=airport\ncode=[SFO]\n```\n\nIn the same way you can choose to just have the ID value returned\nwithout the label.\n\n``` java\ng.V().has('code','SFO').\n      valueMap('code').with(WithOptions.tokens,WithOptions.ids).\n      unfold()\n\nid=23\ncode=[SFO]\n```\n\nAs discussed in the previous section, the property values returned by\n*valueMap* are by default represented as lists even if there is only a\nsingle property value present.\n\n::: note\nUsing versions of TinkerPop prior to 3.4 it is still possible to\ngenerate the same unrolled results that you get using *by(unfold())*.\nHow to do that is discussed a bit later in the book we need to look at a\nfew other steps such as *map* first. If you want to jump ahead you will\nfind these examples in the \\\"[Unrolling the lists returned by\n](#vmunroll)\\\" section.\n:::\n\nStarting with TinkerPop 3.4 you can very easily request that these\nvalues be returned as single values not wrapped in lists. This can be\ndone using a *by* step modulator as shown below.\n\n``` java\ng.V().has('code','SFO').valueMap().by(unfold()).unfold()\n```\n\nNotice how all the values such as the city name, \\\"San Francisco\\\", are\nnow just simple strings or numeric values and not a single value wrapped\nin a list of length one.\n\n``` java\ncountry=US\ncode=SFO\nlongest=11870\ncity=San Francisco\nelev=13\nicao=KSFO\nlon=-122.375\ntype=airport\nregion=US-CA\nrunways=4\nlat=37.6189994812012\ndesc=San Francisco International Airport\n```\n\n::: note\nThere are additional *WithOptions* settings we can use to change how\nproperties with meta properties are returned by *valueMap* This is\ncovered later as part of the \\\"[Using and with Meta\nProperties](#tp34vmmetaprop)\\\" section.\n:::",
            "children": []
          }
        ]
      },
      {
        "level": "3.6",
        "title": "3.6. An alternative to *valueMap* - introducing *elementMap* {#element-map}",
        "content": "A new step, *elementMap*, was added to the Gremlin language as part of\nthe Apache TinkerPop 3.4.4 release in October 2019. This new step is\nsimilar in many ways to the *valueMap* step but makes some things a\nlittle easier.\n\n::: tip\nMake sure the graph database you are using has support for Apache\nTinkerPop at the 3.4.4 level or higher before using *elementMap* in your\nqueries.\n:::\n\nWhen using *valueMap* you need to explicitly request that the ID and\nlabel of a vertex or an edge are included in query results. This is not\nnecessary when using *elementMap*.\n\n``` java\ng.V().has('code','AUS').elementMap().unfold()\n\nid=3\nlabel=airport\ncountry=US\ncode=AUS\nlongest=12250\ncity=Austin\nelev=542\nicao=KAUS\nlon=-97.6698989868164\ntype=airport\nregion=US-TX\nrunways=2\nlat=30.1944999694824\ndesc=Austin Bergstrom International Airport\n```\n\nAs with *valueMap*, you can request only certain property values be\nincluded in the resulting map. Note however that the property values are\nnot returned as list members. This is a key difference from *valueMap*.\nIn fact, if the value for a given property is a list or set containing\nmultiple values, *elementMap* will only return the first member of that\nlist or set. If you need to return *set* or *list* cardinality values\nyou should use *valueMap* instead.\n\n``` java\ng.V().has('code','AUS').elementMap('city')\n\n[id:3,label:airport,city:Austin]\n```\n\nThe biggest difference between *elementMap* and *valueMap* becomes\napparent when looking at edges. For a given edge, as well as the ID and\nlabel and properties, information about the incoming and outgoing\nvertices is also returned.\n\n``` java\ng.V(3).outE().limit(1).elementMap()\n\n[id:5161,label:route,IN:[id:47,label:airport],OUT:[id:3,label:airport],dist:1357]\n```\n\nA similar result could be generated using *valueMap* as shown below but\nit is definitely a bit more work.\n\n``` java\ng.E(5161).project('v','IN','OUT').\n            by(valueMap(true)).\n            by(inV().union(id(),label()).fold()).\n            by(outV().union(id(),label()).fold())\n\n[v:[id:5161,label:route,dist:1357],IN:[47,airport],OUT:[3,airport]]\n```\n\nTo make the output look even closer to the results returned by\n*elementMap* we could decide to add some additional *project* steps.\n\n``` java\ng.E(5161).project('v','IN','OUT').\n            by(valueMap(true)).\n            by(project('id','label').\n              by(inV().id()).\n              by(inV().label())).\n            by(project('id','label').\n              by(outV().id()).\n              by(outV().label())).\n            unfold()\n```\n\nThe results of running the query are shown below. I added an unfold step\nto the query just to make the results a little easier to read.\n\n``` java\nv={id=5161, label=route, dist=1357}\nIN={id=47, label=airport}\nOUT={id=3, label=airport}\n```",
        "children": []
      },
      {
        "level": "3.7",
        "title": "3.7. Assigning query results to a variable {#var}",
        "content": "It is extremely useful to be able to assign the results of a query to a\nvariable. The example below stores the results of the *valueMap* call\nshown above into a variable called *aus*.\n\n``` java\n// Store the properties for the AUS airport in the variable aus.\naus=g.V().has('code','AUS').valueMap().next()\n```\n\n::: tip\nIt is necessary to add a call to *next* to the end of the query in order\nfor this to work. Forgetting to add the call to *next* is a very\ncommonly made mistake by people getting used to the Gremlin query\nlanguage. The call to *next* terminates the traversal part of the query\nand generates a concrete result that can be stored in a variable. There\nare other steps such as *toList* and *toSet* that also perform this\ntraversal termination action. We will see those steps used later on.\n:::\n\nOnce you have some results in a variable you can refer to it as you\nwould in any other programming language. We will explore mixing Java and\nGroovy code with your Gremlin queries later in this book. For now let's\njust use the Groovy *println* to display the results of the query that\nwe stored in *aus*. We will take a deeper look at the use of variables\nwith Gremlin later in the book when we look at mixing Gremlin and Groovy\nin the \\\"[Making Gremlin even Groovier](#grv)\\\" section.\n\n``` java\n// We can now refer to aus using key:value syntax\nprintln \"The AUS airport is located in \" + aus['city'][0]\n\nThe AUS airport is located in Austin\n```\n\n::: note\nProperties are stored as arrays of values. Even if there is only one\nproperty value for the given key, we still have to add the *\\[0\\]* when\nreferencing it otherwise the whole array will be returned if we just\nused *aus\\[\\'city\\'\\]*. We will explore why property values are stored\nin this way in the \\\"[Attaching multiple values (lists or sets) to a\nsingle property](#listprop)\\\" section.\n:::\n\nAs a side note, the *next* step can take a parameter value that tells it\nhow much data to return. For example if you wanted the next three\nvertices from a query like the one below you can add a call to *next(3)*\nat the end of the query. Note that doing this turns the result into an\nArrayList. Each element in the list will contain a vertex.\n\n``` java\nverts=g.V().hasLabel('airport').next(3)\n\nv[1]\nv[2]\nv[3]\n```\n\nWe can call the Java *getClass* method to verify the type of the values\nreturned.\n\n``` java\nverts.getClass()\n\nclass java.util.ArrayList\n\nverts.get(1).getClass()\n\nclass org.apache.tinkerpop.gremlin.tinkergraph.structure.TinkerVertex\n```\n\n::: tip\nWhen using the Gremlin Console, you can check to see what variables you\nhave defined using the command *:show variables*.\n:::",
        "children": [
          {
            "level": "3.7.1",
            "title": "3.7.1. Introducing *toList*, *toSet*, *bulkSet* and *fill* {#setsandlists}",
            "content": "It is often useful to return the results of a query as a list or as a\nset. One way to do this is to use *toList* or *toSet* methods. Below you\nwill find an example of each. The call to *join* is used just to make\nthe results easier to read on a single line.\n\n``` java\n// Create a list of runway counts in Texas\nlistr = g.V().has('airport','region','US-TX').\n              values('runways').toList().join(',')\n\n2,7,5,3,4,3,3,3,3,4,2,3,2,3,2,2,3,2,1,3,2,3,4,3,4,2\n```\n\nNow let's create a set and observe the different result we get back.\n\n``` java\n// Create a set of runway counts in Texas (no duplicates)\nsetr = g.V().has('airport','region','US-TX').\n             values('runways').toSet().join(',')\n\n1,2,3,4,5,7\n```\n\nAs a side note, in many cases we can use the *dedup* step to remove\nduplicates from a result. However, it is worth knowing that a set can be\ncreated as a result type as in some cases this can be very useful. The\nexample below performs the same *runways* query using a *dedup* step. I\nadded an *order* step so that it is easier to compare the results with\nthe previous query.\n\n``` java\n// Create a list of runway counts in Texas (no duplicates)\ng.V().has('airport','region','US-TX').\n      values('runways').dedup().order().fold()\n\n[1,2,3,4,5,7]\n```\n\nFinally, let's create the list again, but without the call to *join*, as\nthat creates a single string result which is not what we want in this\ncase.\n\n``` java\nlistr = g.V().has('airport','region','US-TX').\n        values('runways').toList()\n```\n\nThe variable can now be used as you would expect.\n\n``` java\nlistr[1]\n7\n\nlistr.size()\n26\n\nlistr[1,3]\n7\n3\n```\n\nTinkerPop also provides a third method called *bulkSet* that can be used\nto create a collection at the end of a traversal. The difference between\na *bulkSet* and a *set* is that *bulkSet* is a so called *weighted set*.\nA *bulkSet* stores every value but includes a count of how many of each\ntype is present. Let's look at a few examples. First of all we can check\nthat the *bulkSet* does indeed contain all the values.\n\n``` java\nsetb= g.V().has('airport','region','US-TX').values('runways').toBulkSet().join(',')\n2,2,2,2,2,2,2,2,7,5,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,1\n```\n\nA *bulkSet* offers some additional methods that we can call. One of\nthese is *uniqueSize* which will tell us how many unique values are\npresent.\n\n``` java\nsetb= g.V().has('airport','region','US-TX').values('runways').toBulkSet()\n\n// How many unique values are in the set?\nsetb.uniqueSize()\n6\n\n// How many total values are present?\nsetb.size()\n26\n```\n\nThe *asBulk* method returns a map of key/value pairs where the key is\nthe number and the value is the number of times that number appears in\nthe set.\n\n``` java\nsetb.asBulk()\n\n2=8\n7=1\n5=1\n3=11\n4=4\n1=1\n```\n\nThere is another way to store the results of a query into a collection.\nThis is achieved using the *fill* method. Unlike *toList* and the other\nmethods that we just looked at, *fill* will store the results into a\npre-existing variable. The query below defines a list called *a* and\nstores the results of the query into it. This will produce the same\nresult as using *toList*.\n\n``` java\na = []\ng.V().has('airport','region','US-TX').values('runways').fill(a)\n\na.size()\n26\n\na[1,3]\n7\n3\n```\n\nWe can define a variable that is a set and use *fill* to achieve the\nsame result as using *toSet*.\n\n``` java\ns = [] as Set\ng.V().has('airport','region','US-TX').values('runways').fill(s)\n\nprintln s\n\n[2, 7, 5, 3, 4, 1]\n```",
            "children": []
          }
        ]
      },
      {
        "level": "3.8",
        "title": "3.8. Working with IDs {#wid}",
        "content": "Every vertex, every edge and even every property in a graph has a unique\nID that can be used to reference it individually or as part of a group.\nBeware that the IDs you provide when loading a graph from a GraphML or\nGraphSON file may not in many cases end up being the IDs that the\nback-end graph store actually uses as it builds up your graph.\nTinkergraph for example will preserve user provided IDs but many graph\ndatabases such as JanusGraph generate their own IDs. The same is true\nwhen you add vertices and edges using a graph traversal or using the\nTinkerPop API. This is a long winded way of saying that you should not\ndepend on the IDs in your GraphML or GraphSON file that you just loaded\nremaining unchanged once the data has been loaded into the graph store.\nWhen you add a new vertex or edge to your graph using a traversal, the\ngraph system will automatically generate a new, unique ID for it. If you\nneed to figure out the ID for a vertex or an edge you can always get it\nfrom a query of the graph itself.\n\n::: tip\nDon't rely on the graph preserving the ID values you provide. Write code\nthat can query the graph itself for ID values. How IDs are managed will\nbe graph database implementation dependent.\n:::\n\nEspecially when dealing with large graphs, because using IDs is\ntypically very efficient, you will find that many of your queries will\ninvolve collecting one or more IDs and then passing those on to other\nqueries or parts of the same query. In most if not all cases, the\nunderlying graph system will have setup its data structures, whether on\ndisk or in memory, to be very rapidly accessed by ID value.\n\nLet's demonstrate the use of ID values using a few simple examples. The\nquery below finds the ID, which is 8, for the vertex that represents the\nDFW airport.\n\n``` java\n // What is the ID of the \"DFW\" vertex?\n g.V().has('code','DFW').id()\n\n 8\n```\n\nLet's reverse the query and find the code for the vertex with an ID of\n8.\n\n``` java\n// Simple lookup by ID\ng.V().hasId(8).values('code')\n\nDFW\n```\n\nWe could also have written the above query as follows.\n\n``` java\n// which is the same as this\ng.V().has(id,8).values('code')\n```\n\nHere are some more examples that make use of the ID value.\n\n``` java\n// vertices with an ID between 1 and 5 (note this is inclusive/exclusive)\ng.V().hasId(between(1,6))\n\n// Which is an alternate form of this\ng.V().has(id,between(1,6))\n\n// Find routes from the vertex with an ID of 6 to any vertex with an ID less than 46\ng.V().hasId(6).out().has(id,lt(46)).path().by('code')\n\n// Which is the same as\ng.V().hasId(6).out().hasId(lt(46)).path().by('code')\n```\n\nYou can also pass a single ID or multiple IDs directly into the *V()*\nstep. Take a look at the two examples below.\n\n``` java\n// What is the code property for the vertex with an ID of 3?\ng.V(3).values('code')\n\nAUS\n\n// As above but for all of the specified vertex IDs\ng.V(3,6,8,15).values('code')\n\nAUS\nBWI\nDFW\nMCO\n```\n\nYou can also pass a list of ID values into the *V* step. We take a\ncloser look at using variables in this way in the \\\"[Using a variable to\nfeed a traversal](#varaus)\\\" section.\n\n``` java\na=[3,6,8,15]\n\ng.V(a).values('code')\n```\n\nIf the graph database that you are using supports it you can set the ID\nof a vertex at the time you create it. How that can be done is explained\nin the \\\"[Using to specify new vertex ID values](#injectid)\\\" section.\n\nEvery property in the graph also has an ID as we shall explore in the\n\\\"[Properties have IDs too](#propid)\\\" section a bit later on.",
        "children": []
      },
      {
        "level": "3.9",
        "title": "3.9. Working with labels {#lab}",
        "content": "It's a good idea when designing a graph to give the vertices and edges\nmeaningful labels. You can use these to help refine searches. For\nexample in the *air-routes* graph, every airport vertex is labelled\n*airport* and every country vertex, not surprisingly, is labelled\n*country*. Similarly, edges that represent a flight route are labelled\n*route*. You can use labels in many ways. We already saw the *hasLabel*\nstep being used in the basic queries section to test for a particular\nlabel. Here are a few more examples.\n\n``` java\n// What label does the LBB vertex have?\ng.V().has('code','LBB').label()\n\n// What airports are located in Australia? Note that 'contains' is an\n// edge label and 'country' is a vertex label.\ng.V().hasLabel('country').has('code','AU').out('contains').values('code')\n\n// We could also write this query as follows\ng.V().has('country','code','AU').out().values('code')\n```\n\nBy using labels in this way we can effectively group vertices and edges\ninto classes or types. Imagine if we wanted to build a graph containing\ndifferent types of vehicles. We might decide to label all the vertices\njust *vehicle* but we could decide to use labels such as *car*, *truck*\nand *bus*. Ultimately the overall design of your graph's data model will\ndictate the way you use labels but it is good to be aware of their\nvalue.\n\n::: note\nAs useful as labels are, not all graph database engines provide support\nfor indexing them. You should check to see if the graph database\ntechnology you are using allows for labels to be indexed. If that is not\nthe case, it is recommended to use a vertex or edge property, that can\nbe indexed, as a surrogate for the label. This can then be used in graph\nqueries rather than relying on the vertex label. This is especially\nimportant when working with large graphs where performance can become an\nissue if the items you are looking for are not backed by an index.\n:::\n\nHere are a few more examples of ways we can work with labels.\n\n``` java\n// You can explicitly reference a vertex label using the label() method\ng.V().where(label().is(eq('airport'))).count()\n\n// Or using the label key word\ng.V().has(label,'airport').count()\n\n// But you would perhaps use the hasLabel() method in this case instead\ng.V().hasLabel('airport').count()\n\n// How many non airport vertices are there?\ng.V().has(label,neq('airport')).count()\ng.V().where(label().is(neq('airport'))).count()\n\n// Again, it might be more natural to actually write this query like this:\ng.V().not(hasLabel('airport')).count()\n```\n\nThe same concepts apply equally well when looking at edge labels as\nshown below.\n\n``` java\n// The same basic concepts apply equally to edges\ng.E().has(label,'route').count()\n\ng.E().where(label().is(eq('route'))).count()\n\ng.E().hasLabel('route').count()\n```\n\nOf course we have already seen another common place where labels might\nget used. Namely in the three parameter form of *has* as in the example\nbelow. The first parameter is the label value. The next two parameters\ntest the properties of all vertices that have the *airport* label for a\ncode of \\\"*SYD*\\\".\n\n``` java\ng.V().has('airport','code','SYD')\n```\n\nIt is also possible to specify more than one label in the same step as\nshown below. In general, whenever a step can be provided a label, more\nthan one may also be provided.\n\n``` java\ng.E().hasLabel('route','contains')\n```",
        "children": []
      },
      {
        "level": "3.10",
        "title": "3.10. Using the *local* step to make sure we get the result we intended {#local}",
        "content": "Sometimes it is important to be able to do calculations based on the\ncurrent state of a traversal rather than waiting until near the end. A\ncommon place where this is necessary is when calculating the average\nvalue of a collection. In the next section we are going to look at a\nselection of numerical and statistical operations that Gremlin allows us\nto perform. However, for now lets use the *mean* step to calculate the\naverage of something and look at the effect the *local* step has on the\ncalculation. The *mean* step works just like you would expect, it\nreturns the mean, or average, value for a set of numbers.\n\nIf we wanted to calculate the average number of routes from an airport,\nthe first query that we would write might look like the one below.\n\n``` java\ng.V().hasLabel('airport').out('route').count().mean()\n\n43400.0\n```\n\nAs you can see the answer we got back, *43400.0* looks wrong, and indeed\nit is. That number is in fact the total number of outgoing routes in the\nentire graph. This is because as written the query counts all of the\nroutes, adds them all up, but does not keep track of how many airports\nit visited. This means that calling the *mean* step is essentially the\nsame as dividing the count by one.\n\nSo how do we fix this? The answer is to use the *local* step. What we\nreally want to do is to create, in essence, a collection of values,\nwhere each value is the route count for just one airport. Having done\nthat, we want to divide the sum of all of these numbers by the number of\nmembers, airports in this case, into the collection.\n\nTake a look at the modified query below.\n\n``` java\n// Average number of outgoing routes from an airport.\ng.V().hasLabel('airport').local(out('route').count()).mean()\n\n12.863070539419088\n```\n\nThe result this time is a much more believable answer. Notice how this\ntime we placed the *out(*\\'route*\\').count()* steps inside a *local*\nstep. The query below, with the mean step removed, shows what is\nhappening during the traversal as this query runs. I truncated the\noutput to just show a few lines.\n\n``` java\ng.V().hasLabel('airport').local(out('route').count()).limit(10)\n\n232\n38\n59\n55\n129\n87\n93\n220\n141\n135\n```\n\nWhat this shows is that for the first ten airports the collection that\nwe are building up contains one entry for each airport that represents\nthe number of outgoing routes that airport has. Then, when we eventually\napply the *mean* step it will calculate the average value of our entire\ncollection and give us back the result that we were looking for.\n\nLet's look at another example where we can use the *local* step to\nchange the results of a query in a useful way. First of all, take a look\nat the query below and the results that it generates. The query first\nfinds all the airports located in Scotland using the region code of\n*GB-SCT*. It then creates an ordered list of airport codes and city\nnames into a list.\n\n``` java\ng.V().has('region','GB-SCT').order().by('code').\n      values('code','city').fold()\n```\n\nHere are the results from running the query.\n\n``` java\n[ABZ,Aberdeen,BEB,Balivanich,BRR,Eoligarry,CAL,Campbeltown,DND,Dundee,EDI,Edinburgh,EOI,Eday,FIE,Fair Isle,FOA,Foula,GLA,Glasgow,ILY,Port Ellen,INV,Inverness,KOI,Orkney Islands,LSI,Lerwick,LWK,Lerwick,NDY,Sanday,NRL,North Ronaldsay,PIK,Glasgow,PPW,Papa Westray,PSV,Papa Stour Island,SOY,Stronsay,SYY,Stornoway,TRE,Balemartine,WIC,Wick,WRY,Westray]\n```\n\nHowever, it would be more convenient perhaps to have the results be\nreturned as a list of lists where each small list contains the airport\ncode and city name with all the small lists wrapped inside a big list.\nWe can achieve this by wrapping the second half of the query inside of a\n*local* step as shown below.\n\n``` java\ng.V().has('region','GB-SCT').order().by('code').\n      local(values('code','city').fold())\n```\n\nHere are the results of running the modified query. I have arranged the\nresults in two columns to aid readability.\n\n``` java\n[ABZ,Aberdeen]          [LSI,Lerwick]\n[BEB,Balivanich]        [LWK,Lerwick]\n[BRR,Eoligarry]         [NDY,Sanday]\n[CAL,Campbeltown]       [NRL,North Ronaldsay]\n[DND,Dundee]            [PIK,Glasgow]\n[EDI,Edinburgh]         [PPW,Papa Westray]\n[EOI,Eday]              [PSV,Papa Stour Island]\n[FIE,Fair Isle]         [SOY,Stronsay]\n[FOA,Foula]             [SYY,Stornoway]\n[GLA,Glasgow]           [TRE,Balemartine]\n[ILY,Port Ellen]        [WIC,Wick]\n[INV,Inverness]         [WRY,Westray]\n[KOI,Orkney Islands]\n```\n\nThere are many other ways that *local* can be used. You will find\nexamples of those throughout the book. You will see some that show how\nlocal can be used as a parameter to the *order* step when we dig deeper\ninto route analysis in the \\\"[Distribution of routes in the graph (mode\nand mean)](#meanmode)\\\" section.",
        "children": []
      },
      {
        "level": "3.11",
        "title": "3.11. Basic statistical and numerical operations {#st}",
        "content": "The following queries demonstrate concepts such as calculating the\namount of a particular item that is present in the graph, calculating\nthe average (mean) of a set of values and calculating a maximum or\nminimum value. The table below summarizes the available steps.\n\n+-------------+--------------------------------------------------------+\n| count       | Count how many of something exists.                    |\n+-------------+--------------------------------------------------------+\n| sum         | Sum (add up) a collection of values.                   |\n+-------------+--------------------------------------------------------+\n| max         | Find the maximum value in a collection of values.      |\n+-------------+--------------------------------------------------------+\n| min         | Find the minimum value in a collection of values.      |\n+-------------+--------------------------------------------------------+\n| mean        | Find the mean (average) value in a collection.         |\n+-------------+--------------------------------------------------------+\n\n: Basic statistical steps\n\nWe will dig a bit deeper into some of these capabilities and explain in\nmore detail in the \\\"[Distribution of routes in the graph (mode and\nmean)](#meanmode)\\\" section of the book. Some of these examples also\ntake advantage of the *local* step that was introduced in the previous\nsection. A way of calculating the standard deviation within a data set\nis presented later in the \\\"[Gremlin's scientific calculator -\nintroducing ](#mathstep)\\\" section. The results of running each query\nare also shown in the examples below.\n\n``` java\n// How many routes are there from Austin?\ng.V().has(\"airport\",\"code\",\"AUS\").out().count()\n\n59\n\n// Sum of values - total runways of all airports\ng.V().hasLabel('airport').values('runways').sum()\n\n4828\n```\n\nThe *mean* step allows us to find the mean (average) value in a data\nset.\n\n``` java\n// Statistical mean (average) value - average number of runways per airport\ng.V().hasLabel('airport').values('runways').mean()\n\n1.4309425014819206\n\n// Average length of the longest runway across all airports\ng.V().hasLabel('airport').values('longest').mean()\n\n7570.862477771191\n\n// Average number of routes to and from an airport\ng.V().hasLabel('airport').local(both('route').count()).mean()\n\n25.726141078838175\n```\n\nThe following queries find maximum and minimum values using the *max*\nand *min* steps.\n\n``` java\n//maximum value - longest runway\ng.V().hasLabel('airport').values('longest').max()\n\n18045\n\n// What is the biggest number of outgoing routes any airport has?\ng.V().hasLabel('airport').local(out('route').count()).max()\n\n272\n\n//minimum value - shortest runway\ng.V().hasLabel('airport').values('longest').min()\n\n1300\n```\n\nIt is also possible in more recent versions of Apache TinkerPop to use\nthe *min* and *max* steps with more than just numeric values.\n\n::: note\nBefore TinkerPop 3.4 was released *min* and *max* could only be used\nwith numeric values. It is now possible to also test any values that are\nconsidered *\\\"comparable\\\"*.\n:::\n\nPrior to TinkerPop 3.4, it was only possible to work with purely numeric\nvalues when using *min* and *max*. It is now possible to apply these\nsteps to any values that are considered *\\\"comparable\\\"*. So, for\nexample, we can now compare strings as well as numbers. The examples\nbelow look for the minimum and maximum value in the descriptive names of\nthe continents.\n\n``` java\ng.V().hasLabel('continent').values('desc').min()\n\nAfrica\n\ng.V().hasLabel('continent').values('desc').max()\n\nSouth America\n```\n\nPrior to TinkerPop 3.4, a similar result could still be achieved by\nordering the results and simply returning the first one.\n\n``` java\ng.V().hasLabel('continent').values('desc').order().limit(1)\n\nAfrica\n\ng.V().hasLabel('continent').values('desc').order().by(desc).limit(1)\n\nSouth America\n```",
        "children": []
      },
      {
        "level": "3.12",
        "title": "3.12. Testing values and ranges of values {#tranges}",
        "content": "We have already seen some ways of testing whether a value is within a\ncertain range. Gremlin provides a number of different predicates that we\ncan use to do range testing. The list below provides a summary of the\navailable predicates. We will see each of these in use throughout this\nbook.\n\n+-------------+--------------------------------------------------------+\n| eq          | Equal to                                               |\n+-------------+--------------------------------------------------------+\n| neq         | Not equal to                                           |\n+-------------+--------------------------------------------------------+\n| gt          | Greater than                                           |\n+-------------+--------------------------------------------------------+\n| gte         | Greater than or equal to                               |\n+-------------+--------------------------------------------------------+\n| lt          | Less than                                              |\n+-------------+--------------------------------------------------------+\n| lte         | Less than or equal to                                  |\n+-------------+--------------------------------------------------------+\n| inside      | Inside a lower and upper bound, neither bound is       |\n|             | included.                                              |\n+-------------+--------------------------------------------------------+\n| outside     | Outside a lower and upper bound, neither bound is      |\n|             | included.                                              |\n+-------------+--------------------------------------------------------+\n| between     | Between two values inclusive/exclusive (upper bound is |\n|             | excluded)                                              |\n+-------------+--------------------------------------------------------+\n| within      | Must match at least one of the values provided. Can be |\n|             | a range or a list                                      |\n+-------------+--------------------------------------------------------+\n| without     | Must not match any of the values provided. Can be a    |\n|             | range or a list                                        |\n+-------------+--------------------------------------------------------+\n\n: Predicates that test values or ranges of values\n\nThe following queries demonstrate these capabilities being used in\ndifferent ways. First of all, here are some examples of some of the\ndirect compare steps such as *gt* and *gte* being used. The *fold* step\nconveniently folds all of the results into a list for us.\n\n``` java\n// Airports with at least 5 runways\ng.V().has('runways',gte(5)).values('code','runways').fold()\n```\n\nHere is the output that we might get from running the query.\n\n``` java\n[ATL,5,BOS,6,DFW,7,IAH,5,ORD,8,DEN,6,DTW,6,YYZ,5,AMS,6,SNN,5,MKE,5,MDW,5,GIS,5,HLZ,5,NPE,5,NSN,5,PPQ,5,TRG,5,UFA,5,KRP,5]\n```\n\nThe next three queries show examples of *lt*, *eq* and *neq* being used.\n\n``` java\n// Airports with fewer than 3 runways\ng.V().has('runways',lt(3)).values('code','runways').fold()\n\n// How many airports have 3 runways?\ng.V().has('runways',eq(3)).count()\n\n// How many airports have anything but just 1 runway?\ng.V().has('runways',neq(1)).count()\n```\n\nNote that in some cases, such as when using a simple *has* step the *eq*\nis not actually required. For example the query used above could be\nwritten as follows instead.\n\n``` java\ng.V().has('runways',3).count()\n```\n\nYou could also write this query using an *is* step. You will find the\n*is* step used a lot in this book but mostly in conjunction with *where*\nsteps. To me the usage below does not feel as elegant as the *has* step\nalternative used above.\n\n``` java\n// How many airports have 3 runways?\ng.V().values('runways').is(3).count()\n```\n\nHere are examples of *inside* and *outside* being used.\n\n``` java\n// Airports with greater than 3 but fewer than 6 runways.\ng.V().has('runways',inside(3,6)).values('code','runways')\n\n// Airports with fewer than 3 or more than 6 runways.\ng.V().has('runways',outside(3,6)).values('code','runways')\n```\n\nBelow are some examples showing *within* and *without* being used.\n\n``` java\n// Airports with at least 3 but not more than 6 runways\ng.V().has('runways',within(3..6)).values('code','runways').limit(15)\n\n// Airports with 1,2 or 3 runways.\ng.V().has('runways',within(1,2,3)).values('code','runways').limit(15)\n\n// Airports with fewer than 3 or more than 6 runways.\ng.V().has('runways',without(3..6)).values('code','runways').limit(15)\n```\n\nThe *between* step lets us test the provided value for being greater\nthan or equal to a lower bound but less than an upper bound. The query\nbelow will find any airport that has 5,6 or 7 runways. In other words,\nany airport that has at least 5 but fewer than 8 runways.\n\n``` java\n// Airports with at least 5 runways but fewer than 8\ng.V().has('runways',between(5,8)).values('code','runways').fold()\n```\n\nHere is the result of running the query.\n\n``` java\n[ATL,5,BOS,6,DFW,7,IAH,5,DEN,6,DTW,6,YYZ,5,AMS,6,SNN,5,MKE,5,MDW,5,GIS,5,HLZ,5,NPE,5,NSN,5,PPQ,5,TRG,5,UFA,5,KRP,5]\n```\n\nAs with many queries we may build, there are several ways to get the\nsame answer. Each of the following queries will return the same result.\nTo an extent which one you use comes down to personal preference\nalthough in some cases one form of a query may be better than another\nfor reasons of performance.\n\n``` java\ng.V().hasId(gt(0)).hasId(lte(46)).out().hasId(lte(46)).count()\n\ng.V().hasId(within(1..46)).out().hasId(lte(46)).count()\n\ng.V().hasId(within(1..46)).out().hasId(within(1L..46L)).count()\n\ng.V().hasId(between(1,47)).out().hasId(lte(46)).count()\n\ng.V().hasId(within(1..46)).out().hasId(between(1,47)).count()\n\ng.V().hasId(inside(0,47)).out().hasId(lte(46)).count()\n```\n\n::: note\nThe values do not have to be numbers. We could also compare strings for\nexample.\n:::\n\nLet's now look at a query that compares strings rather than numbers. The\nfollowing query finds all airports located in the state of Texas in the\nUnited States but only returns their code if the name of the city the\nairport is located in is not *Houston*.\n\n``` java\ng.V().has('airport','region','US-TX').\n      has('city',neq('Houston')).\n      values('code')\n```\n\nThis next query can be used to find routes between Austin and Las Vegas.\nWe use a *within* step to limit the results we get back to just routes\nthat have a plane change in Dallas, San Antonio or Houston airports.\n\n``` java\n g.V().has('airport','code','AUS').\n       out().has('code',within('DFW','DAL','IAH','HOU','SAT')).\n       out().has('code','LAS').path().by('code')\n```\n\nHere is what the query returns. Looks like we can change planes in\nDallas or Houston but nothing goes via San Antonio.\n\n``` java\n[AUS,DFW,LAS]\n[AUS,IAH,LAS]\n[AUS,DAL,LAS]\n[AUS,HOU,LAS]\n```\n\nConversely, if we wanted to avoid certain airports we could use\n*without* instead. This query again finds routes from Austin to Las\nVegas but avoids any routes that go via Phoenix (PHX) or Los Angeles\n(LAX).\n\n``` java\n g.V().has('airport','code','AUS').\n       out().has('code',without('PHX','LAX')).\n       out().has('code','LAS').path().by('code')\n```\n\nLastly this query uses both within and without to modify the previous\nquery to just airports within the United States or Canada as Austin now\nhas a direct flight to London in England. We probably don't want to go\nthat way if we are headed to Vegas!\n\n``` java\ng.V().has('airport','code','AUS').out().\n      has('country',within('US','CA')).\n      has('code',without('PHX','LAX')).out().\n      has('code','LAS').path().by('code')\n```\n\nThe *within* and *without* steps can take a variety of input types. For\nexample, each of these queries will yield the same results.\n\n``` java\n// Range of values (inclusive, inclusive)\ng.V().hasId(within(1..3))\n\n// Explicit set of values\ng.V().hasId(within(1,2,3))\n\n// List of values\ng.V().hasId(within([1,2,3]))\n```\n\nYou will find more examples of these types of queries in the next two\nsections.",
        "children": [
          {
            "level": "3.12.1",
            "title": "3.12.1. Using *between* to simulate *startsWith* {#startswith}",
            "content": "One thing that may not be obvious is that when using string values with\nthe *between* predicate the values do not have to specify exact matches.\nTake a look at the query below. This will find any airports in cities\nwhose names start with *\\\"Dal\\\"* as it looks for strings between\n*\\\"Dal\\\"* and *\\\"Dam\\\"* in an inclusive/exclusive fashion. The rest of\nthe characters following *\\\"Dal\\\"* in the strings being tested are\nignored. Note that this is a case sensitive comparison. In other words\n*\\\"Dal\\\"* and *\\\"dal\\\"* are different strings in this context.\n\n::: tip\nThe *between* predicate can be used to simulate a string *startsWith*\nmethod.\n:::\n\nAs discussed more in the \\\"[Using regular expressions to do fuzzy\nsearches](#fuzzyregs)\\\" section, Gremlin does not currently support any\nmethods for applying regular expressions or even more basic text\nanalysis operators to strings. This use of the *between* predicate can\nat least be used to simulate a *startsWith* type of operator. It is\nlikely that support for additional text search predicates will appear in\nfuture Apache TinkerPop releases.\n\n``` java\ng.V().hasLabel('airport').\n      has('city',between('Dal','Dam')).\n      values('city')\n```\n\nHere are the results from running the query. As you can see every city\nname starts with the characters *\\\"Dal\\\"*.\n\n``` java\nDallas\nDallas\nDalaman\nDalian\nDalcahue\nDalat\nDalanzadgad\n```\n\nYou will notice from the results above that *\\\"Dallas\\\"* appears twice\nas there are two airports with that city name. We could add a *dedup*\nstep to our query to only return unique matches.\n\n``` java\ng.V().hasLabel('airport').\n      has('city',between('Dal','Dam')).\n      values('city').dedup()\n```\n\nHere are the modified results.\n\n``` java\nDallas\nDalaman\nDalian\nDalcahue\nDalat\nDalanzadgad\n```\n\nHere is one more example where the range of values being compared is\nexpanded a little. This query will find any cities that start with\n*\\\"Dal\\\"* through *\\\"Dar\\\"*.\n\n``` java\ng.V().hasLabel('airport').\n      has('city',between('Dal','Dat')).\n      values('city').order().dedup()\n```\n\nAs you can see this time, more cities met our search criteria.\n\n``` java\nDalaman\nDalanzadgad\nDalat\nDalcahue\nDalian\nDallas\nDamascus\nDandong\nDangriga\nDaocheng\nDaqing Shi\nDar es Salaam\nDaru\nDarwin\n```\n\nIf you wanted to find strings that begin with a single character you can\nachieve that as follows.\n\n``` java\ng.V().has('airport','code',between('X','Xa')).\n      values('code').fold()\n```\n\nWhen run, the query returns all airports with codes that start with the\nletter *\\\"X\\\"*.\n\n``` java\n[XNA,XMN,XRY,XIY,XUZ,XSB,XCH,XIL,XFN,XNN,XGR,XFW,XCR,XSC,XQP,XMH,XBJ,XAP,XMS,XKH,XIC,XTG,XKS,XBE,XTO]\n```\n\nWhile Gremlin does not currently provide any advanced text searching\ncapabilities, graph systems such as JanusGraph do offer such\ncapabilities. Those features are discussed in the \\\"[Additional\nJanusGraph text search predicates](#janpred)\\\" section.",
            "children": []
          },
          {
            "level": "3.12.2",
            "title": "3.12.2. Refining flight routes analysis using *not*, *neq*, *within* and *without* {#winout}",
            "content": "As we saw in the previous section, it is often useful to be able to\nspecifically include or exclude values from a query. We have already\nseen a few examples of *within* and *without* being used in the section\nabove. The following examples show additional queries that use *within*\nand *without* as well as some examples that use the *neq* (not equal)\nand *not* steps to exclude certain airports from query results.\n\nThe following query finds routes from AUS to SYD with only one stop but\nignores any routes that stop in DFW.\n\n``` java\ng.V().has('airport','code','AUS').\n      out().has('code',neq('DFW')).\n      out().has('code','SYD').path().by('code')\n```\n\nWe could also have written the query using *not*\n\n``` java\ng.V().has('airport','code','AUS').\n      out().not(values('code').is('DFW')).\n      out().has('code','SYD').path().by('code')\n```\n\nSimilar to the above but adding an *and* clause to also avoid LAX\n\n``` java\ng.V().has('airport','code','AUS').\n      out().and(has('code',neq('DFW')),has('code',neq('LAX'))).\n      out().has('code','SYD').path().by('code')\n```\n\nWe could also have written the prior query this way replacing *and* with\n*without*. This approach feels a lot cleaner and it is easy to add more\nairports to the *without* test as needed. We will look more at steps\nlike *and* in the \\\"[Boolean operations](#bool)\\\" section that is coming\nup soon.\n\n``` java\n// Flights to Sydney avoiding DFW and LAX\ng.V().has('airport','code','AUS').\n      out().has('code',without('DFW','LAX')).\n      out().has('code','SYD').path().by('code')\n```\n\nUsing *without* is especially useful when you want to exclude a list of\nitems from a query. This next query finds routes from San Antonio to\nSalt Lake City with one stop but avoids any routes that pass through a\nlist of specified airports.\n\n``` java\n// How can I get from SAT to SLC but avoiding DFW,LAX,PHX and JFK ?\ng.V().has('airport','code','SAT').\n      out().has('code',without('DFW','LAX','PHX','JFK')).\n      out().has('code','SLC').path().by('code')\n```\n\nIn a similar way, *within* allows us to specifically give a list of\nthings that we **are** interested in. The query below again looks at\nroutes from SAT to SLC with one stop but this time only returns routes\nthat stop in one of the designated airports.\n\n``` java\n// From AUS to SLC with a stop in any one of DFW,LAX,PHX or TUS\ng.V().has('airport','code','SAT').\n       out().has('code',within('DFW','LAX','PHX','TUS')).\n       out().has('code','SLC').path().by('code')\n```\n\nHere is what the query returns.\n\n``` java\n[SAT,LAX,SLC]\n[SAT,DFW,SLC]\n```\n\nHere are two more examples that use *without* and *within* to find\nroutes based on countries.\n\n``` java\n// Flights from Austin to countries outside (without) the US and Canada\ng.V().has('code','AUS').out().has('country',without('US','CA')).values('city')\n```\n\nHere is the output from running the query.\n\n``` java\nLondon\nFrankfurt\nMexico City\nCancun\nGuadalajara\n```\n\nHere is a twist on the previous query that looks for destinations in\nMexico or Canada that you can fly to non stop from Austin.\n\n``` java\n// Flights from Austin to airports in (within) Mexico or Canada\ng.V().has('code','AUS').out().has('country',within('MX','CA')).values('city')\n```\n\nThis is what we get back from our new query.\n\n``` java\nToronto\nMexico City\nCancun\nGuadalajara\n```",
            "children": []
          },
          {
            "level": "3.12.3",
            "title": "3.12.3. Using *coin* and *sample* to sample a dataset {#_using_coin_and_sample_to_sample_a_dataset}",
            "content": "In any sort of analysis work it is often useful to be able to take a\nsample, perhaps a pseudo random sample, of the data set contained within\nyour graph. The *coin* step allows you to do just that. It simulates a\nbiased coin toss. You give *coin* a value indicating how biased the toss\nshould be. The value should be between 0 and 1, where 0 means there is\nno chance something will get picked (not that useful!), 1 means\neverything will get picked (also not that useful!) and 0.5 means there\nis an even 50/50 chance that an item will get selected.\n\nThe following query simply picks airports with a 50/50 coin toss and\nreturns the airport code for the first 20 found.\n\n``` java\n// Pick 20 airports at random with an evenly biased coin (50% chance).\ng.V().hasLabel('airport').coin(0.5).limit(20).values('code')\n```\n\nThis next query is similar to the first but takes a subtly different\napproach. It will select a pseudo random sample of vertices from the\ngraph and for each one picked return its code and its elevation. Note\nthat a very small value of 0.05 (or 5% chance of success) is used for\nthe *coin* bias parameter this time. This has the effect that only a\nsmall number of vertices are likely to get selected but there is a\nbetter chance they will come from all parts of the graph and avoids\nneeding a *limit* step. Of course, there is no guarantee how many\nairports this query will pick!\n\n``` java\n// Select some vertices at random and return them with their elevation.\ng.V().hasLabel('airport').coin(0.05).values('code','elev').fold()\n```\n\nWe can see how fairly the *coin* step is working by counting the number\nof vertices returned. The following query should always return a count\nrepresenting approximately half of the airports in the graph.\n\n``` java\ng.V().hasLabel('airport').coin(0.5).count()\n```\n\nIf all you want is, say 20 randomly selected vertices, without worrying\nabout setting the value of the coin yourself, you can use the *sample*\nstep instead.\n\n``` java\ng.V().hasLabel('airport').sample(20).values('code')\n```",
            "children": []
          },
          {
            "level": "3.12.4",
            "title": "3.12.4. Using *Math.random* to more randomly select a single vertex {#_using_math_random_to_more_randomly_select_a_single_vertex}",
            "content": "While the *sample* step allows you to select one or more vertices at\nrandom, in my testing, at least when using a TinkerGraph, it tends to\nfavor vertices with lower index values. So for example, in a test I ran\nthis query 1000 times.\n\n``` java\ng.V().hasLabel('airport').sample(1).id()\n```\n\nWhat I found was that I always got back an ID of less than 200. This\nleads me to believe that the *sample(1)* call is doing something similar\nto this\n\n``` java\ng.V().hasLabel('airport').coin(0.01).limit(1)\n```\n\nLook at the code below. Even if I run that simple experiment many times\nit always gives results similar to these.\n\n``` java\n(1..10).each { println g.V().hasLabel('airport').sample(1).id().next()}\n\n69\n143\n94\n115\n36\n47\n23\n22\n129\n67\n```\n\nGiven the air routes graph has over 3,300 airport vertices I wanted to\ncome up with a query that gave a more likely result of picking any one\nairport from across all of the possible airports in the graph. By taking\nadvantage of the Java Math class we can do something that does seem to\nmuch more *randomly* pick one airport from across all of the possible\nairports. Take a look at the snippets of Groovy/Gremlin code below.\n\n::: note\nMore examples of using variables to store values and other ways to use\nadditional Groovy classes and methods with Gremlin are provided in the\n\\\"[Making Gremlin even Groovier](#grv)\\\" and \\\"[Using a variable to feed\na traversal](#varaus)\\\" sections.\n:::\n\n``` java\n// How many airports are there?\nnumAirports = g.V().hasLabel('airport').count().next()\n\n3374\n\n// Pick a random airport ID\nx=Math.round(numAirports*Math.random()) as Integer\n\n2359\n\n// Get the code for our randomly selected airport\ng.V(x).values('code')\n\nPHO\n```\n\nThis simple experiment shows that the numbers being generated using the\n*Math.random* approach appears to be a lot more evenly distributed\nacross all of the possible airports.\n\n``` java\n(1..10).each { println Math.round(numAirports*Math.random()) as Integer}\n\n1514\n18\n3087\n1292\n3062\n2772\n2401\n400\n2084\n3028\n```\n\nNote that this approach only works unmodified with the *air-routes*\ngraph loaded into a TinkerGraph. This is because we know that the\nTinkerGraph implementation honors user provided IDs and that in the\n*air-routes* graph, airport IDs begin at one and are sequential with no\ngaps. However, you could easily modify this approach to work with other\ngraphs without relying on knowing that the index values are sequential.\nFor example you could extract all of the IDs into a list and then select\none randomly from that list.\n\nIt is likely that this apparent lack of randomness is more specific to\nTinkerGraph and the fact that it will respect user provided ID values\nwhereas other graph systems will probably store vertices in a more\nrandom order to begin with. Indeed when I ran these queries on\nJanusGraph the *sample* step did yield a better selection of airports\nfrom across the graph.\n\nIf the airport IDs were not all known to be in a sequential order one\nafter the other, we could create a list of all the airport IDs and then\nselect one at random by doing something like this if we wanted to use\nour *Math.random* technique.\n\n``` java\nairports = g.V().hasLabel('airport').id().toList()\n\nnumAirports = airports.size\n\n3374\n\nx=Math.round(numAirports*Math.random()) as Integer\n\n859\n\ng.V(airports[x-1])\n\nv[859]\n\ng.V(airports[x-1]).values('code')\n\nOSR\n```",
            "children": []
          }
        ]
      },
      {
        "level": "3.13",
        "title": "3.13. New text search predicates added in TinkerPop 3.4 {#textpredicates}",
        "content": "Probably one of, if not the, most anticipated features in Apache\nTinkerPop version 3.4 was the addition of new *\\\"predicates\\\"* that aid\nin performing more focused text searches.\n\n::: tip\nAdditional information on the text predicates can be found in the\nofficial Apache TinkerPop documentation here:\n<http://tinkerpop.apache.org/docs/current/reference/#a-note-on-predicates>\n:::\n\nIn total, six new predicates were added to the Gremlin query language.\nThere are three predicates that search for the existence of one or more\ncharacters within a string of text and three that search for the non\nexistence of one or more characters.\n\n+-------------+--------------------------------------------------------+\n| s           | Match text that starts with the given character(s)     |\n| tartingWith |                                                        |\n+-------------+--------------------------------------------------------+\n| endingWith  | Match text that ends with the given charcter(s)        |\n+-------------+--------------------------------------------------------+\n| containing  | Match text that contains the given character(s)        |\n+-------------+--------------------------------------------------------+\n| notS        | Match text that does not start with the given          |\n| tartingWith | character(s)                                           |\n+-------------+--------------------------------------------------------+\n| no          | Match text that does not end with the given            |\n| tEndingWith | charcter(s)                                            |\n+-------------+--------------------------------------------------------+\n| no          | Match text that does notcontain the given character(s) |\n| tContaining |                                                        |\n+-------------+--------------------------------------------------------+\n\n: Text searching predicates\n\nIn the sections below you will find examples of each predicate being\nused. Each predicate is case sensitive so bear that in mind as you use\nthem. To do a case insensitive search you can chain multiple steps\ntogether combined by an *or* step.\n\n::: note\nAll of these predicates are ***case sensitive***.\n:::\n\nThese predicates add to the existing Gremlin predicates that we looked\nat in the [Testing values and ranges of values](#tranges) section.",
        "children": [
          {
            "level": "3.13.1",
            "title": "3.13.1. startingWith",
            "content": "The text that you search for can be one or more characters. Here is a\nsimple example that looks for unique city names that begin with an\nuppercase \\\"X\\\".\n\n``` java\ng.V().hasLabel('airport').\n      has('city',startingWith('X')).\n      values('city')\n```\n\nAs expected, when run we get back a set of names all beginning with an\n\\\"X\\\".\n\n``` java\nXiamen\nXianyang\nXuzhou\nXilinhot\nXiangfan\nXining\nXalapa\nXieng Khouang\nXiahe\nXiaguan\nXichang\nXingyi\nXinyuan\nXigaze\n```\n\nThe example below looks for any cities with names starting with \\\"Dal\\\".\nA *dedup* step is used to get rid of any duplicate names in the results.\n\n``` java\ng.V().hasLabel('airport').\n      has('city',startingWith('Dal')).\n      values('city').\n      dedup().\n      fold()\n```\n\nWhen run, the query finds all the city names in the graph that begin\nwith the characters \\\"Dal\\\" as expected.\n\n``` java\n[Dalat, Dallas, Dalcahue, Dalaman, Dalian, Dalanzadgad]\n```\n\nAs I mentioned, all of the text predicates are case sensitive. If we\nwere to search for city names starting with the characters \\\"dal\\\" we\nwould not find any matches. The query below demonstrates this.\n\n``` java\ng.V().hasLabel('airport').\n      has('city',startingWith('dal')).\n      count()\n\n0\n```\n\nGiven the predicates are case sensitive, if, for example, you need to\nfind matches for both *Dal* or *dal* you can do that as shown below\nusing an *or* step and two *has* steps.\n\n``` java\ng.V().hasLabel('airport').\n      or(has('city',startingWith('dal')),\n         has('city',startingWith('Dal'))).\n      dedup().by('city').\n      count()\n\n6\n```",
            "children": []
          },
          {
            "level": "3.13.2",
            "title": "3.13.2. endingWith",
            "content": "The example below looks for any city names ending with that characters\n\\\"zhi\\\".\n\n``` java\ng.V().hasLabel('airport').\n      has('city',endingWith('zhi')).\n      values('city')\n\nChangzhi\n```",
            "children": []
          },
          {
            "level": "3.13.3",
            "title": "3.13.3. containing",
            "content": "We can also look for cities whose names contain a certain string of one\nor more characters. The example below looks for any cities with the\nstring \\\"gzh\\\" in their name.\n\n``` java\ng.V().hasLabel('airport').\n      has('city',containing('gzh')).\n      values('city')\n```\n\nWhen run the query produces the following results.\n\n``` java\nGuangzhou\nHangzhou\nZhengzhou\nChangzhi\nChangzhou\nYongzhou\nYangzho\n```",
            "children": []
          },
          {
            "level": "3.13.4",
            "title": "3.13.4. notStartingWith {#notStartingWith}",
            "content": "Each of the text predicates has an inverse step. We can use the\n*notStartingWith* predicate to look for city names that do not start\nwith \\\"Dal\\\".\n\n``` java\ng.V().hasLabel('airport').\n      has('city',notStartingWith('Dal')).\n      count()\n\n3367\n```\n\nThe example above returns the same results we would get if we were to\nnegate a *startingWith* predicate as shown below.\n\n``` java\ng.V().hasLabel('airport').\n      not(has('city',startingWith('Dal'))).\n      count()\n\n3367\n```",
            "children": []
          },
          {
            "level": "3.13.5",
            "title": "3.13.5. notEndingWith {#notEndingWith}",
            "content": "Using *notEndingWith* we can easily find cities whose names do not end\nwith \\\"zhi\\\".\n\n``` java\ng.V().hasLabel('airport').\n      has('city',notEndingWith('zhi')).\n      count()\n\n3373\n```",
            "children": []
          },
          {
            "level": "3.13.6",
            "title": "3.13.6. notContaining {#notContaining}",
            "content": "The query below counts the number of cities that do not contain the\nstring \\\"berg\\\" in their name.\n\n``` java\ng.V().hasLabel('airport').\n      has('city',notContaining('berg')).\n      count()\n\n3370\n```\n\nLet's now do something a little more interesting. The query below chains\ntogether a number of has steps using *notContaining* and *containing*\npredicates to find cities with names containing no basic, lowercase,\nvowels commonly used in the English language but containing either of\nthe secondary vowels.\n\n``` java\ng.V().hasLabel('airport').\n      has('city',notContaining('e')).\n      has('city',notContaining('a')).\n      has('city',notContaining('i')).\n      has('city',notContaining('u')).\n      has('city',notContaining('o')).\n      or(has('city',containing('y')),\n         has('city',containing('h'))).\n      values('city').\n      dedup()\n```\n\nOnly two results are found. Note that one of the results does contain a\nvowel but it is an uppercase \\\"O\\\" and as such is allowed by the\nconstraints that we specified.\n\n``` java\nOsh\nKyzyl\n```",
            "children": []
          }
        ]
      },
      {
        "level": "3.14",
        "title": "3.14. Sorting things - introducing *order* {#sort}",
        "content": "You can use *order* to sort things in either ascending (the default) or\ndescending order. Note that the sort does not have to be the last step\nof a query. It is perfectly OK to sort things in the middle of a query\nbefore moving on to a further step. We can see examples of that in the\nfirst two queries below. Note that the first query will return different\nresults than the second one due to the placement of the *limit* step. I\nused *fold* at the end of the query to collect all of the results into a\nlist. The *fold* step can also do more than this. It provides a way of\ndoing the *reduce* part of map-reduce operations. We will see some other\nexamples of its use elsewhere in this book, such as in the \\\"[Using to\ndo simple Map-Reduce computations](#mapreduce)\\\" section.\n\n``` java\n// Sort the first 20 airports returned in ascending order\ng.V().hasLabel('airport').limit(20).values('code').order().fold()\n\n[ANC,ATL,AUS,BNA,BOS,BWI,DCA,DFW,FLL,IAD,IAH,JFK,LAX,LGA,MCO,MIA,MSP,ORD,PBI,PHX]\n```\n\nAs above, but this time perform the *limit* step after the *order* step.\n\n``` java\n// Sort all of the airports in the graph by their code and then return the first 20\ng.V().hasLabel('airport').order().by('code').limit(20).values('code').fold()\n\n[AAE,AAL,AAN,AAQ,AAR,AAT,AAX,AAY,ABA,ABB,ABD,ABE,ABI,ABJ,ABL,ABM,ABQ,ABR,ABS,ABT]\n```\n\nHere is a similar example to the previous two. We find all of the places\nyou can fly to from Austin (AUS) and sort the results as before, using\nthe airport's IATA code, but this time we also include the ICAO code for\neach airport in the result set.\n\n``` java\ng.V().has('code','AUS').out().order().by('code').\n                        values('code','icao').fold()\n```\n\nHere are the results from running the query.\n\n``` java\n[ABQ,KABQ,ATL,KATL,BKG,KBBG,BNA,KBNA,BOS,KBOS,BWI,KBWI,CLE,KCLE,CLT,KCLT,CUN,MMUN,CVG,KCVG,DAL,KDAL,DCA,KDCA,DEN,KDEN,DFW,KDFW,DTW,KDTW,ELP,KELP,EWR,KEWR,FLL,KFLL,FRA,EDDF,GDL,MMGL,HOU,KHOU,HRL,KHRL,IAD,KIAD,IAH,KIAH,IND,KIND,JFK,KJFK,LAS,KLAS,LAX,KLAX,LBB,KLBB,LGB,KLGB,LHR,EGLL,MCI,KMCI,MCO,KMCO,MDW,KMDW,MEM,KMEM,MEX,MMMX,MIA,KMIA,MSP,KMSP,MSY,KMSY,OAK,KOAK,ORD,KORD,PDX,KPDX,PHL,KPHL,PHX,KPHX,PIE,KPIE,PIT,KPIT,PNS,KPNS,RDU,KRDU,SAN,KSAN,SEA,KSEA,SFB,KSFB,SFO,KSFO,SJC,KSJC,SLC,KSLC,SNA,KSNA,STL,KSTL,TPA,KTPA,VPS,KVPS,YYZ,CYYZ]\n```\n\nBy default a sort performed using *order* returns results in ascending\norder. To obtain results in descending order instead, *desc* can be\nspecified using a `by` modulator. Likewise, *asc* can be used to make it\nclear that sorting in ascending order is required.\n\n``` java\n// Sort the first 20 airports returned in descending order\ng.V().hasLabel('airport').limit(20).values('code').order().by(desc).fold()\n\n[PHX,PBI,ORD,MSP,MIA,MCO,LGA,LAX,JFK,IAH,IAD,FLL,DFW,DCA,BWI,BOS,BNA,AUS,ATL,ANC]\n```\n\nYou can also sort things into a random order using *shuffle*. Take a\nlook at the example below and the output it produces.\n\n``` java\ng.V().hasLabel('airport').limit(20).values('code').order().by(shuffle).fold()\n\n[MCO,LGA,BWI,IAD,ATL,BOS,DCA,BNA,IAH,DFW,MIA,MSP,ANC,AUS,JFK,ORD,PBI,FLL,LAX,PHX]\n```\n\nBelow is an example where we combine the field we want to sort by\n*longest* and the direction we want the sort to take, *desc* into a\nsingle *by* instruction.\n\n``` java\n// List the 10 airports with the longest runways in decreasing order.\ng.V().hasLabel('airport').order().by('longest',desc).valueMap().\n      select('code','longest').limit(10)\n```\n\nHere is the output from running the query. To save space I have split\nthe results into two columns.\n\n``` java\n[code:[BPX],longest:[18045]]    [code:[DOH],longest:[15912]]\n[code:[RKZ],longest:[16404]]    [code:[GOQ],longest:[15748]]\n[code:[ULY],longest:[16404]]    [code:[HRE],longest:[15502]]\n[code:[UTN],longest:[16076]]    [code:[FIH],longest:[15420]]\n[code:[DEN],longest:[16000]]    [code:[ZIA],longest:[15092]]\n```\n\nLet's look at another way we could have coded the query we used earlier\nto find the longest runway in the graph. As you may recall, we used the\nfollowing query. While the query does indeed find the longest runway in\nthe graph, if we wanted to know which airport or airports had runways of\nthat length we would have to run a second query to find them.\n\n``` java\ng.V().hasLabel('airport').values('longest').max()\n```\n\nNow that we know how to sort things we could write a slightly more\ncomplex query that sorts all the airports by longest runway in\ndescending order and returns the *valueMap* for the first of those.\nWhile this query could probably be written more efficiently and also\nimproved to handle cases where more than one airport has the longest\nrunway, it provides a nice example of using *order* to find an airport\nthat we are interested in.\n\n``` java\ng.V().hasLabel('airport').order().by(values('longest'),desc).limit(1).valueMap()\n```\n\nIn the case of the *air-routes* graph there is only one airport with the\nlongest runway. The runway at the Chinese city of Bangda is 18,045 feet\nlong. The reason the runway is so long is due to the altitude of the\nairport which is located 14,219 feet above sea level. Aircraft need a\nlot more runway to operate safely at that altitude!\n\n``` java\n[country:[CN], code:[BPX], longest:[18045], city:[Bangda], elev:[14219], icao:[ZUBD], lon:[97.1082992553711], type:[airport], region:[CN-54], runways:[1], lat:[30.5536003112793], desc:[Qamdo Bangda Airport]]\n```",
        "children": [
          {
            "level": "3.14.1",
            "title": "3.14.1. Sorting by key or value {#sortkeyvalue}",
            "content": "Sometimes, when the results of a query are a set of one or more\nkey:value pairs, we need to sort by either the key or the value in\neither ascending or descending order. Gremlin offers us ways that we can\ncontrol the sort in these cases. Examples of how this works are shown\nbelow.\n\n::: note\nIn Tinkerpop 3.3 changes to the syntax were made. The previous keywords\n*valueDecr*, *valueIncr*, *keyDecr* and *keyIncr* are now specified\nusing the form *by(keys,asc)* or *by(values,desc)* etc.\n:::\n\nThe following example shows the difference between running a query with\nand without the use of *order* to sort using the keys of the map created\nby the *group* step.\n\n``` java\n// Query but do not order\ng.V().hasLabel('airport').limit(5).group().by('code').by('runways')\n\n[BNA:[4],ANC:[3],BOS:[6],ATL:[5],AUS:[2]]\n```\n\nNotice also how *local* is used as a parameter to *order*. This is\nrequired so that the ordering is done while the final list is being\nconstructed. If you do not specify *local* then *order* will have no\neffect as it will be applied to the entire result which is treated as a\nsingle entity at that point.\n\n``` java\n// Query and order by airport code (the key)\ng.V().hasLabel('airport').limit(5).\n      group().by('code').by('runways').\n      order(local).by(keys,asc)\n\n[ANC:[3],ATL:[5],AUS:[2],BNA:[4],BOS:[6]]\n```\n\nIn this example we make the numbers of runways the key field and sort on\nit in descending order.\n\n``` java\ng.V().hasLabel('airport').limit(10).\n      group().by('runways').by('code').\n      order(local).by(keys,desc)\n\n[7:[DFW],6:[BOS],5:[ATL],4:[BNA,IAD],3:[ANC,BWI,DCA],2:[AUS,FLL]]\n```",
            "children": []
          },
          {
            "level": "3.14.2",
            "title": "3.14.2. Changes to *order* introduced in TinkerPop release 3.3.4 {#orderchanges}",
            "content": "On October 15th 2018 a change was introduced as part of the Apache\nTinkerPop 3.3.4 release This change deprecated the *incr* and *decr*\nkeywords recognized by the *order* step in favor of the, new at the\ntime, *asc* and *desc* keywords. This book and its accompanying code\nsamples have been updated to only use *asc* and *desc*. If the database\nyou are using supports a version of Apache TinkerPop at the 3.3.4 level\nor higher you should be using the new keywords.\n\n::: note\nThe *Order.incr* and *Order.decr* enumerations were deprecated in the\nTinkerPop 3.3.4 release in favor of *Order.asc* and *Order.desc*. This\nwas done bring the keywords more into line with other commonly used\nquery languages. As of TinkerPop release 3.5.0, those enumerations were\ncompletely removed from the Gremlin reference implementation and\ndocumentation and should no longer be used.\n:::\n\nLet's take a look at how queries are affected by these changes. The\nquery below finds the 10 airports in England with the most outgoing\nroutes and sorts the results in descending order. Prior to TinkerPop\n3.3.4 the query would have been written as follows.\n\n``` java\ng.V().has('airport','region','GB-ENG').\n      order().by(out().count(),decr).limit(10).\n      project('a','b').by('code').by(out().count())\n```\n\nRunning the query produces the following results.\n\n``` java\n[a:LGW,b:200]\n[a:LHR,b:191]\n[a:STN,b:186]\n[a:MAN,b:182]\n[a:BHX,b:109]\n[a:LTN,b:104]\n[a:BRS,b:84]\n[a:EMA,b:64]\n[a:LBA,b:62]\n[a:LPL,b:60]\n```\n\nUsing the new keywords introduced in the 3.3.4 release, the query can be\nwritten as shown below.\n\n``` java\ng.V().has('airport','region','GB-ENG').\n      order().by(out().count(),desc).limit(10).\n      project('a','b').by('code').by(out().count())\n```\n\nThe results produced, as you would expect, are the same as before.\n\n``` java\n[a:LGW,b:200]\n[a:LHR,b:191]\n[a:STN,b:186]\n[a:MAN,b:182]\n[a:BHX,b:109]\n[a:LTN,b:104]\n[a:BRS,b:84]\n[a:EMA,b:64]\n[a:LBA,b:62]\n[a:LPL,b:60]\n```\n\nFor completeness let's take a look at the same query but sorted in\nascending order using both the original *incr* keyword and the newly\nintroduced *asc* keyword. As with *incr*, this remains the default\nbehavior if neither *asc* nor *desc* is specified.\n\n``` java\ng.V().has('airport','region','GB-ENG').\n      order().by(out().count(),incr).limit(10).\n      project('a','b').by('code').by(out().count())\n```\n\nThis time the query has found the airports with the least outgoing\ncommercial aviation routes.\n\n``` java\n[a:CVT,b:0]\n[a:GLO,b:1]\n[a:LEQ,b:1]\n[a:BZZ,b:1]\n[a:MME,b:2]\n[a:ISC,b:3]\n[a:HUY,b:6]\n[a:BLK,b:9]\n[a:NQY,b:11]\n[a:DSA,b:15]\n```\n\nThe query below is modified to use the new *asc* keyword.\n\n``` java\ng.V().has('airport','region','GB-ENG').\n      order().by(out().count(),asc).limit(10).\n      project('a','b').by('code').by(out().count())\n```\n\nThe results produced are the same as before.\n\n``` java\n[a:CVT,b:0]\n[a:GLO,b:1]\n[a:LEQ,b:1]\n[a:BZZ,b:1]\n[a:MME,b:2]\n[a:ISC,b:3]\n[a:HUY,b:6]\n[a:BLK,b:9]\n[a:NQY,b:11]\n[a:DSA,b:15]\n```\n\nWhen TinkerPop 3.3.4 was released, these were not breaking changes. As\nmore graph database engines move up to the TinkerPop 3.5.0 level these\nnow become breaking changes and *asc* and *desc* must be used. In order\nfor your code and other queries to be future proof, even if your\ndatabase is not yet at the TinkerPop 3.5.0 level, I recommend making\nthese changes to your code as soon as possible.",
            "children": []
          }
        ]
      },
      {
        "level": "3.15",
        "title": "3.15. Boolean operations {#bool}",
        "content": "Gremlin provides a set of logical operators such as *and*, *or* and\n*not* that can be used to form Boolean (true/false) type queries. In a\nlot of cases I find that *or* can be avoided by using *within* for\nexample and that *not* can be sometimes avoided by using *without* but\nit is still good to know that these operators exist. The *and* operator\ncan sometimes be avoided by chaining *has* steps together. That said\nthere are always cases where having these boolean steps available is\nextremely useful.\n\n``` java\n// Simple example of doing a Boolean AND operation\ng.V().and(has('code','AUS'),has('icao','KAUS'))\n\n// Simple example of doing a Boolean OR operation\ng.V().or(has('code','AUS'),has('icao','KDFW'))\n```\n\nYou can also use *and* in an infix way as follows so long as you only\nwant to *and* two traversals together.\n\n``` java\ng.V().has('code','AUS').and().has('icao','KAUS')\n```\n\nAs you would probably expect, an *or* step can have more than two\nchoices. This one below has four. Also, note that in practice, for this\nquery, using *within* would be a better approach but this suffices as an\nexample of a bigger *or* expression.\n\n``` java\ng.V().hasLabel('airport').or(has('region','US-TX'),\n                             has('region','US-LA'),\n                             has('region','US-AZ'),\n                             has('region','US-OK')).\n                           order().by('region',asc).\n                           valueMap().select('code','region')\n```\n\nUsing *within* the example above could be written like this so always\nkeep in mind that using *or* may not always be the best approach to use\nfor a given query. We will look more closely at the *within* and\n*without* steps in the following section.\n\n``` java\ng.V().hasLabel('airport').has('region',within('US-TX','US-LA','US-AZ','US-OK')).\n                          order().by('region',asc).\n                          valueMap().select('code','region')\n```\n\nThis next example uses an *and* step to find airports in Texas with a\nrunway at least 12,000 feet long.\n\n``` java\ng.V().hasLabel('airport').and(has('region','US-TX'),has('longest',gte(12000))).values('code')\n```\n\nAs with the *or* step, using *and* is not always necessary. We could\nrewrite the previous query as follows.\n\n``` java\ng.V().has('region','US-TX').has('longest',gte(12000))\n```\n\nGremlin also provides a *not* step which works as you would expect. This\nquery finds vertices that are not airports.\n\n``` java\ng.V().not(hasLabel('airport')).count()\n```\n\nThis previous query could also be written as follows.\n\n``` java\ng.V().has(label,neq('airport')).count()\n```\n\n::: tip\nDepending on the model of your graph and the query itself it may or may\nnot make sense to use the boolean steps. Sometimes, as described above\nchaining *has* steps together may be more efficient or using a step like\n*within* or *without* may make more sense.\n:::\n\nBoolean steps such as *and* can also be dot combined as the example\nbelow shows. This query finds all the airports that have fewer than 100\noutbound routes but more than 94 and returns them grouped by airport\ncode and route count. Notice how in this case the *and* step is added to\nthe *lt* step using a dot rather than having the *and* be the containing\nstep for the whole test. The results from running the query are shown\nbelow as well.\n\n``` java\ng.V().hasLabel('airport').\n      where(out().count().is(lt(100).and(gt(94)))).\n      group().by('code').by(out().count())\n\n[BUD:98,STR:95,NCE:97,AUH:97,WAW:98,CRL:95]\n```\n\nThe query we just looked at could also be written as follows but in this\ncase using the *and* step inline by dot combining it (as above) feels\ncleaner to me. As you can see we get the same result as before.\n\n``` java\ng.V().hasLabel('airport').where(and(out().count().is(lt(100)),\n                out().count().is(gt(94)))).\n                group().by('code').by(out().count())\n\n[BUD:98,STR:95,NCE:97,AUH:97,WAW:98,CRL:95]\n```\n\nAs I have pointed out several times already, there are often many ways\nto write a query that will produce the same result. Here is an example\nof the previous two queries rewritten to use a *between* step instead of\nan *and* step. Remember that *between* is inclusive/exclusive, so we\nhave to specify 101 as the upper bound and 95 as the lower bound.\n\n``` java\ng.V().hasLabel('airport').where(out().count().is(between(95,101))).\n                          group().by('code').by(out().count())\n\n[BUD:98,STR:95,NCE:97,AUH:97,WAW:98,CRL:95]\n```\n\nJust for fun, here is the same query but rewritten to use an *inside*\nstep.\n\n``` java\ng.V().hasLabel('airport').where(out().count().is(inside(94,100))).\n                          group().by('code').by(out().count())\n\n[BUD:98,STR:95,NCE:97,AUH:97,WAW:98,CRL:95]]\n```\n\nAs a side note, if we wanted to reverse the grouping so that the\nairports were grouped by the counts rather than the codes we could do\nthat as follows.\n\n``` java\ng.V().hasLabel('airport').\n      where(out().count().is(lt(100).and(gt(94)))).\n      group().by(out().count()).by('code')\n\n[97:[NCE,AUH],98:[BUD,WAW],95:[STR,CRL]]\n```\n\nYou can also add additional inline *and* steps to a query as shown\nbelow. Notice that this time *AUH* and *NCE* are not part of the result\nset as they have 97 routes which our new *and* test eliminates.\n\n``` java\ng.V().hasLabel('airport').\n      where(out().count().is(lt(100).and(gt(94)).and(neq(97)))).\n      group().by(out().count()).by('code')\n\n[98:[BUD,WAW],95:[STR,CRL]]\n```\n\nThe *where* step was used lot in the examples above. Hopefully the\neffect of using it was clear. Nonetheless I will explain in more detail\nhow the *where* step works in the next section.",
        "children": []
      },
      {
        "level": "3.16",
        "title": "3.16. Using *where* to filter things out of a result {#where}",
        "content": "We have already seen the *where* step used in some of the prior\nexamples. In this section we will take a slightly more focussed look at\nthe *where* step. The *where* step is an example of a *filter*. It takes\nthe current state of a traversal and only allows anything that matches\nthe specified constraint to pass on to any following steps. *Where* can\nbe used by itself, or as we shall see later, in conjunction with a *by*\nmodulator or following a *match* or a *choose* step.\n\n::: tip\nIt is worth noting that some queries that use *where* can also be\nwritten using *has* instead.\n:::\n\nLet's start by looking at a simple example of how *has* and *where* can\nbe used to achieve the same result.\n\n``` java\n// Find airports with more than five runways\ng.V().has('runways',gt(5))\n\n// Find airports with more than five runways\ng.V().where(values('runways').is(gt(5)))\n```\n\nIn examples like the one above, both queries will yield the exact same\nresults but the *has* step feels simpler and cleaner for such cases.\nNotice how in the *where* step version the *gt* predicate has to be\nplaced inside of an *is* step. The next example starts to show the real\npower of the *where* step. We can include a traversal inside of the\n*where* step that does some filtering for us. In this case, we first\nfind all vertices that are airports and then use a *where* step to only\nkeep airports that have more than 60 outgoing routes. Finally we count\nhow many such airports we found.\n\n``` java\n// Airports with more than 60 unique routes from them\ng.V().hasLabel('airport').where(out('route').count().is(gt(60))).count()\n\n179\n```\n\nIn our next example, we want to find routes between airports that have\nan ID of less than 47 but only return routes that are longer than 4,000\nmiles. Again, notice how we are able to look at the incoming vertex ID\nvalues by placing a reference to *inV* at the start of the *where*\nexpression. The *where* step is placed inside of an *and* step so that\nwe can also examine the *dist* property of the edge. Finally we return\nthe path as the result of our query.\n\n``` java\n// Routes longer than 4,000 miles between airports with and ID less than 47\ng.V().hasId(lt(47)).outE().\n      and(where(inV().id().is(lt(47))),values('dist').is(gt(4000))).\n      inV().path().by('code').by('dist')\n```\n\nBelow is what we get back as a result of running the query.\n\n``` java\n[ATL,4502,HNL]\n[JFK,4970,HNL]\n[ORD,4230,HNL]\n[EWR,4950,HNL]\n[HNL,4502,ATL]\n[HNL,4970,JFK]\n[HNL,4230,ORD]\n[HNL,4950,EWR]\n```\n\nSometimes you will be looking for results that match the inverse\ncondition of a *where* step. One way this can be achieved is to wrap the\n*where* step inside of a *not* step, as shown below.\n\n::: note\nThe double underscore prefix *\\\"\\_\\_.\\\"* before the *in* step is\nrequired as *in* is a reserved word in Groovy. If you are using the\nGremlin Console and do not include the prefix you will get an error.\nThis is explained in more detail in the \\\"[A warning about reserved word\nconflicts and collisions](#rword)\\\" section a bit later. The *\\\"\\_\\_.\\\"*\nnotation is actually a reference to a special TinkerPop Java class that\nhas the name *\\\"\\_\\_\\\"* (double underscore) but don't worry about that\nfor the time being. In fact, for now, just think of *\\\"\\_\\_.\\\"* as\nmeaning *\\\"the result of the previous step\\\"*. This will become\nimportant once we start looking at writing a Java program to issue\nGremlin queries and is discussed in the \\\"[The Apache TinkerPop\ninterfaces and classes](#tpinterfaces)\\\" section quite a bit later on.\n:::\n\nThe query starts by finding the Austin airport (AUS) and then finds all\noutgoing routes. We then look at all incoming *contains* edges to see\nwhich country each airport we can fly to is in. The *not* step ensures\nthat only airports that do not have the United States country code of\n*US* are selected.\n\n``` java\ng.V().has('airport','code','AUS').\n      out().not(where(__.in('contains').has('code','US'))).\n      valueMap('code','city')\n```\n\nAs you can see, when we run the query, only destinations outside the\nUnited States are returned.\n\n``` java\n[code:[YYZ],city:[Toronto]]\n[code:[LHR],city:[London]]\n[code:[FRA],city:[Frankfurt]]\n[code:[MEX],city:[Mexico City]]\n[code:[CUN],city:[Cancun]]\n[code:[GDL],city:[Guadalajara]]\n```\n\nThis pattern comes in useful whenever you want to use a traversal inside\nof a *where* step and negate the results. Of course, there are other\nways we could write this particular query but I wanted to show an\nexample of this technique being used. For completeness, two simpler ways\nof writing this query that do not use *where* at all are shown below but\nthere will be cases where combining *not* and *where* are your best\noption.\n\n``` java\ng.V().has('airport','code','AUS').\n      out().has('country', neq('US')).valueMap('code','city')\n\ng.V().has('airport','code','AUS').\n      out().not(has('country', 'US')).valueMap('code','city')\n```\n\nIt is also possible to use some special forms of the *and* and *or*\nsteps when working with a *where* step. Take a look at the query below.\nThis will match airports that you can fly to from Austin (AUS) so long\nas they have more than four runways and do not have exactly six runways.\n\n``` java\ng.V().has('airport','code','AUS').out().\n      where(values('runways').is(gt(4).and(neq(6)))).\n      valueMap('code','runways')\n```\n\nHere is what the query returns. As you can see we only found airports\nthat you can fly to from AUS that have 5,7 or 8 runways.\n\n``` java\n[code:[YYZ],runways:[5]]\n[code:[MDW],runways:[5]]\n[code:[ATL],runways:[5]]\n[code:[DFW],runways:[7]]\n[code:[IAH],runways:[5]]\n[code:[ORD],runways:[8]]\n```\n\nThe same is true for the *or* step. We could rewrite our query to find\nairports we can fly to from Austin that have more than six or exactly\nfour runways.\n\n``` java\ng.V().has('airport','code','AUS').out().\n      where(values('runways').is(gt(6).or(eq(4)))).\n      valueMap('code','runways')\n```\n\nThe above is a shorter form of the following query which demonstrates\nanother way we could use the boolean operators within a *where* step. In\nthis case only two traversals are allowed to be compared using the\nboolean operator (in this case an *or* step).\n\n``` java\ng.V().has('airport','code','AUS').out().\n      where(values('runways').is(gt(6)).or().values('runways').is(4)).\n      valueMap('code','runways')\n```\n\nOur last example in this section uses a *where* step to make sure we\ndon't end up back where we started when looking at airline routes with\none stop. We find routes that start in Austin, with one intermediate\nstop, that then continue to another airport, but never end up back in\nAustin. A *limit* step is used to just return the first 10 results that\nmatch this criteria. Notice how the *as* step is used to label the *AUS*\nairport so that we can refer to it later in our *where* step. The effect\nof this query is that routes such as AUS→DFW→AUS will not be returned\nbut AUS→DFW→LHR will be as it does not end up back in Austin.\n\n``` java\n// List 10 places you can fly to with one stop, starting at Austin but\n// never ending up back in Austin\n\ng.V().has('airport','code','AUS').as('a').\n      out().out().where(neq('a')).\n      path().by('code').limit(10)\n```\n\nAs you work with Gremlin, you will find that the *where* step is one\nthat you use a lot. You will see many more examples of *where* being\nused throughout the remainder of this book. In the next section we will\nlook at some additional ways that *where* can be used.",
        "children": [
          {
            "level": "3.16.1",
            "title": "3.16.1. Using *where* and *by* to filter results {#whereby}",
            "content": "A new capability was added in the Tinkerpop 3.2.4 release that allows a\n*where* step to be followed with a *by* modulator. This makes writing\ncertain types of queries a lot easier than it was before. Hopefully by\nnow, this capability is supported in many TinkerPop enabled graph stores\nbut it is always a good idea to verify the version of TinkerPop\nsupported before starting to design queries.\n\nThe query below starts at the Austin airport and finds all the airports\nthat you can fly to from there. A *where* *by* step is then used to\nfilter the results to just those airports that have the same number of\nrunways that Austin has. What is really nice about this is that we do\nnot have to know ahead of time how many runways Austin itself has as\nthat is handled for us by the query.\n\n``` java\n g.V().has('code','AUS').as('a').out().\n       where(eq('a')).by('runways').valueMap('code','runways')\n```\n\n::: tip\nCombining the *where* and *by* steps allows you to write powerful\nqueries in a nice and simple way.\n:::\n\nIf you were to run the query in the Gremlin Console, these are the\nresults that you should see. Note that all the airports returned have\ntwo runways. This is the same number of runways that the Austin airport\nhas.\n\n``` java\n[code:[LHR],runways:[2]]\n[code:[MEX],runways:[2]]\n[code:[CUN],runways:[2]]\n[code:[GDL],runways:[2]]\n[code:[PNS],runways:[2]]\n[code:[VPS],runways:[2]]\n[code:[FLL],runways:[2]]\n[code:[SNA],runways:[2]]\n[code:[MSY],runways:[2]]\n```\n\nThe ability to combine *where* and *by* steps together allows us to\navoid having to write the previous query in more complicated ways such\nas the one shown below.\n\n``` java\ng.V().has('code','AUS').as('a').out().as('b').\n      filter(select('a','b').by('runways').where('a',eq('b'))).\n      valueMap('code','runways')\n```\n\nThere is also a two parameter form of the *where* step that you may have\nnoticed used above. In this case the first parameter refers to a label\ndefined earlier in the query. Take a look at the example below. We find\nthe vertex for the Austin (AUS) airport and label it *\\'a\\'*. We then\nlook at all the airports you can fly to from there and label them\n*\\'b\\'*. We then use a *where* step to compare *\\'a\\'* and *\\'b\\'*. Only\nairports with fewer runways than Austin should be returned.\n\n``` java\ng.V().has('airport','code','AUS').as('a').out().as('b').\n      where('a',gt('b')).by('runways').valueMap('code','runways')\n```\n\nAustin has two runways so only airports with one runway are returned by\nthis query when run.\n\n``` java\n[code:[BKG],runways:[1]]\n[code:[SAN],runways:[1]]\n```\n\nIt is also possible to compare two different properties by adding a\nsecond *by* modulator. This is useful when vertex properties have\ndifferent key names but may contain the same values. The query below is\ndefinitely contrived, you could achieve the same thing in a more simple\nway, but it does demonstrate two *by* modulators being used. The\n*country* property of an airport vertex is compared with the *code*\nproperty of a *country* vertex. The query first finds any airport vertex\nwith a *city* property containing the string *London*. Next any\nconnecting *country* vertices (ones connected by contains edges) are\nfound. The *where* test compares the country code value of the two\nvertices. Lastly a *select* is used to pick the results that we want to\nreturn.\n\n``` java\ng.V().has('airport','city','London').as('a','r').\n      in('contains').as('b').\n      where('a',eq('b')).by('country').by('code').\n      select('a','r','b').by('code').by('region')\n```\n\nWhen the query is run we get back all the airports with a city name of\n*London* along with their region code and country code.\n\n``` java\n[a:LHR,r:GB-ENG,b:UK]\n[a:LGW,r:GB-ENG,b:UK]\n[a:LCY,r:GB-ENG,b:UK]\n[a:STN,r:GB-ENG,b:UK]\n[a:LTN,r:GB-ENG,b:UK]\n[a:YXU,r:CA-ON,b:CA]\n```\n\nAs I mentioned the above query was used just as an example. In reality\nthe following query that does not use any *where* steps would have\nsufficed in this case.\n\n``` java\ng.V().has('airport','city','London').\n      valueMap('code','region','country')\n\n[country:[UK],code:[LHR],region:[GB-ENG]]\n[country:[UK],code:[LGW],region:[GB-ENG]]\n[country:[UK],code:[LCY],region:[GB-ENG]]\n[country:[UK],code:[STN],region:[GB-ENG]]\n[country:[UK],code:[LTN],region:[GB-ENG]]\n[country:[CA],code:[YXU],region:[CA-ON]]\n```\n\nLet's imagine that we want to write a query to find all airports that\nhave the same region code as the French airport of Nice. Let's assume\nfor now that we do not know what the region code is so we cannot just\nwrite a simple query to find all airports in that region. So, instead we\nneed to write a query that will first find the region code for Nice and\nthen use that region code to find any other airports in the region.\nFinally we want to return the airport code along with the city name and\nthe region code. One way of writing this query is to take advantage of\nthe *where...​by* construct.\n\nTake a look at the query below and the output it generates.\n\n``` java\ng.V().has('code','NCE').values('region').as('r').\n  V().hasLabel('airport').as('a').values('region').\n      where(eq('r')).by().\n      local(select('a').values('city','code','region').fold())\n\n[NCE,Nice,FR-U]\n[MRS,Marseille,FR-U]\n[TLN,Toulon/Le Palyvestre,FR-U]\n[AVN,Avignon/Caumont,FR-U]\n```\n\n::: tip\nIn the sample programs folder you will find a program called\nGraphRegion.java that shows how to perform the query shown above in a\nJava program.\n:::\n\nThere are several things about this query that are interesting. Firstly\nbecause we are comparing the results of two *values* steps we do not\nprovide a parameter to the *by* step as we do not need to provide a\nproperty key. Secondly, we use a second *V()* step in the query to find\nall the airports that have the same airport code as Nice. Note that this\nalso means that Nice is included in the results. Lastly we wrap the part\nof the query that prepares the output in a form we want in a *local*\nstep so that a separate list is created for each airport.\n\nYou could write this query other ways, perhaps using a *match* step but\nonce you understand the pattern used above it is both fairly simple and\nquite powerful.",
            "children": []
          }
        ]
      },
      {
        "level": "3.17",
        "title": "3.17. Using *choose* to write if...​then...​else type queries {#choose}",
        "content": "The *choose* step allows the creation of queries that are a lot like the\n\\\"if then else\\\" constructs found in most programming languages. If we\nwere programming in Java we might find ourselves writing something like\nthe following.\n\n``` java\nif (longest > 12000)\n{\n  return(code);\n}\nelse\n{\n  return(desc);\n}\n```\n\nGremlin offers us a way to do the same thing. The query below finds all\nthe airports in Texas and then will return the value of the *code*\nproperty if an airport has a runway longer than 12,000 feet otherwise it\nwill return the value of the *desc*.\n\n``` java\n// If an airport has a runway > 12,000 feet return its code else return its description\ng.V().has('region','US-TX').\n      choose(values('longest').is(gt(12000)),\n             values('code'),\n             values('desc')).\n      limit(5)\n```\n\nWhen run the output returned should look like this.\n\n``` java\nAUS\nDFW\nIAH\nSan Antonio\nHouston Hobby\n```\n\nIf the \\\"else\\\" part of the *choose* step is not provided then it\nbehaves as a simple \\\"if\\\".\n\n``` java\ng.V().has('region','US-TX').\n      choose(values('longest').is(gt(12000)),\n             values('code')).\n             limit(5)\n```\n\nThe \\\"else\\\" in this case is implied and the incoming element that the\n*choose* step received is passed on as shown below.\n\n``` java\nAUS\nDFW\nIAH\nv[33]\nv[38]\n```\n\nHere is another example that uses the same constructs.\n\n``` java\n// If an airport has a code of AUS or DFW report its region else report its country\ng.V().hasLabel('airport').\n      choose(values('code').is(within('AUS','DFW')),\n             values('city'),\n             values('region')).\n     limit(5)\n```",
        "children": [
          {
            "level": "3.17.1",
            "title": "3.17.1. Including a constant value - introducing *constant* {#chooseconstant}",
            "content": "Sometimes it is very useful, as the example below demonstrates, to\nreturn constant rather than derived values as part of a query. This\nquery will return the string \\\"some\\\" if an airport has fewer than four\nrunways or \\\"lots\\\" if it has more than four.\n\n``` java\n// You can also return constants using the constant() step\ng.V().hasLabel('airport').limit(10).\n      choose(values('runways').is(lt(4)),\n             constant('some'),\n             constant('lots'))\n```\n\n::: tip\nThe *constant* step can be used to return a constant value as part of a\nquery.\n:::\n\nHere is one more example that uses a *sample* step to pick 10 airports\nand then return either \\\"lots\\\" or \\\"not so many\\\" depending on whether\nthe airport has more than 50 routes or not. Note also how *as* and\n*select* are used to combine both the derived and constant parts of the\nquery result that we will ultimately return.\n\n``` java\ng.V().hasLabel('airport').sample(10).as('a').\n      choose(out('route').count().is(gt(50)),\n             constant('lots'),\n             constant('not so many')).as('b').\n      select('a','b').by('code').by()\n```\n\nHere is an example of what the output from running this query might look\nlike.\n\n``` java\n[a:YYT,b:not so many]\n[a:YEG,b:not so many]\n[a:LGA,b:lots]\n[a:DXB,b:lots]\n[a:BLR,b:not so many]\n[a:CGN,b:lots]\n[a:BOM,b:lots]\n[a:SIN,b:lots]\n[a:TSF,b:not so many]\n[a:HKG,b:lots]\n```\n\nWe could go one step further if you don't want the *a:* and *b:* keys\nreturned as part of the result by adding a *select(values)* to the end\nof the query as follows.\n\n``` java\ng.V().hasLabel('airport').sample(10).as('a').\n      choose(out('route').count().is(gt(50)),\n             constant('lots'),\n             constant('not so many')).as('b').\n      select('a','b').by('code').by().select(values)\n```\n\nHere is what the output from the modified form of the query.\n\n``` java\n[YYT,not so many]\n[YEG,not so many]\n[LGA,lots]\n[DXB,lots]\n[BLR,not so many]\n[CGN,lots]\n[BOM,lots]\n[SIN,lots]\n[TSF,not so many]\n[HKG,lots]\n```\n\nThe *constant* step is not limited to use within *choose* steps. It can\nbe used wherever needed. You will find many examples of its use\nthroughout this book including in the \\\"[Using to combine query\nresults](#union)\\\" section.",
            "children": []
          }
        ]
      },
      {
        "level": "3.18",
        "title": "3.18. Using *option* to write case/switch type queries {#option}",
        "content": "When *option* is combined with *choose* the result is similar to the\n*case* or *switch* style construct found in most programming languages.\nIn Java for example, we might code a *switch* statement as follows.\n\n``` java\n  switch(airport)\n  {\n    case \"DFW\": System.out.println(desc); break;\n    case \"AUS\": System.out.println(region); break;\n    case \"LAX\": System.out.println(runways);\n  }\n```\n\nWe can write a Gremlin query that follows the same pattern as our Java\n*switch* statement. As in the Java example I decided to lay our query\nout across multiple lines to aid readability and clarity.\n\n``` java\n// You can combine choose and option to generate a more \"case statement\" like query\ng.V().hasLabel('airport').\n      choose(values('code')).\n        option('DFW',values('desc')).\n        option('AUS',values('region')).\n        option('LAX',values('runways'))\n```\n\nThe example below shows a *choose* followed by four options. Note the\ndefault case of *none* is used as the catchall. Notice how in this case,\nthe values returned are constants.\n\n``` java\n// You can return constant values if you need to\ng.V().hasLabel('airport').limit(10).\n      choose(values('runways')).\n        option(1,constant('just one')).\n        option(2,constant('a couple')).\n        option(7,constant('lots')).\n        option(none,constant('quite a few'))\n```\n\nStarting with the 3.4.3 release of Apache TinkerPop, the *option* step\ncan now include a predicate. A nice improvement allowing additional\ncomparisons to be made within the *option* step. This allows testing\nthat a value is greater than or less than another, for example, as part\nof the *option* step without needing to write a more complex query.\n\n::: note\nIn the TinkerPop 3.4.3 release, a feature was added allowing the\n*option* step to include a predicate.\n:::\n\nUsing this new capability, a query can be written using a more simple\nsyntax. The query below creates a group containing the counts of\nairports that fall into one of the categories generated by the *choose*\nand *option* steps. Any airport situated above 5,000 feet of elevation\nwill be categorized as \\\"high\\\", greater than 3,000 feet as \\\"medium\\\"\nand all others as \\\"low\\\".\n\n``` java\ng.V().hasLabel('airport').\n      groupCount().\n        by(choose(values('elev')).\n             option(gt(5000),constant('high')).\n             option(gt(3000),constant('medium')).\n             option(none,constant('low')))\n\n[high:157,low:3013,medium:204]\n```\n\nIn TinkerPop releases prior to 3.4.3, the query could still have been\nwritten but it required the use of nested *choose* steps.\n\n``` java\ng.V().hasLabel('airport').\n      groupCount().\n        by(choose(values('elev').is(gt(5000)),\n             constant('high'),\n             choose(values('elev').is(gt(3000)),\n               constant('medium'),\n               constant('low'))))\n\n[high:157,low:3013,medium:204]\n```",
        "children": []
      },
      {
        "level": "3.19",
        "title": "3.19. Using *match* to do pattern matching {#patmatch}",
        "content": "The *match* step was added in TinkerPop 3 and allows a more declarative\nstyle of pattern based query to be expressed using Gremlin. *Match* can\nbe a bit hard to master but once you figure it out it can be a very\npowerful way of traversing a graph looking for specific patterns. As we\nshall see however, sometimes a `where` step is more than adequate and\ncan be used to express similar patterns to those supported by *match*.\n\nBelow is an example that uses *match* to look for airline route patterns\nwhere there is a flight from one airport to another but no return flight\nback to the original airport. The first query looks for such patterns\ninvolving the JFK airport as the starting point. You can see the output\nfrom running the query below it. This is the correct answer as,\ncurrently, the British Airways Airbus A318 flight from London City (LCY)\nairport stops in Dublin (DUB) to take on more fuel on the way to JFK but\ndoes not need to stop on the way back because of the trailing wind.\n\n``` java\n// Find any cases of where you can fly from JFK non stop\n// to a place you cannot get back from non stop. This query\n// should return LCY, as the return flight stops in Dublin\n// to refuel.\n\ng.V().has('code','JFK').\n      match(__.as('s').out().as('d'),\n            __.not(__.as('d').out().as('s'))).\n      select('s','d').by('code')\n\n[s:JFK,d:LCY]\n```\n\nWe can expand the query by leaving off the specific starting point of\nJFK and look for this pattern anywhere in the graph. This really starts\nto show how important and useful the *match* Gremlin step is. We don't\nhave any idea what we might find, but by using *match*, we are able to\ndescribe the pattern of behavior that we are looking for and Gremlin\ndoes the rest.\n\n``` java\n// Same as above but from any airport in the graph.\ng.V().hasLabel('airport').\n      match(__.as('s').out().as('d'),\n            __.not(__.as('d').out().as('s'))).\n      select('s','d').by('code')\n```\n\nIf you were to run the query you would find that there are in fact over\n200 places in the graph where this situation applies. We can add a\n*count* to the end of query to find out just how many there are.\n\n``` java\n// How many occurrences of the pattern in the graph are there?\ng.V().hasLabel('airport').\n      match(__.as('s').out().as('d'),\n            __.not(__.as('d').out().as('s'))).\n      count()\n\n238\n```\n\nThe next query looks for routes that follow the pattern A→B→C but where\nthere is no direct flight of the form A→C. In other words it looks for\nall routes between two airports with one intermediate stop where there\nis no direct flight alternative available. Note that the query also\neliminates any routes that would end up back at the airport of origin.\nTo achieve the requirement that we not end up back where we started, a\n*where* step is included to make sure we do not match any routes of the\nform A→B→A.\n\n``` java\ng.V().hasLabel('airport').\n      match(__.as('a').out().as('b')\n           ,__.as('b').out().where(neq('a')).as('c')\n           ,__.not(__.as('a').out().as('c'))).\n      select('a','b','c').by('code').limit(10)\n```\n\nThere are, of course a lot of places in the *air-routes* graph where\nthis pattern can be found. Here are just a few examples of the results\nyou might get from running the query.\n\n``` java\n[a:ATL,b:MLB,c:ISP]\n[a:ATL,b:MLB,c:BIM]\n[a:ATL,b:MLB,c:YTZ]\n[a:ATL,b:PHF,c:SFB]\n[a:ATL,b:SBN,c:SFB]\n[a:ATL,b:SBN,c:AZA]\n[a:ATL,b:SBN,c:PIE]\n[a:ATL,b:SBN,c:PGD]\n[a:ATL,b:TRI,c:SFB]\n[a:ATL,b:TRI,c:PIE]\n```\n\nHere is another example of using *match* along with a *where*. This is\nactually a different way of writing a query we saw earlier. This query\nstarts out by looking at how many runways Austin has and then looks at\nevery airport that you can fly to from Austin and then looks at how many\nrunways those airports have. Only airports with the same number as\nAustin are returned. Using a *match* step for this task is overkill.\nHowever, it does show the basic constructs used by the *match* step and\nagain illustrates using values calculated in one part of a query later\non in that same query.\n\n``` java\ng.V().has('code','AUS').\n      match(__.as('aus').values('runways').as('ausr'),\n            __.as('aus').out('route').as('outa').values('runways').as('outr')\n              .where('ausr',eq('outr'))).\n      select('outa').valueMap().select('code','runways')\n```\n\nAs I mentioned, the example above is not the best way to write this\nquery and it can be done without using a *match* step at all and just\nusing a *where* step as shown in the three examples below. Each one is\nsimpler than its predecessor.\n\nOne way we could choose to write this query is using multiple select\nsteps. This is also not a very efficient solution but does work.\n\n``` java\ng.V().has('code','AUS').as('aus').values('runways').as('ausr').\n      select('aus').out().as('outa').values('runways').as('outr').\n      where('ausr',eq('outr')).\n      select('outa').valueMap().select('code','runways')\n```\n\nA better way than either of the prior two combines a *filter* step with\nthe *where* and *select* steps.\n\n``` java\ng.V().has('code','AUS').as('a').out().as('b').\n      filter(select('a','b').by('runways').where('a',eq('b'))).\n      valueMap('code','runways')\n```\n\nAs mentioned in the \\\"[Using and to filter results](#whereby)\\\" section,\nthis query can be simplified further using a *where* step and a *by*\nmodulator. This capability was introduced in the TinkerPop 3.2.4\nrelease.\n\n``` java\ng.V().has('code','AUS').as('a').out().\n       where(eq('a')).by('runways').\n       valueMap('code','runways')\n```\n\nSo, while there is often a simpler way to write a query that avoids\nusing the *match* step, for some queries, especially in more complex\ncases, it provides a useful and powerful way to express in a more\ndeclarative way, a set of criteria that must be met. However, before I\nresort to using a *match* step I always think carefully about other ways\nthat I could write the query that might be simpler. I do this because\nthe syntax of the *match* step can be tricky to get right without a fair\nbit of trial and error in my experience.",
        "children": [
          {
            "level": "3.19.1",
            "title": "3.19.1. Pattern matching using a *where* step {#patternwhere}",
            "content": "As the Gremlin language has evolved, many queries that might seem a\nperfect candidate for a *match* step can actually also be written using\na *where* step but still in a more declarative style. We can rewrite the\nquery from the previous section that looks at routes from JFK that do\nnot have a return flight using a *where* step as shown below.\n\nThe way to read this, in a similar way as with a *match* step is as\nfollows. Starting at JFK, look at all the places we can fly to but only\nkeep those airports that do not have a route back to JFK. Note that the\n*as* step plays two roles in this query. Outside of the *where* step it\nis used to label steps in the query we want to refer back to later.\nInside the *where* step it provides a convenient shorthand way to refer\nback to the departure airport.\n\n``` java\ng.V().has('code','JFK').as('s').\n      out().as('d').\n      where(__.not(out().as('s'))).\n      select('s','d').by('code')\n\n[s:JFK,d:LCY]\n```\n\nAs we have seen in some prior examples, if you only want the airport\ncodes in the result and not the \\\"s\\\" and \\\"d\\\" keys, adding an\nadditional *select* step is all that it takes.\n\n``` java\ng.V().has('code','JFK').as('s').\n      out().as('d').\n      where(__.not(out().as('s'))).\n      select('s','d').by('code').\n      select(values)\n\n[JFK,LCY]\n```\n\nThe query can be expanded to search for this same pattern across the\nwhole graph. The example below returns the first ten routes found where\nthere is no return flight. The results are sorted in ascending order\nusing the departure airport code.\n\n``` java\ng.V().hasLabel('airport').as('s').\n      out().as('d').\n      where(__.not(out().as('s'))).\n      limit(10).\n      select('s','d').by('code').\n      order().by(select('s'))\n```\n\nWhen run the query returns the following results.\n\n``` java\n[s:AMS,d:HRE]\n[s:AMS,d:FNA]\n[s:AMS,d:UIO]\n[s:BNE,d:BCI]\n[s:BNE,d:BKQ]\n[s:BOM,d:DIU]\n[s:HEL,d:IVL]\n[s:HPN,d:HYA]\n[s:JFK,d:LCY]\n[s:MAN,d:ANU]\n```",
            "children": []
          }
        ]
      },
      {
        "level": "3.20",
        "title": "3.20. Using *union* to combine query results {#union}",
        "content": "The *union* step works just as you would expect from its name. It allows\nus to combine parts of a query into a single result. Just as with the\nboolean *and* and *or* steps it is sometimes possible to find other ways\nto do the same thing without using *union* but it does offer some very\nuseful capability.\n\nHere is a simple example that uses a *union* step to produce a list\ncontaining a vertex and the number of outgoing routes from that vertex.\nNote that in the next section we will see that there are simpler ways to\nwrite this query while still using a *union* step. The main point to\ntake away from this example is that you can use a *union* step to\ncombine the results of multiple traversals. This example combines the\nresults of two traversals but you can certainly combine more as needed.\nNote that the *out* step starts from the vertex that was found\nimmediately before the *union* step which in this case is the DFW\nvertex. So in other words the output from the prior step is available to\nthe steps within the *union* step just as with other Gremlin steps we\nhave already looked at.\n\n``` java\ng.V().has('airport','code','DFW').as('a').\n      union(select('a'),out().count()).fold()\n\n[v[8],221]\n```\n\nNot that this is recommended, but the previous query could also be\nwritten as follows using two *has* steps both inside a single *union*\nstep. This does however demonstrate that you can use a *union* step to\ncombine the results of fairly arbitrary graph traversals.\n\n``` java\ng.V().union(has('airport','code','DFW'),\n            has('airport','code','DFW').\n               out().count()).fold()\n\n[v[8],221]\n```\n\nAs a side note, instead of using a *union* step and producing a list, we\nmight decide to use a *group* step and produce a map. A map might be\npreferable if you want to access individual keys and values directly. It\nall depends, as always, on the results that best fit the problem you are\nsolving.\n\n``` java\ng.V().has('airport','code','DFW').\n      group().by().by(out().count())\n\n[v[8]:221]]\n```",
        "children": [
          {
            "level": "3.20.1",
            "title": "3.20.1. Introducing the *identity* step {#unionidentity}",
            "content": "Gremlin has an *identity* step that we have not seen used so far in this\nbook. The *identity* step simply returns the entity that was passed in\nto the current step of a traversal (in this case *union*) from the prior\nstep. We can rewrite the query we used above to use an *identity* step.\nThis simplifies the query as it removes the need to use the *as* and\n*select* steps. As shown below, using *identity* causes the vertex\n*V\\[8\\]* representing the DFW airport from the prior *has* step to be\nincluded in the result.\n\n``` java\ng.V().has('airport','code','DFW').\n      union(identity(),out().count()).fold()\n\n[v[8],221]\n```\n\nWe could modify the query slightly to have the first part of the result\nreturned be the airport's IATA code rather than just a vertex.\n\n``` java\ng.V().has('airport','code','DFW').\n      union(identity().values('code'),out().count()).fold()\n\n[DFW,221]\n```",
            "children": []
          },
          {
            "level": "3.20.2",
            "title": "3.20.2. Using *constant* values as part of a *union* {#unionconstant}",
            "content": "We have already seen the *constant* step used in the \\\"[Including a\nconstant value - introducing ](#chooseconstant)\\\" section. As you might\nexpect, you can also use *constant* steps within a *union* step as the\ntwo examples below show.\n\n``` java\ng.V(3).union(constant(\"Hello\"),\n             constant(\"There\")).fold()\n\n[Hello,There]\n```\n\nThe *identity* step that was just introduced above could be used to add\nthe *V\\[3\\]* vertex to the result. We are now combining three traversal\nsteps together inside of the *union* step.\n\n``` java\ng.V(3).union(constant(\"Hello\"),\n             constant(\"There\"),\n             identity()).fold()\n\n[Hello,There,v[3]]\n```\n\nFinally, let's change the query again to include a city name in the\nresult. Note that the *values* step refers to the property of the vertex\nthat was referenced immediately before the *union* step so it will\nreturn the *city* property of vertex *V\\[3\\]*.\n\n``` java\ng.V(3).union(constant(\"Hello\"),\n             constant(\"There\"),\n             values('city')).fold()\n\n[Hello,There,Austin]\n```",
            "children": []
          },
          {
            "level": "3.20.3",
            "title": "3.20.3. More examples of the *union* step {#unionmore}",
            "content": "The following query uses a *sample* step to select 10 airports at random\nfrom the graph. For each selected airport, a *union* step is then used\nto combine the *id* of the vertex with a few properties. Note that\n*local* scope is used so that the results of each *union* step are\nfolded into a list.\n\n``` java\ng.V().hasLabel(\"airport\").sample(10).\n      local(union(id(),values(\"code\",\"city\")).fold())\n```\n\nHere is the output I got back from running the query.\n\n``` java\n[83,RSW,Fort Myers]\n[97,GLA,Glasgow]\n[26,SAN,San Diego]\n[57,MEL,Melbourne]\n[136,MEX,Mexico City]\n[163,YHZ,Halifax]\n[44,SAF,Santa Fe]\n[42,OAK,Oakland]\n[92,OSL,Oslo]\n[161,IST,Istanbul]\n```\n\nIf *local* scope had not been used, the result would have been a single\nlist containing all of the results as shown below.\n\n``` java\ng.V().hasLabel(\"airport\").sample(10).\n      union(id(),values(\"code\",\"city\")).fold()\n\n[84,MAN,Manchester,87,CGN,Cologne,35,EWR,Newark,37,HNL,Honolulu,54,NRT,Tokyo,86,YEG,Edmonton,45,PHL,Philadelphia,52,FRA,Frankfurt,85,YUL,Montreal,142,SOF,Sofia]\n```\n\nBy way of another simple example, the following query returns flights\nthat arrive in AUS from the UK or that leave AUS and arrive in Mexico.\n\n``` java\n// Flights to AUS from the UK or from AUS to Mexico\ng.V().has('code','AUS').\n      union(__.in().has('country','UK'),\n            out().has('country','MX')).\n            path().by('code')\n```\n\nWhen we run that query, we get the following results showing that there\nare routes from LHR in the UK and to the three airports MEX, CUN and GDL\nin Mexico.\n\n``` java\n[AUS,LHR]\n[AUS,MEX]\n[AUS,CUN]\n[AUS,GDL]\n```\n\nThis query solves the problem \\\"Find all routes that start in London,\nEngland and end up in Paris or Berlin with no stops\\\". Because city\nnames are used and not airport codes, all airports in the respective\ncities are considered.\n\n``` java\ng.V().has('city','London').has('region','GB-ENG').\n         union(out('route').has('city','Paris'),\n               out('route').has('city','Berlin')).\n               path().by('code')\n```\n\nHere are the results from running the query. Note that routes from five\ndifferent London airports were found.\n\n``` java\n[LHR,CDG]\n[LHR,ORY]\n[LHR,TXL]\n[LGW,CDG]\n[LGW,SXF]\n[LCY,CDG]\n[LCY,ORY]\n[STN,TXL]\n[STN,SXF]\n[LTN,CDG]\n[LTN,SXF]\n```\n\nAs mentioned previously, sometimes, especially for fairly simple\nqueries, there are alternatives to using *union*. Indeed, it is actually\nnot necessary to use a *union* step to achieve the prior result. The\nre-written version of the query below will return the same results as\nthe version that uses a *union* step. This time a simple *has* step\nfeaturing a *within* predicate is used instead.\n\n``` java\ng.V().has('city','London').has('region','GB-ENG').\n      out('route').has('city',within('Berlin','Paris')).\n      path().by('code')\n```\n\nThe previous two queries used a *path* step to essentially show each\nindividual route. We can adjust the version of the query that uses a\n*union* step just a little bit and instead turn the result into a series\nof lists where the first item in the list is the origin airport and the\nremaining items in the list are the places you can fly to from there\nwithin our criteria. The double underscore *\\\"\\_\\_\\\"* is used in the way\nthat *identity* could have been used to refer to the incoming vertex.\nThe *union* step is wrapped in a *local* step so that each *union* is\nindividually folded. If the *local* step was omitted all of the results\nwould be folded into a single list. In this case, the *union* step makes\nwriting the query relatively easy and this is probably a good example of\nwhere the *union* step should be used. Namely, when you want to combine\nmultiple traversal results.\n\n``` java\ng.V().has('city','London').has('region','GB-ENG').\n      local(union(__.values('code'),\n                  out('route').has('city','Paris').values('code'),\n                  out('route').has('city','Berlin').values('code')).\n      fold())\n```\n\nRunning the amended query shows us the results in perhaps a more useful\nform.\n\n``` java\n[LHR,ORY,CDG,TXL]\n[LGW,CDG,SXF]\n[LCY,ORY,CDG]\n[STN,TXL,SXF]\n[LTN,CDG,SXF]\n```",
            "children": []
          },
          {
            "level": "3.20.4",
            "title": "3.20.4. Using *union* to combine more complex traversal results {#unionthree}",
            "content": "So far the examples we have looked at mostly show fairly simple\ntraversals being used inside of a *union* step. This next query is a bit\nmore interesting. We again start from any airport in London, but then we\nwant routes that meet any of the criteria:\n\n-   Go to Berlin and then to Lisbon\n\n-   Go to Paris and then Barcelona\n\n-   Go to Edinburgh and then Rome\n\nWe also want to return the distances in each case. Note that you can\nunion together as many items as you need to. In this example we combine\nthe results of three sets of traversals to get the desired results.\n\n``` java\n// Returns any paths found along with the distances between airport pairs.\n\ng.V().has('city','London').has('region','GB-ENG').\n      union(outE().inV().has('city','Berlin').\n                   outE('route').inV().has('city','Lisbon').\n                   path().by('code').by('dist').by('code').by('dist'),\n            outE().inV().has('city','Paris').\n                   outE('route').inV().has('city','Barcelona').\n                   path().by('code').by('dist').by('code').by('dist'),\n            outE().inV().has('city','Edinburgh').\n                   outE('route').inV().has('city','Rome').\n                   path().by('code').by('dist').by('code').by('dist'))\n```\n\nHere is what we get back when we run our query\n\n``` java\n[LHR,227,ORY,513,BCN]\n[LHR,216,CDG,533,BCN]\n[LGW,591,SXF,1432,LIS]\n[LGW,191,CDG,533,BCN]\n[LCY,227,ORY,513,BCN]\n[STN,563,SXF,1432,LIS]\n[LTN,589,SXF,1432,LIS]\n[LTN,236,CDG,533,BCN]\n```\n\nThe next query finds the total distance of all routes from any airport\nin Madrid to any airport anywhere and also does the same calculation but\nminus any routes that end up in any Paris airport. We have not yet seen\nthe *filter* step that is used below. It is one of the foundational\nGremlin steps that many others such as *where* build upon. A *filter*\nstep will only pass on to the next step in the query incoming elements\nthat meet the criteria specified within the *filter*.\n\n``` java\ng.V().has('city','Madrid').outE('route').\n      union(values('dist').sum(),\n            filter(inV().has('city',neq('Paris'))).values('dist').sum())\n```\n\nHere is the output from running the query. As you can see the first\nnumber is slightly larger than the second as all routes involving Paris\nhave been filtered out from the calculation.\n\n``` java\n397708\n396410\n```\n\nIt is worth noting that it is not required that every traversal inside\nof a union step returns a result. The returned results will include any\nof the traversals that did return something. The example below\ndemonstrates this. Of course in practice you would not write this\nparticular query this way. However, I think this example demonstrates a\nfeature of the *union* step that it is important to understand.\n\n``` java\ng.V().has('airport','code','AUS').\n      union(out().has('code','LHR'),\n            out().has('code','SYD'),\n            out().has('code','DFW')).\n      values('code')\n```\n\nIf we run the query, you will see that SYD is not part of the results as\nthere is no route between Austin and Sydney.\n\n``` java\nLHR\nDFW\n```\n\nFor completeness, this query would more likely be written as follows\nrather than using a *union*.\n\n``` java\ng.V().has('airport','code','AUS').\n      out().has('code',within('LHR','DFW','SYD')).\n      values('code')\n\nLHR\nDFW\n```",
            "children": []
          }
        ]
      },
      {
        "level": "3.21",
        "title": "3.21. Using *sideEffect* to do things on the side {#sideeffect}",
        "content": "The *sideEffect* step allows you to do some additional processing as\npart of a query without changing what gets passed on to the next stage\nof the query. The example below finds the airport vertex V(3) and then\nuses a *sideEffect* to count the number of places that you can fly to\nfrom there and stores it in a traversal variable named *a* before\ncounting how many places you can get to with one stop and storing that\nvalue in *b*. Note that there are other ways we could write this query\nbut it demonstrates quite well how *sideEffect* works.\n\n``` java\ng.V(3).sideEffect(out().count().store('a')).\n       out().out().count().as('b').select('a','b')\n\n[a:[59],b:5911]\n```\n\nLater in the book we will discuss lambda functions, sometimes called\nclosures and how they can be used. The example below combines a closure\nwith a *sideEffect* to print a message before displaying information\nabout the vertex that was found. Again notice how the *sideEffect* step\nhas no effect on what is seen by the subsequent steps. You can see the\noutput generated below the query.\n\n``` java\ng.V().has('code','SFO').sideEffect{println \"I'm working on it\"}.values('desc')\n\nI'm working on it\nSan Francisco International Airport\n```\n\nLater in the book we will look at other ways that side effects can be\nused to solve more interesting problems.",
        "children": []
      },
      {
        "level": "3.22",
        "title": "3.22. Using *aggregate* to create a temporary collection {#aggregate}",
        "content": "At the time of writing this book, there were 59 places you could fly to\ndirectly (non stop) from Austin. We can verify this fact using the\nfollowing query.\n\n``` java\ng.V().has('code','AUS').out().count()\n\n59\n```\n\nIf we wanted to count how many places we could go to from Austin with\none stop, we could use the following query. The *dedup* step is used as\nwe only want to know how many unique places we can go to, not how many\ndifferent ways of getting to all of those places there are.\n\n``` java\ng.V().has('code','AUS').out().out().dedup().count()\n\n871\n```\n\nThere is however a problem with this query. The 871 places is going to\ninclude (some or possibly all of) the places we can also get to non stop\nfrom Austin. What we really want to find are all the places that you can\nonly get to from Austin with one stop. So what we need is a way to\nremember all of those places and remove them from the 871 some how. This\nis where *aggregate* is useful. Take a look at the modified query below\n\n``` java\ng.V().has('code','AUS').out().aggregate('nonstop').\n     out().where(without('nonstop')).dedup().count()\n\n812\n```\n\nAfter the first *out* step all of the vertices that were found are\nstored in a collection I chose to call *nonstop*. Then, after the second\n*out* we can add a *where* step that essentially says \\\"only keep the\nvertices that are not part of the nonstop collection\\\". We still do the\n*dedup* step as otherwise we will still end up counting a lot of the\nremaining airports more than once.\n\nNotice that 812 is precisely 59 less than the 871 number returned by the\nprevious query which shows the places you can get to non stop were all\ncorrectly removed from the second query. This also tells us there are no\nflights from Austin to places that you cannot get to from anywhere else!\n\nWe will take a more in depth look at the various types of collections\nthat you can use as part of a Gremlin query in the \\\"[Collections\nrevisited](#collrev)\\\" section a bit later.",
        "children": []
      },
      {
        "level": "3.23",
        "title": "3.23. Using *inject* to insert values into a query {#inject}",
        "content": "Sometimes you may want to add something additional to be returned along\nwith the results of your query. This can be done using the *inject*\nstep. To start off, here is a simple example showing how *inject*\nfundamentally works. We insert some numbers and ask Gremlin to give us\nthe mean value.\n\n``` java\ng.inject(1,2,3,4,5).mean()\n\n3.0\n```\n\nOf course just using *inject* so we can do a simple mathematical\ncomputation is of limited use. The next example shows how *inject* can\nbe used as part of a query. The string *ABIA*, another acronym commonly\nused when referring to the Austin Bergstrom International Airport, is\ninjected into the query.\n\n``` java\ng.V().has('code','AUS').values().inject('ABIA')\n```\n\nIf we were to run the query, here is what we would get back\n\n``` java\nABIA\nUS\nAUS\n12250\nAustin\n542\nKAUS\n-97.6698989868164\nairport\nUS-TX\n2\n30.1944999694824\nAustin Bergstrom International Airport\n```",
        "children": [
          {
            "level": "3.23.1",
            "title": "3.23.1. A useful trick using *inject* {#injecttrick}",
            "content": "There is also a useful trick that can be achieved using *inject*. Take a\nlook at the query below.\n\n``` java\ng.V().choose(V().hasLabel('XYZ').count().is(0),constant(\"None found\"))\n```\n\nIf we were to run it we would get back multiple lines like those below.\nOne for each vertex in the graph in fact.\n\n``` java\nNone found\nNone found\nNone found\nNone found\nNone found\n...\n```\n\nIn order to get just one result we might be tempted to write the query\nas shown below.\n\n``` java\ng.choose(V().hasLabel('XYZ').count().is(0),constant(\"None found\"))\n```\n\nHowever this will cause an error to be returned as a choose step cannot\ncome immediately after a traversal source object (*g*). To get around\nthis we can rewrite the query with an *inject* step after the *g*. We do\nnot use the value of the *inject* in the query but its presence allows\nus to follow it with a *choose* step.\n\n``` java\ng.inject(1).choose(V().hasLabel('XYZ').count().is(0),constant(\"None found\"))\n\nNone found\n```\n\nThis is a trick that can come in useful from time to time. The query\nused to demonstrate this point could indeed be rewritten to avoid any\nuse of *choose* but hopefully the usefulness of *inject* as a way to\navoid using a *V* when not wanted is clear.",
            "children": []
          }
        ]
      },
      {
        "level": "3.24",
        "title": "3.24. Using *coalesce* to see which traversal returns a result {#coalesce}",
        "content": "Sometimes, when you are uncertain as to which traversal of a set you are\ninterested in will return a result you can have them evaluated in order\nby the *coalesce* step. The first of the traversals that you specify\nthat returns a result will cause that result to be the one that is\nreturned to your query.\n\nLook at the example below. Starting from the vertex with an ID of 3 it\nuses *coalesce* to first see if there are any outgoing edges with a\nlabel of *fly*. If there are any, the vertices connected to those edges\nwill be returned. If there are not any, any vertices on any incoming\nedges labelled *contains* will be returned.\n\n``` java\n// Return the first step inside coalesce that returns a vertex\ng.V(3).coalesce(out('fly'),__.in('contains')).valueMap()\n```\n\nAs there are not any edges labelled *fly* in the *air-routes* graph, the\nsecond traversal will be the one whose results are returned.\n\nIf we were to run the above query using the *air-routes* graph, this is\nwhat would be returned.\n\n``` java\n[code:[NA],type:[continent],desc:[North America]]\n[code:[US],type:[country],desc:[United States]]\n```\n\nWe can put more than two traversals inside of a *coalesce* step. In the\nfollowing example there are now three. Because some *contains* edges do\nexist for this vertex, the *route* edges will not be looked at as the\ntraversals are evaluated in left to right order.\n\n``` java\ng.V(3).coalesce(out('fly'),\n              __.in('contains'),\n                out('route')).valueMap()\n```\n\nAs we can see the results returned are still the same.\n\n``` java\n[code:[NA],type:[continent],desc:[North America]]\n[code:[US],type:[country],desc:[United States]]\n```",
        "children": [
          {
            "level": "3.24.1",
            "title": "3.24.1. Combining *coalesce* with a *constant* value {#coalconst}",
            "content": "The *coalesce* step can also be very useful when combined with a\n*constant* value. In the example below if the airport is in Texas then\nits description is returned. If it is not in Texas, the string \\\"Not in\nTexas\\\" is returned instead.\n\n``` java\ng.V(1).coalesce(has('region','US-TX').values('desc'),constant(\"Not in Texas\"))\n\nNot in Texas\n\ng.V(3).coalesce(has('region','US-TX').values('desc'),constant(\"Not in Texas\"))\n\nAustin Bergstrom International Airport\n```\n\nA bit later in the \\\"[Using to only add a vertex if it does not\nexist](#coaladdv)\\\" section we will again use *coalesce* to check to see\nif a vertex already exists before we try to add it.",
            "children": []
          }
        ]
      },
      {
        "level": "3.25",
        "title": "3.25. Returning one of two possible results - introducing *optional* {#optional}",
        "content": "Sometimes it may be useful to return one of two results depending upon\nthe outcome of an attempted traversal. The *optional* step will return\neither the results of the provided traversal if there is a result or the\nresult of the prior step if there is no result.\n\nIn the example below, there is no direct route between Austin (AUS) and\nSydney (SYD) so the Austin vertex is returned by the *optional* step.\n\n``` java\ng.V().has('code','AUS').optional(out().has('code','SYD')).values('city')\n\nAustin\n```\n\nHowever, there is a route between Austin and Dallas Fort Worth (DFW) so\nas the example below shows, this time the *optional* step returns the\nDFW vertex.\n\n``` java\ng.V().has('code','AUS').optional(out().has('code','DFW')).values('city')\n\nDallas\n```\n\nNote that the previous queries behave in the same way that the\n*coalesce* step would behave if used as shown below. In this case, an\n*identity* step is used to return the prior vertex if the provided\ntraversal does not return a result.\n\n``` java\ng.V().has('code','AUS').\n      coalesce(out().has('code','SYD'),identity()).values('city')\n\nAustin\n\ng.V().has('code','AUS').\n      coalesce(out().has('code','DFW'),identity()).values('city')\n\nDallas\n```",
        "children": []
      },
      {
        "level": "3.26",
        "title": "3.26. Other ways to explore vertices and edges using *both*, *bothE*, *bothV* and *otherV* {#otherv}",
        "content": "We have already looked at examples of how you can walk a graph and\nexamine vertices and edges using steps such as *out*, *in*, *outE* and\n*inE*. In this section we introduce some additional ways to explore\nvertices and edges.\n\nAs a quick recap, we have already seen examples of queries like the one\nbelow that simply counts the number of outgoing edges from the vertex\nwith an ID of 3.\n\n``` java\ng.V(3).outE().count()\n\n59\n```\n\nLikewise, this query counts the number of incoming edges to that same\nvertex.\n\n``` java\ng.V(3).inE().count()\n\n61\n```\n\nThe following query introduces the *bothE* step. What this step does is\nreturn all of the edges connected to this vertex whether they are\noutgoing or incoming. As we can see the count of 120 lines up with the\nvalues we got from counting the number of outgoing and incoming edges.\nWe might want to retrieve the edges, as a simple example, to examine a\nproperty on each of them.\n\n``` java\ng.V(3).bothE().count()\n\n120\n```\n\nIf we wanted to return vertices instead of edges, we could use the\n*both* step. This will return all of the vertices connected to the\nvertex with an ID of 3 regardless of whether they are connected by an\noutgoing or an incoming edge.\n\n``` java\ng.V(3).both().count()\n\n120\n```\n\nThis next query can be used to show us the 120 vertices that we just\ncounted in the previous query. I sorted the results and used *fold* to\nbuild them into a list to make the results easier to read. Note how\nvertex 3 is **not** returned as part of the results. This is important,\nfor as we shall see in a few examples time, this is not always the case.\n\n``` java\ng.V(3).both().order().by(id).fold()\n\n[v[1],v[1],v[4],v[4],v[5],v[5],v[6],v[6],v[7],v[7],v[8],v[8],v[9],v[9],v[10],v[10],v[11],v[11],v[12],v[12],v[13],v[13],v[15],v[15],v[16],v[16],v[17],v[17],v[18],v[18],v[20],v[20],v[21],v[21],v[22],v[22],v[23],v[23],v[24],v[24],v[25],v[25],v[26],v[26],v[27],v[27],v[28],v[28],v[29],v[29],v[30],v[30],v[31],v[31],v[34],v[34],v[35],v[35],v[38],v[38],v[39],v[39],v[41],v[41],v[42],v[42],v[45],v[45],v[46],v[46],v[47],v[47],v[49],v[49],v[52],v[52],v[136],v[136],v[147],v[147],v[149],v[149],v[178],v[178],v[180],v[180],v[182],v[182],v[183],v[183],v[184],v[184],v[185],v[185],v[186],v[186],v[187],v[187],v[188],v[188],v[190],v[190],v[273],v[273],v[278],v[278],v[389],v[389],v[416],v[416],v[430],v[430],v[549],v[549],v[929],v[929],v[1274],v[1274],v[3591],v[3605]]\n```\n\nYou probably also noticed that most of the vertices appear twice. This\nis because for most air routes there is an outgoing and an incoming\nedge. If we wanted to eliminate any duplicate results we can do that by\nadding a *dedup* step to our query.\n\n``` java\ng.V(3).both().dedup().order().by(id).fold()\n\n[v[1],v[4],v[5],v[6],v[7],v[8],v[9],v[10],v[11],v[12],v[13],v[15],v[16],v[17],v[18],v[20],v[21],v[22],v[23],v[24],v[25],v[26],v[27],v[28],v[29],v[30],v[31],v[34],v[35],v[38],v[39],v[41],v[42],v[45],v[46],v[47],v[49],v[52],v[136],v[147],v[149],v[178],v[180],v[182],v[183],v[184],v[185],v[186],v[187],v[188],v[190],v[273],v[278],v[389],v[416],v[430],v[549],v[929],v[1274],v[3591],v[3605]]\n```\n\nWe can do another count using our modified query to check we got the\nexpected number of results back.\n\n``` java\ng.V(3).both().dedup().count()\n\n61\n```\n\nThere are a similar set of things we can do when working with edges\nusing the *bothV* and *otherV* steps. The *bothV* step returns the\nvertices at both ends of an edge and the *otherV* step returns the\nvertex at the other end of the edge. This is relative to how we are\nlooking at the edge.\n\nThe query below starts with our same vertex with the ID of 3 and then\nlooks at all the edges no matter whether they are incoming or outgoing\nand retrieves all of the vertices at each end of those edges using the\n*bothV* step. Notice that this time our count is 240. This is because\nfor every one of the 120 edges, we asked for the vertex at each end so\nwe ended up with 240 of them.\n\n``` java\ng.V(3).bothE().bothV().count()\n\n240\n```\n\nWe can again add a *dedup* step to get rid of duplicate vertices as we\ndid before and re-do the count but notice this time we get back 62\ninstead of the 61 we got before. So what is going on here?\n\n``` java\ng.V(3).bothE().bothV().dedup().count()\n\n62\n```\n\nLet's run another query and take a look at all of the vertices that we\ngot back this time.\n\n``` java\ng.V(3).bothE().bothV().dedup().order().by(id()).fold()\n\n[v[1],v[3],v[4],v[5],v[6],v[7],v[8],v[9],v[10],v[11],v[12],v[13],v[15],v[16],v[17],v[18],v[20],v[21],v[22],v[23],v[24],v[25],v[26],v[27],v[28],v[29],v[30],v[31],v[34],v[35],v[38],v[39],v[41],v[42],v[45],v[46],v[47],v[49],v[52],v[136],v[147],v[149],v[178],v[180],v[182],v[183],v[184],v[185],v[186],v[187],v[188],v[190],v[273],v[278],v[389],v[416],v[430],v[549],v[929],v[1274],v[3591],v[3605]]\n```\n\nCan you spot the difference? This time, vertex 3 (v\\[3\\]) **is**\nincluded in our results. This is because we started out by looking at\nall of the edges and then asked for all the vertices connected to those\nedges. Vertex 3 gets included as part of that computation. So beware of\nthis subtle difference between using *both* and the *bothE().bothV()*\npattern.\n\nLet's rewrite the queries we just used again but replace *bothV* with\n*otherV*. Notice that when we count the number of results we are back to\n61 again.\n\n``` java\ng.V(3).bothE().otherV().dedup().count()\n61\n```\n\nSo let's again look at the returned vertices and see what the difference\nis.\n\n``` java\ng.V(3).bothE().otherV().dedup().order().by(id()).fold()\n\n[v[1],v[4],v[5],v[6],v[7],v[8],v[9],v[10],v[11],v[12],v[13],v[15],v[16],v[17],v[18],v[20],v[21],v[22],v[23],v[24],v[25],v[26],v[27],v[28],v[29],v[30],v[31],v[34],v[35],v[38],v[39],v[41],v[42],v[45],v[46],v[47],v[49],v[52],v[136],v[147],v[149],v[178],v[180],v[182],v[183],v[184],v[185],v[186],v[187],v[188],v[190],v[273],v[278],v[389],v[416],v[430],v[549],v[929],v[1274],v[3591],v[3605]]\n```\n\nAs you can see, when we use *otherV* we do not get *v\\[3\\]* returned as\nwe are only looking at the other vertices relative to where we started\nfrom, which was *v\\[3\\]*.",
        "children": []
      },
      {
        "level": "3.27",
        "title": "3.27. Shortest paths (between airports) - introducing *repeat* {#sp}",
        "content": "Gremlin provides a *repeat...​until* looping construct similar to those\nfound in many programming languages. This gives us a nice way to perform\nsimple shortest path type queries. We can use a *repeat...​until* loop to\nlook for paths between two airports without having to specify an\nexplicit number of *out* steps to try.\n\nWhile performing such computations, we may not want paths we have\nalready travelled to be travelled again. We can ask for this behavior\nusing the *simplePath* step. Doing so will speed up queries that do not\nneed to travel the same paths through a graph multiple times. Without\nthe *simplePath* step being used the query we are about to look at could\ntake a lot longer. The addition of a *limit* step is also important as\nwithout it this query will run for a LONG time looking for every\npossible path!!\n\nThe query below looks for routes between Austin (AUS) and Agra (AGR). An\nimportant query for those Austinites wanting to visit the Taj Mahal!\n\n``` java\n// What are some of the ways to travel from AUS to AGR?\ng.V().has('code','AUS').\n      repeat(out().simplePath()).\n        until(has('code','AGR')).\n        path().by('code').limit(10)\n```\n\nHere are the results from running the query. Notice how, using the\n*repeat...​until* construct we did not have to specify how many steps to\ntry.\n\n``` java\n[AUS,YYZ,BOM,AGR]\n[AUS,LHR,BOM,AGR]\n[AUS,FRA,BOM,AGR]\n[AUS,EWR,BOM,AGR]\n[AUS,YYZ,ZRH,BOM,AGR]\n[AUS,YYZ,BRU,BOM,AGR]\n[AUS,YYZ,MUC,BOM,AGR]\n[AUS,YYZ,ICN,BOM,AGR]\n[AUS,YYZ,CAI,BOM,AGR]\n[AUS,YYZ,ADD,BOM,AGR]\n```\n\nYou can also place the *until* before the *repeat* as shown below.\n\n``` java\n// Another shortest path example using until...repeat instead\ng.V().has('code','AUS').\n      until(has('code','SYD')).\n        repeat(out().simplePath()).limit(10).\n      path().by('code')\n```\n\nHere are the results from running the query.\n\n``` java\n[AUS,DFW,SYD]\n[AUS,LAX,SYD]\n[AUS,SFO,SYD]\n[AUS,YYZ,HND,SYD]\n[AUS,YYZ,ICN,SYD]\n[AUS,YYZ,SCL,SYD]\n[AUS,YYZ,AUH,SYD]\n[AUS,YYZ,TPE,SYD]\n[AUS,YYZ,CAN,SYD]\n[AUS,YYZ,DFW,SYD]\n```\n\nWe can also specify an explicit number of out steps to try using a\n*repeat...​times* loop but this of course assumes that we know ahead of\ntime how many stops we want to look for between airports. In the next\nsection we will introduce the *emit* step that gives you more control\nover the behavior of what is returned from *repeat* loops.\n\n``` java\ng.V().has('code','AUS').repeat(out()).times(2).has('code','SYD').path().by('code')\n\n[AUS,DFW,SYD]\n[AUS,LAX,SYD]\n[AUS,SFO,SYD]\n```\n\nThe previous query is equivalent to this next one but doing it this way\nis less flexible in that we can not as easily vary the number of *out*\nsteps, should, for example we want to next try five hops instead of the\ncurrent two.\n\n``` java\ng.V().has('code','AUS').out().out().has('code','SYD').path().by('code')\n```\n\nAs is often the case when working with Gremlin there is more than one\nway to achieve the same result. The *loops* step, that can be used to\ncontrol how long a repeat loop runs, is essentially equivalent to the\n*times* step. Take a look at the two queries below. Both achieve the\nsame result. The first uses *loops* while the second uses *times*. I\nprefer the readability offered by the use of *times*.\n\n``` java\ng.V(3).repeat(out()).until(loops().is(2)).count()\n\n5894\n\ng.V(3).repeat(out()).times(2).count()\n\n5894\n```\n\n::: note\nIf you simply want to find out if any route exists between two airports,\nthere is a nice optimization that can be used. This is discussed in the\n\\\"[Does any route exist between two airports?](#doesanyrouteexist)\\\"\nsection later in the book.\n:::\n\nIn the next section, we will look at how *emit* can be used to adjust\nthe behavior of a *repeat...​times* loop.",
        "children": [
          {
            "level": "3.27.1",
            "title": "3.27.1. Using *emit* to return results during a *repeat* loop {#emit}",
            "content": "Sometimes it is useful to be able to return the results of a traversal\nas it executes. The example below starts at the Santa Fe airport (SAF)\nand uses a *repeat* to keep going out from there. By placing an *emit*\nright after the *repeat* we will be able to see the paths that are taken\nby the traversal. If we did not put the *emit* here this query would run\nfor a very long time as the *repeat* has no other ending condition!\n\n``` java\ng.V().has('code','SAF').repeat(out()).emit().path().by('code').limit(10)\n\n[SAF,DFW]\n[SAF,LAX]\n[SAF,PHX]\n[SAF,DEN]\n[SAF,DFW,ATL]\n[SAF,DFW,ANC]\n[SAF,DFW,AUS]\n[SAF,DFW,BNA]\n[SAF,DFW,BOS]\n[SAF,DFW,BWI]\n```\n\nAnother place where *emit* can be useful is when *repeat* and *times*\nare used together to find paths between vertices. Ordinarily, if you use\na step such as *times(3)* then the query will only return results that\nare three hops out. However if we use an *emit* we can also see results\nthat take fewer hops. First of all take a look at the query below that\ndoes not use an *emit* and the results that it generates.\n\n``` java\ng.V(3).repeat(out()).times(3).has('code','MIA').\n       limit(5).path().by('code')\n```\n\nThe paths returned show a selection of ways to get to Miami from Austin\nwith two stops but none of the results show fewer than two stops. Is\nthis what we really wanted?\n\n``` java\n[AUS,YYZ,MUC,MIA]\n[AUS,YYZ,MAN,MIA]\n[AUS,YYZ,YUL,MIA]\n[AUS,YYZ,SVO,MIA]\n[AUS,YYZ,GRU,MIA]\n```\n\nNow let's change the query to use an *emit*. This time you can think of\nthe query as saying \\\"at most three hops\\\" or in airline terms \\\"at most\ntwo stops\\\".\n\n``` java\ng.V(3).repeat(out().simplePath()).emit().times(3).has('code','MIA').\n       limit(5).path().by('code')\n```\n\nAs you can see, by adding an *emit* we got back a quite different set of\nresults. This is a really useful and powerful capability. Being able to\nexpress ideas such as \\\"at most three\\\" provides us a way to write very\nclean queries in cases like this.\n\n``` java\n[AUS,MIA]\n[AUS,YYZ,MIA]\n[AUS,LHR,MIA]\n[AUS,FRA,MIA]\n[AUS,MEX,MIA]\n```\n\nNote that using the emit step in the previous query we were able to\nwrite a more compact form of this query which essentially does the same\nthing. Note the use of the inline *or* step in this example.\n\n``` java\ng.V(3).repeat(out().simplePath()).\n         until(has('code','MIA').or().loops().is(3)).\n       has('code','MIA').\n       path().by('code').limit(5)\n```\n\nWhen run, as you can see, we get the same results back.\n\n``` java\n[AUS,MIA]\n[AUS,YYZ,MIA]\n[AUS,LHR,MIA]\n[AUS,FRA,MIA]\n[AUS,MEX,MIA]\n```\n\nThe *emit* step can also take a parameter such as a *has* step to filter\nout intermediate results that we are not interested in. The query below\nwill only show intermediate results as the *repeat* operates if they\nmeet a given condition. In this case the condition is that the path must\nhave passed through the Prague (PRG) airport's vertex. A *limit* step is\nused to only show the first 10 results.\n\n``` java\ng.V(3).repeat(out().simplePath()).emit(has('code','PRG')).\n       path().by('code').limit(10)\n```\n\nHere are the results from running the query.\n\n``` java\n[AUS,YYZ,PRG]\n[AUS,LHR,PRG]\n[AUS,FRA,PRG]\n[AUS,DTW,YYZ,PRG]\n[AUS,DTW,LHR,PRG]\n[AUS,DTW,CDG,PRG]\n[AUS,DTW,FRA,PRG]\n[AUS,DTW,PVG,PRG]\n[AUS,DTW,AMS,PRG]\n[AUS,DTW,MUC,PRG]\n```\n\nWithout the condition as part of the *emit* step we get different\nresults as we are shown every path the graph traverser is taking.\n\n``` java\ng.V(3).repeat(out().simplePath()).emit().path().by('code').limit(10)\n\n[AUS,DTW]\n[AUS,YYZ]\n[AUS,LHR]\n[AUS,FRA]\n[AUS,MEX]\n[AUS,PIT]\n[AUS,PDX]\n[AUS,ONT]\n[AUS,CLT]\n[AUS,CUN]\n```\n\nSo far, while interesting, many of the results shown look at first\nglance as if they could have been generated without using an *emit*.\nHowever, the query below is more interesting in that we use an *until*\nstep to specify a target airport of Austin (AUS) that we are interested\nin getting to from Lerwick (LSI) in the Shetland Islands. We also\nspecify, as part of the *emit* step, that we are interested in seeing\nany routes found that involve any airports in New York State regardless\nof whether or not they end up in Austin.\n\n``` java\ng.V().has('code','LSI').\n     repeat(out().simplePath()).\n        emit(has('region','US-NY')).\n        until(has('code','AUS')).\n     path().by('code').limit(10)\n```\n\nHere are the results the query generates, Notice how we got a mixture of\nNew York airports as well as Austin as our final destinations.\n\n``` java\nLSI,EDI,JFK]\nLSI,EDI,EWR]\nLSI,EDI,SWF]\nLSI,GLA,JFK]\nLSI,GLA,EWR]\nLSI,EDI,JFK,AUS]\nLSI,EDI,JFK,ROC]\nLSI,EDI,JFK,BUF]\nLSI,EDI,JFK,SYR]\nLSI,EDI,EWR,ROC]\n```\n\nThe *emit* can also be placed before the *repeat* step. This will cause\nthe result of the previous step in the query to be emitted before the\nresults that follow. In the example below, we start in Austin and go out\ntwo hops using a *repeat* loop. The first ten airport codes of the\nplaces we found are returned. Notice how AUS is returned as the first\nvalue even though that is where we started from due to our use of\n*emit*.\n\n``` java\ng.V().has('airport','code','AUS').\n      emit().repeat(out().simplePath()).times(2).limit(10).\n      values('code').fold()\n\n[AUS,YYZ,ZRH,YOW,BRU,MUC,RSW,MAN,YUL,YEG]\n```\n\nIn some cases, an *emit* placed after a *repeat* step has the same\neffect as an *until* step. Both queries below look for routes between\nJohannesburg (JNB) and Sydney (SYD).\n\n``` java\ng.V().has('code','JNB').repeat(out()).until(has('code','SYD')).\n      path().by('code').limit(3)\n\ng.V().has('code','JNB').repeat(out()).emit(has('code','SYD')).\n      path().by('code').limit(3)\n```\n\nWhen either query is run, the following results are returned.\n\n``` java\n[JNB,SYD]\n[JNB,BKK,SYD]\n[JNB,DOH,SYD]\n```\n\nYou will see more examples of *emit* being used in the \\\"[Modelling an\nordered binary tree as a graph](#btree)\\\" section a bit later.",
            "children": []
          },
          {
            "level": "3.27.2",
            "title": "3.27.2. Nested and named *repeat* steps {#nestedrepeat}",
            "content": "Starting with Apache TinkerPop release 3.4 it is now possible to nest a\n*repeat* step inside another *repeat* step as well as inside *emit* and\n*until* steps.\n\n::: tip\nThe official documentation for these new capabilities can be located\nhere: <http://tinkerpop.apache.org/docs/current/reference/#repeat-step>\n:::\n\nIt is also possible to label a repeat step with a name so that it can be\nreferenced later in a traversal. Nested *repeat* steps allow for some\ninteresting new graph traversal patterns. For example you might be\ntraversing along a set of outgoing edges, and for each vertex along the\nway want to traverse a set of incoming edges. The `air-routes` graph\ndoes not have any relationships that demonstrate an ideal use case for\nnested *repeat* steps but the query below shows a simple example.\n\n``` java\ng.V().has('code','SAF').\n      repeat(out('route').simplePath().\n        repeat(__.in('route')).times(3)).\n      times(2).\n      path().by('code').\n      limit(3).\n      toList()\n```\n\nRunning the query will generate results similar to those shown below. We\nstart at Santa Fe (SAF) and take one outbound route and arrive at Dallas\nFort Worth (DFW). We then look at three incoming routes which yields\nCorpus Christi (CRP), Lubbock (LBB) and Austin (AUS). We then take\nanother outbound hop from DFW and find ourselves in Atlanta(ATL) we then\nlook at three incoming routes from Atlanta and find Lagos (LOS), Addis\nAbaba (ADD) and one of Oslo (OSL), Bangkok (BKK) or Mumbai (BOM).\n\n``` java\n[SAF,DFW,CRP,LBB,AUS,ATL,LOS,ADD,OSL]\n[SAF,DFW,CRP,LBB,AUS,ATL,LOS,ADD,BKK]\n[SAF,DFW,CRP,LBB,AUS,ATL,LOS,ADD,BOM]\n```\n\nAs I mentioned, working with the air routes data set does not perhaps\npresent an ideal use case for using nested repeat steps. Most of the\nedges are routes and most of the vertices are airports. However, if your\ndata had a broader variety of vertex and edge types, this capability may\ncome in quite handy.\n\n::: note\nThere is a stand alone example in the `sample-code` folder that creates\na small social graph and performs various nested *repeat* step\noperations. That sample is located here:\n<https://github.com/krlawrence/graph/blob/main/sample-code/nested-repeat.groovy>\n:::\n\nWhen using nested *repeat* steps, in order for a *loops* step to know\nwhich repeat step it is attached to it is necessary to give each\n*repeat* step its own label name. The example below gives the *repeat*\nstep a label of *\\\"r1\\\"* and refers to that label in the subsequent\n*loops* step. Obviously, this example does not contain any nested\nrepeats but hopefully shows how this new labelling capability can be\nused.\n\n``` java\ng.V().has('code','SAF').\n      repeat('r1',out().simplePath()).\n        until(loops('r1').is(3).or().has('code','MAN')).\n      path().by('city').\n      limit(3).\n      toList()\n```\n\nThe results below show that we found Manchester once and reached our\n*loops* limit the other two times.\n\n``` java\n[Santa Fe,Los Angeles,Manchester]\n[Santa Fe,Dallas,Buenos Aires,Atlanta]\n[Santa Fe,Dallas,Buenos Aires,Houston]\n```",
            "children": []
          },
          {
            "level": "3.27.3",
            "title": "3.27.3. Limiting the results at each depth {#depthlimit}",
            "content": "Sometimes, while exploring a graph using *repeat* steps, it is desirable\nto limit the amount of results returned at any given depth of a\ntraversal. Achieving this result is a little more complicated than you\nmight expect. The *limit* step has a global scope, as shown below, and\nis therefore not quite what we need in this case.\n\n``` java\ng.V().has('code','SFO').\n      repeat(out().simplePath()).times(3).\n      limit(5).\n      path().by('code')\n```\n\nWhen the query is run, we get back five results at depth three (three\nhops) from San Francisco (SFO). While interesting, this is not the\nresult we are looking for in this case.\n\n``` java\n[SFO,ANC,DFW,ATL]\n[SFO,ANC,DFW,AUS]\n[SFO,ANC,DFW,BNA]\n[SFO,ANC,DFW,BOS]\n[SFO,ANC,DFW,BWI]\n```\n\nAt first glance, it may appear that simply moving the *limit* step\ninside the body of the *repeat* step is all we need to do but because of\nthe global nature of the *limit* step we need to take a different\napproach.\n\n``` java\ng.V().has('code','SFO').\n      repeat(out().simplePath().limit(5)).times(3).\n       path().by('code')\n```\n\nAs you can see, when the query is run we get the same result we got when\n*limit* was outside the *repeat* step body.\n\n``` java\n[SFO,ANC,DFW,ATL]\n[SFO,ANC,DFW,AUS]\n[SFO,ANC,DFW,BNA]\n[SFO,ANC,DFW,BOS]\n[SFO,ANC,DFW,BWI]\n```\n\nIn order to construct a traversal that will yield five results at each\ndepth we need to introduce some additional steps into the query. Rather\nthan jump straight to the final query though, let's look at some\nintermediate steps first.\n\nFirst of all, lets write a query that counts how many places we might\nend up at for each depth, starting at SFO to a depth of three hops. To\ndo this we can use the *loops* step as the key for a *groupCount* step.\nRemember that *loops* will tell us the depth we are currently at while\nexecuting a *repeat* step. The *loops* step depth counter starts at\nzero, so a value of zero really means we are at depth one. The counts\ngenerated by this query will include duplicates as there are multiple\nways to get to the same airport beyond depth one but that is not a\nproblem for the query we are building.\n\n``` java\ng.V().has('code','SFO').\n       repeat(out().simplePath().\n              groupCount('airports').by(loops())).\n       times(3).\n       cap('airports')\n```\n\nWhen given a label, in this case \\\"*airports*\\\", the *groupCount* step\nacts as a side effect. This means that it counts what passes through it\nbut does not change what is passed on to subsequent steps in the query.\nThe *cap* step at the end of the query explicitly returns the counts to\nus. As you can see below, when run, the query produces a map of the\nroute counts at the first three depths, where the depth is the map key\nand the count is the map value. As a side note, it is interesting to see\nhow quickly queries like this one can \\\"fan out\\\". We have essentially\nvisited airport vertices over 836,000 times at depth three given all the\nduplicate visits.\n\n``` java\n[0:141,1:11587,2:836707]\n```\n\nNow that we have a query that can count how many vertices we are\nvisiting at each depth we can use that to add a constraint that limits\nhow many we return.\n\n::: tip\nThe query below is available as a script called\n`restricted-repeat.groovy` in the sample-code folder located at\n<https://github.com/krlawrence/graph/tree/main/sample-code>.\n:::\n\nAn updated version of our query is shown below. A *where* step has been\nadded that initially selects the map generated by *groupCount* and from\nthat uses the current *loops* value to select an entry from the map. A\nvertex is passed on by the *where* step filter only if five or fewer\nhave been encountered so far.\n\n``` java\ng.V().has('code','SFO').\n       repeat(out().simplePath().groupCount('airports').by(loops()).\n              where(select('airports').select(loops()).is(lte(5)))).\n       emit().\n       times(3).\n       path().\n         by('code')\n```\n\nWhen we run our modified query, the output is quite different. This time\nat each depth, five routes are returned. This is the result we are\nlooking for!\n\n``` java\n[SFO,ANC]\n[SFO,AUS]\n[SFO,BNA]\n[SFO,BOS]\n[SFO,BWI]\n[SFO,ANC,DFW]\n[SFO,ANC,PDX]\n[SFO,ANC,IAH]\n[SFO,ANC,FAI]\n[SFO,ANC,LAX]\n[SFO,ANC,DFW,ATL]\n[SFO,ANC,DFW,AUS]\n[SFO,ANC,DFW,BNA]\n[SFO,ANC,DFW,BOS]\n[SFO,ANC,DFW,BWI]\n```\n\nAt first glance, the *where* step used above can be confusing. I have\nincluded some examples below that hopefully help explain the behavior\nmore easily. First of all, the query below simply creates a map using\n*groupCount* based on five vertex IDs where the key is simply a constant\nliteral value. As there is no *where* step present all five incoming\nvertices are accounted for in the result.\n\n``` java\ng.V(1,2,3,4,5).groupCount('x').by(constant('A')).select('x')\n\n[A:1]\n[A:2]\n[A:3]\n[A:4]\n[A:5]\n```\n\nIf we only wanted the third vertex to pass through the *where* step\nfilter we could adjust the query as follows. This is essentially what\nour \\\"five at each depth\\\" query does but is perhaps easier to follow.\n\n``` java\ng.V(1,2,3,4,5).groupCount('x').by(constant('A')).\n               where(select('x').select('A').is(3))\n\nv[3]\n```\n\nLastly, we can see what happens when we change the constraint to be less\nthan or equal to three. Only the first three vertices are included in\nthe result.\n\n``` java\ng.V(1,2,3,4,5).groupCount('x').by(constant('A')).\n               where(select('x').select('A').is(lte(3)))\n\nv[1]\nv[2]\nv[3]\n```\n\n::: note\nThere is another example of limiting the results of a *repeat* step\nusing a combination of *local* and *limit* steps in the \\\"[Randomly\nwalking a graph](#randwalk)\\\" section later in the book.\n:::\n\nHopefully, by decomposing the steps in this way you are able to gain a\ngood understanding of how this very useful Gremlin query works.",
            "children": []
          },
          {
            "level": "3.27.4",
            "title": "3.27.4. Haven't I been here before? - Introducing *cyclicPath* {#cyclicpath}",
            "content": "You can use the *cyclicPath* step to find paths through the graph that\nrevisit a vertex seen earlier in the traversal. This does not\nnecessarily mean revisiting the starting vertex, it can be any vertex\nalready seen while traversing a graph. An example of some cyclic paths\nis shown below. The rather contrived query below finds ten routes that\nboth start and end in Austin (AUS) with a stop along the way.\n\n``` java\n// From Austin and back again with one stop.\ng.V().has('code','AUS').\n      out().out().cyclicPath().\n      limit(10).path().by('code')\n```\n\nHere are the results from running the query.\n\n``` java\n[AUS,TUS,AUS]\n[AUS,PHL,AUS]\n[AUS,DTW,AUS]\n[AUS,YYZ,AUS]\n[AUS,LHR,AUS]\n[AUS,FRA,AUS]\n[AUS,MEX,AUS]\n[AUS,PIT,AUS]\n[AUS,PDX,AUS]\n[AUS,ONT,AUS]\n```\n\nYou can also use *cyclicPath* as a termination condition for a *repeat*\nloop. The query below keeps following outbound *route* edges until it\nends up back where it started. Once again, only the first ten results\nare selected.\n\n``` java\ng.V().has('code','AUS').\n      repeat(out('route')).until(cyclicPath()).\n      limit(10).path().by('code')\n```\n\nHere are the results from running the query. As you can see it generated\nthe same results in this instance but if we let it run for longer than\njust ten results it would ultimately find a lot more cyclic paths as it\nis not restricted to just going out one hop from its starting point.\nIndeed, if we did not restrict the number of results we wanted the query\nwould ultimately find every cyclic route in the graph. That query could\nrun for quite a while so I would not recommend trying it!\n\n``` java\n[AUS,TUS,AUS]\n[AUS,PHL,AUS]\n[AUS,DTW,AUS]\n[AUS,YYZ,AUS]\n[AUS,LHR,AUS]\n[AUS,FRA,AUS]\n[AUS,MEX,AUS]\n[AUS,PIT,AUS]\n[AUS,PDX,AUS]\n[AUS,ONT,AUS]\n```\n\nIf we let the previous query run a few hundred times you would start to\nsee examples of where the cycle is not back to the starting vertex. The\ntwo results below were generated by letting the query find 500 cyclic\npaths. Note that in the second case the cycle is back to Miami (MIA) and\nnot the starting vertex (AUS).\n\n``` java\n[AUS,MIA,BUF,AUS]\n[AUS,MIA,BUF,MIA]\n```\n\nYou can also use *cyclicPath* combined with a *not* predicate to avoid\nreturning cyclic results from a query.\n\n``` java\ng.V().has('code','AUS').\n      out().\n      out().not(cyclicPath()).limit(10).\n      path().by('code')\n```\n\nNote that for the *air-routes* graph this has the same effect as if we\nhad written the query as shown below.\n\n``` java\ng.V().has('code','AUS').as('a').\n      out().\n      out().where(neq('a')).limit(10).\n      path().by('code')\n```\n\nSome graphs contain vertices that have an edge that loops immediately\nback to the same vertex. Take a look at the code below that creates an\nedge with a label of *loop* from the vertex with an ID of 3 back to the\nsame vertex.\n\n``` java\ng.V(3).as('a').addE('loop').to('a')\n\ne[56951][3-loop->3]\n```\n\nWe can then use the *cyclicPath* step to find such loops in the graph.\n\n``` java\ng.V().out().cyclicPath().path()\n\n[v[3],v[3]]\n```\n\nTo include the edge in the result, you just need to modify the query a\nlittle as shown below.\n\n``` java\n g.V().outE().inV().cyclicPath().path()\n\n[v[3],e[56951][3-loop->3],v[3]]\n```",
            "children": []
          },
          {
            "level": "3.27.5",
            "title": "3.27.5. A warning that path finding can be memory and CPU intensive {#pathwarn}",
            "content": "Take a look at the query below. It returns the first 10 routes found\nthat will get you from Papa Stour (PSV), a small airport in the Shetland\nIslands, to Austin (AUS). The *simplePath* step is used to make sure the\nsame exact path is never looked at twice. This query runs quickly and\nreturns some useful results.\n\n``` java\ng.V().has('code','PSV').\n      repeat(out().simplePath()).\n      until(has('code','AUS')).\n      limit(10).\n      path().\n        by('code')\n```\n\nHere are some of the routes returned.\n\n``` java\n[PSV,LWK,FIE,KOI,EDI,JFK,AUS]\n[PSV,LWK,FIE,KOI,EDI,EWR,AUS]\n[PSV,LWK,FIE,KOI,EDI,LHR,AUS]\n[PSV,LWK,FIE,KOI,EDI,FRA,AUS]\n[PSV,LWK,FIE,KOI,GLA,JFK,AUS]\n[PSV,LWK,FIE,KOI,GLA,MCO,AUS]\n[PSV,LWK,FIE,KOI,GLA,EWR,AUS]\n[PSV,LWK,FIE,KOI,GLA,PHL,AUS]\n[PSV,LWK,FIE,KOI,GLA,YYZ,AUS]\n[PSV,LWK,FIE,KOI,GLA,LHR,AUS]\n```\n\nIf we reverse the query as shown below we can run into trouble. In fact,\nif you run this query on your laptop, after a few minutes of high CPU\nusage and increased fan noise, it is likely you will get an error that\nthe query ran out of available memory.\n\n``` java\ng.V().has('code','AUS').\n      repeat(out().simplePath()).\n      until(has('code','PSV')).\n      limit(10).\n      path().\n        by('code')\n```\n\nThe reason this happens is as follows. There are very few routes from\nPSV and not many more from the airports it is closely connected to.\nTherefore, if you start the query from PSV, you will fairly quickly find\nsome paths that end up in AUS. However, if you start from AUS there are\na lot of possible routes that Gremlin has to explore before it gets\nclose to finding PSV. If it helps, think of a funnel where PSV is at the\nnarrow end and AUS is at the other. This is also sometimes referred to\nas having a high or low \\\"fan out\\\" of possible routes depending on the\nquery direction.",
            "children": []
          },
          {
            "level": "3.27.6",
            "title": "3.27.6. A warning that the *path* and *as* steps can also be memory intensive {#pathstepwarn}",
            "content": "The Gremlin *path* step is incredibly useful and I find myself using it\na lot. However, there are some downsides to the use of *path*,\nespecially when searching entire graphs for non trivial results. Even if\nthe paths that you are looking for are less difficult to find than in\nthe prior section, you should be aware that keeping track of all the\npaths that you find and retrieving them using a *path* step can require\na lot of memory to be used.\n\n::: note\nThe *path* and *as* steps can use a lot of memory and in some cases\ncause issues.\n:::\n\nThe reason that so much memory can be consumed is that the *path* step,\neven if *simplePath* is used to avoid travelling the same exact path\nmore than once, requires the query processor to potentially store up a\nvery large number of results before finding the ones we are actually\ninterested in. So while the *path* step is incredibly useful, be aware\nthat in cases where a lot of paths need to be tracked, it can get you\ninto trouble if not used with care. A Gremlin query processor will have\na limited amount of memory available in which to execute a given query.\nStoring a large amount of path information may exceed that limit causing\nquery execution to fail.\n\nSomething that may not be immediately obvious is that using an *as* step\ncan also require the query processor to, at least in part, store path\ninformation requiring significant amounts of memory. The *as* step\nallows us to refer back to the previous state of a traversal but\npotentially requires a lot of memory to hold this state during complex\nqueries.\n\nIf you find yourself running into memory limitation issues there are\noften ways to circumvent the problem using different approaches to\nwriting the query. You will find an example of such a case in the\n\\\"[Comparing properties and constants to the value of a\nsack](#sackpredicate)\\\" section.",
            "children": []
          }
        ]
      },
      {
        "level": "3.28",
        "title": "3.28. Calculating vertex degree {#nd}",
        "content": "While working with graphs, the word *degree* is used when discussing the\nnumber of edges coming into a vertex (in degree), going out from a\nvertex (out degree) or potentially both coming in and going out\n(degree). It's quite simple with Gremlin to calculate various measures\nof degree as the following examples demonstrate.\n\nThe simplest way to calculate vertex degree is simply to count edges as\nshown below.\n\n``` java\n// Outgoing degree\ng.V().has('airport','code','LHR').out().count()\n\n191\n\n// Incoming degree\ng.V().has('airport','code','LHR').in().count()\n\n193\n\n// Overall degree\ng.V().has('airport','code','LHR').both().count()\n\n384\n```\n\nIf you want to calculate the degree values for more than a single\nvertex, it can be done more easily using the *group* step. The query\nbelow will calculate the number of outgoing routes for every airport in\nthe graph. If you run this query you will get quite a lot of result data\nback as there are over 3,300 airports in the graph.\n\n``` java\n// Out degree (number of routes) from each vertex (airport)\ng.V().hasLabel('airport').group().by('code').by(out('route').count())\n```\n\nThe query below builds upon the prior one but just selects a few of the\nresults.\n\n``` java\n// Outbound routes (degree) from LHR, JFK and DFW\ng.V().hasLabel('airport').group().by('code').by(out('route').count()).\n      select('LHR','JFK','DFW')\n```\n\nIf we were to run the query the output should look like this.\n\n``` java\n[LHR:191,JFK:187,DFW:221]\n```\n\nWe could change the query a little to calculate the in degree values.\nNote that we can see that JFK has one fewer incoming route than it has\noutgoing.\n\n``` java\ng.V().hasLabel('airport').\n      group().by('code').by(__.in('route').count()).\n      select('LHR','JFK','DFW')\n\n[LHR:191,JFK:186,DFW:221]\n```\n\nThe query below is a little more complex but can be used to find the 10\nairports with the highest number of outgoing routes. Some of the\nconcepts used such as *local* scope are covered in more detail a bit\nlater on in the \\\"[Using scope with collections](#localcollect)\\\"\nsection.\n\n``` java\ng.V().hasLabel('airport').\n      group().by('code').by(out().count()).\n      order(local).by(values).unfold().tail(10).fold()\n```\n\nHere are the results from running the query. As you can see, Frankfurt\nAirport (FRA) has the highest number of outgoing routes. The topic of\nanalyzing routes is revisited in detail in the \\\"[Airports with the most\nroutes](#mostroutes)\\\" section.\n\n``` java\n[DFW=221,DXB=229,ORD=232,ATL=232,PEK=234,MUC=237,CDG=262,AMS=269,IST=270,FRA=272]\n```\n\nThe next query will calculate the route degree based on all, incoming\nand outgoing, routes for ten airports. The query takes advantage of the\n*project* step that was introduced in TinkerPop 3.2.\n\n``` java\n// Calculate degree (in and out) for each vertex.\ng.V().hasLabel('airport').limit(10).\n      project(\"v\",\"degree\").by('code').by(bothE('route').count())\n```\n\nHere is the output that this query generates.\n\n``` java\n[v:ATL,degree:464]\n[v:ANC,degree:78]\n[v:AUS,degree:118]\n[v:BNA,degree:110]\n[v:BOS,degree:260]\n[v:BWI,degree:178]\n[v:DCA,degree:186]\n[v:DFW,degree:442]\n[v:FLL,degree:284]\n[v:IAD,degree:272]\n```\n\nWe could of course also write the same query using a *group* step as\nshown below.\n\n``` java\ng.V().hasLabel('airport').limit(10).\n      group().by('code').by(bothE('route').count())\n```\n\nThe results below were generated by running the query.\n\n``` java\n[DCA:186,BNA:110,DFW:442,BWI:178,ANC:78,BOS:260,FLL:284,ATL:464,IAD:272,AUS:118]\n```",
        "children": []
      },
      {
        "level": "3.29",
        "title": "3.29. Gremlin's scientific calculator - introducing *math* {#mathstep}",
        "content": "As we have seen in some of the prior sections, there are some Gremlin\nsteps such as *sum*, *count* and *mean* that can be used to perform some\nfairly basic mathematical operations. In Apache TinkerPop version 3.3.1\na new *math* step was introduced that allows us to perform scientific\ncalculator style mathematical operations as part of a Gremlin graph\ntraversal. As these operators build upon the Java Math class it is worth\nbecoming familiar with that class if you are not already. Be aware that\nthis functionality will only be available to you if the graph\nimplementation that you are using supports Apache TInkerPop 3.3.1 or\nhigher.\n\nThe table below provides a summary of the available operators sorted\nalphabetically.\n\n+----------+-----------------------------------------------------------+\n| \\+       | Arithmetic plus.                                          |\n+----------+-----------------------------------------------------------+\n| \\-       | Arithmetic minus.                                         |\n+----------+-----------------------------------------------------------+\n| \\*       | Arithmetic multiply.                                      |\n+----------+-----------------------------------------------------------+\n| /        | Arithmetic divide.                                        |\n+----------+-----------------------------------------------------------+\n| \\%       | Arithmetic modulo (remainder).                            |\n+----------+-----------------------------------------------------------+\n| \\^       | Raise to the power. (n\\^x).                               |\n+----------+-----------------------------------------------------------+\n| abs      | Absolute value                                            |\n+----------+-----------------------------------------------------------+\n| acos     | Arc (inverse) cosine in radians.                          |\n+----------+-----------------------------------------------------------+\n| asin     | Arc (inverse) sine in radians.                            |\n+----------+-----------------------------------------------------------+\n| atan     | Arc (inverse) tangent in radians.                         |\n+----------+-----------------------------------------------------------+\n| cbrt     | Cube root                                                 |\n+----------+-----------------------------------------------------------+\n| ceil     | Returns the smallest (closest to negative infinity)       |\n|          | double value that is greater than or equal to the         |\n|          | argument and is equal to a mathematical integer.          |\n+----------+-----------------------------------------------------------+\n| cos      | Cosine of angle given in radians.                         |\n+----------+-----------------------------------------------------------+\n| cosh     | Hyperbolic cosine.                                        |\n+----------+-----------------------------------------------------------+\n| exp      | Returns Euler's number *\\\"e\\\"* raised to the given power  |\n|          | *(e\\^x)*                                                  |\n+----------+-----------------------------------------------------------+\n| floor    | Returns the largest (closest to positive infinity) double |\n|          | value that is less than or equal to the argument and is   |\n|          | equal to a mathematical integer.                          |\n+----------+-----------------------------------------------------------+\n| log      | Natural logarithm (base *e*)                              |\n+----------+-----------------------------------------------------------+\n| log10    | Logarithm (base 10)                                       |\n+----------+-----------------------------------------------------------+\n| log2     | Logarithm (base 2)                                        |\n+----------+-----------------------------------------------------------+\n| signum   | Returns the *signum* function of the argument; zero if    |\n|          | the argument is zero, 1.0 if the argument is greater than |\n|          | zero, -1.0 if the argument is less than zero.             |\n+----------+-----------------------------------------------------------+\n| sin      | Sine of angle given in radians.                           |\n+----------+-----------------------------------------------------------+\n| sinh     | Hyperbolic sine                                           |\n+----------+-----------------------------------------------------------+\n| sqrt     | Square root                                               |\n+----------+-----------------------------------------------------------+\n| tan      | Tangent of angle given in radians.                        |\n+----------+-----------------------------------------------------------+\n| tanh     | Hyperbolic tangent.                                       |\n+----------+-----------------------------------------------------------+\n\n: Scientific calculator operators\n\nThe *math* step behaves differently from other steps that we have looked\nat so far in as much as the entire expression is passed in as a single\nstring. This means that you can use labels you have assigned as part of\na traversal but you cannot use external variables or static constant\nreferences such as *Math.PI* inside the expression itself. There are\nways to easily work around this however as we shall see below. I have\nnot attempted to give an example of every single operator being used but\nthe examples provided should provide all of the basic building blocks\nyou will need to incorporate mathematical operators into your own\nGremlin queries.\n\n::: tip\nThese features require that the graph database system you are using\nsupports a TinkerPop version of 3.3.1 or higher.\n:::",
        "children": [
          {
            "level": "3.29.1",
            "title": "3.29.1. Performing simple arithmetic {#arithmentic}",
            "content": "Let's start by looking at a few basic examples. First of all the query\nbelow shows that we can perform mathematical operations on literal\nvalues as part of a traversal. The vertex we found at the start of the\ntraversal is not used by the math step in this case.\n\n``` java\ng.V().limit(1).math('100/2')\n\n50.0\n```\n\nIf you want to use the result of the prior step of a traversal as part\nof a *math* step the special symbol *\\\"\\_\\\"* (underscore) can be used as\nshown below. Note that the *inject* step provides us a nice way to feed\nin values while experimenting with the *math* step\n\n``` java\ng.inject(100).math('_ /2')\n\n50.0\n```\n\nNow let's look at how vertex properties can be used by a *math* step. To\ndo this, we can also use named traversal steps as part of a *math*\noperation. The examples below start by checking how many runways the DFW\nand SFO airports have. Then a *math* step is used to show how we can add\nthose values together as part of a traversal.\n\n``` java\n// How many runways does DFW have?\ng.V().has('airport','code','DFW').values('runways')\n\n7\n\n// How many runways does SFO have?\ng.V().has('airport','code','SFO').values('runways')\n\n4\n```\n\nNow let's use *math* to add the values together as part of a single\ntraversal. Note that even though we are adding two integers together,\nthe result comes back as a double precision value. Also, note that the\nnamed steps *\\'a\\'* and *\\'b\\'* are specified inside the single string\nthat is passed to the math step. This is a key difference from all other\nsteps where we refer to one or more traversal labels inside of a step.\nLastly, notice that a *by* modulator is used to tell the *math* step\nwhich properties we want to add together.\n\n``` java\n// Use named steps to add some results together.\ng.V().has('airport','code','DFW').as('a').\n      out().has('code','SFO').as('b').\n      math('a + b').by('runways')\n\n11.0\n```\n\nThe examples below show division and modulo operators being used on the\nresults of a *count* step.\n\n``` java\ng.V(3).out().count()\n\n59\n\ng.V(3).out().count().math('_ / 2')\n\n29.5\n\ng.V(3).out().count().math('_ % 5')\n\n4.0\n```\n\nNote that the underscore character allowed us to avoid having to write\nthe previous queries using a pattern like the one used below where the\ncount step is labelled as *\\'a\\'*.\n\n``` java\ng.V(3).out().count().as('a').math('a / 2')\n\n29.5\n```",
            "children": []
          },
          {
            "level": "3.29.2",
            "title": "3.29.2. Using a *by* modulator with a *math* step {#mathby}",
            "content": "As with many Gremlin steps, a *math* step can also be combined with one\nor more *by* modulators. First of all let's write a simple query to\ninspect the number of runways and Santa Fe (SAF) and all of the places\nthat you can fly to from there.\n\n``` java\ng.V().has('code','SAF').as('a').\n      out().as('b').\n      select('a','b').\n        by(values('code','runways').fold())\n\n[a:[SAF,3],b:[DFW,7]]\n[a:[SAF,3],b:[LAX,4]]\n[a:[SAF,3],b:[PHX,3]]\n[a:[SAF,3],b:[DEN,6]]\n```\n\nNow let's modify the query to use a *math* step to add the number of\nrunways each pair of airports has.\n\n``` java\ng.V().has('code','SAF').as('a').\n      out().as('b').\n      math('a + b').by('runways')\n\n10.0\n7.0\n6.0\n9.0\n```\n\nOf course, this is a simple example where *math* is not really needed\nbut hopefully it shows how a *by* modulator can be used with a *math*\nstep. For completeness, here is the query rewritten to use a *sum* step.\nNotice that in this case the results are integers whereas the *math*\nstep always returns floating point values.\n\n``` java\ng.V().has('code','SAF').as('a').\n      out().as('b').\n      select('a','b').by('runways').select(values).sum(local)\n\n10\n7\n6\n9\n```",
            "children": []
          },
          {
            "level": "3.29.3",
            "title": "3.29.3. Converting feet to meters {#mathconvert}",
            "content": "The length of the longest runway at each airport in the graph is stored\nas units of feet. We can use a simple *math* step to convert that value\nto meters.\n\n``` java\ng.V().has('code','DFW').values('longest').math('_ * 0.3048')\n\n4084.6248\n```\n\nWe could make the result a bit more interesting by adding a *project*\nstep to the query.\n\n``` java\ng.V().has('code','DFW').\n      project('Longest runway at','feet','meters').\n        by('code').\n        by('longest').\n        by(values('longest').math('_ * 0.3048'))\n\n[Longest runway at:DFW,feet:13401,meters:4084.6248]\n```",
            "children": []
          },
          {
            "level": "3.29.4",
            "title": "3.29.4. Using the trigonometric functions {#mathtrig}",
            "content": "The trigonometric operators work as you would expect. All angles need to\nbe specified as radians and not degrees. You can do the conversion to\nradians yourself or use the Java *Math.toRadians* helper method if you\nprefer. The query below uses the *math* step to calculate the sine of 60\ndegrees and stores the result in a variable called *\\\"x\\\"*.\n\n``` java\n// Calculate the sine of 60 degrees\nx=g.inject(60*(Math.PI/180)).math('sin(_)').next()\n\n0.8660254037844386\n```\n\nWe can use our variable *\\\"x\\\"* to calculate the arcsine.\n\n``` java\n// Calculate the arcsine\ng.inject(x).math('asin(_)')\n\n1.0471975511965976\n```\n\nWe can use the Gremlin console as a calculator to prove that we got the\ncorrect answer back.\n\n``` java\n// Prove this is the right answer\nMath.toRadians(60)\n\n1.0471975511965976\n```\n\nNote that just as when using the Java Math library you have to be aware\nof possible rounding errors. You would expect the calculation below to\nreturn 1.0 but it does not as the conversion of 45 degrees to radians is\nnot precise enough for the Math library. Note that using the Java\n*Math.toRadians* method does not achieve the desired result either.\n\n``` java\n// Manual conversion\ng.inject(45*(Math.PI/180)).math('tan(_)')\n\n0.9999999999999999\n```\n\nSame experiment but using the helper method.\n\n``` java\n// Libraray conversion\ng.inject(Math.toRadians(45)).math('tan(_)')\n\n0.9999999999999999\n```\n\nThis presents us with a chance to experiment with another of the\noperators that the *math* step provides. We can use the *ceil* operator\nto round our result up to the nearest integer.\n\n``` java\ng.inject(Math.toRadians(45)).math('tan(_)').math('ceil(_)')\n\n1.0\n```",
            "children": []
          },
          {
            "level": "3.29.5",
            "title": "3.29.5. Using signum to make a choice {#mathsignum}",
            "content": "The *signum* operator allows us to make a decision depending upon\nwhether a numeric value is positive, negative or zero as shown below.\n\n``` java\ng.inject(-10).math('signum(_)')\n-1.0\n\ng.inject(10).math('signum(_)')\n1.0\n\ng.inject(0).math('signum(_)')\n0.0\n```\n\nWe can use this capability to build a query that reports which side of\nthe Greenwich meridian an airport is located. Note that I had to use the\n*\\\"D\\\"* suffix on the numbers in the *option* steps as *math* returns a\ndouble precision result.\n\n``` java\ng.V().hasLabel('airport').sample(12).\n      project('IATA','city','position').\n        by('code').\n        by('city').\n        by(choose(values('lon').math('signum(_)')).\n          option(0D,constant('on the meridian')).\n          option(1D,constant('East')).\n          option(-1D,constant('West')))\n```\n\nHere is an example of the output from running the query.\n\n``` java\n[IATA:LGW,city:London,position:West]\n[IATA:STN,city:London,position:East]\n[IATA:LIM,city:Lima,position:West]\n[IATA:SYD,city:Sydney,position:East]\n[IATA:VCE,city:Venice,position:East]\n[IATA:FCO,city:Rome,position:East]\n[IATA:OAK,city:Oakland,position:West]\n[IATA:GVA,city:Geneva,position:East]\n[IATA:LAS,city:Las Vegas,position:West]\n[IATA:NRT,city:Tokyo,position:East]\n[IATA:DME,city:Moscow,position:East]\n[IATA:ALC,city:Alicante,position:West]\n```",
            "children": []
          },
          {
            "level": "3.29.6",
            "title": "3.29.6. Calculating a standard deviation {#stddev}",
            "content": "We could use the new *math* step to implement a query that calculates\nthe standard deviation for the number of runways each airport in the\ngraph has. This allows us to see use of the *sqrt* and power (\\^)\noperators. I broke the solution into three queries rather than try to\nforce it all into one. Even now the final query of the three is\ncomplicated enough I think! Notice how multiple *math* steps are used in\nthe same query with the results from one being used as input to the\nnext.\n\nFirst of all let's calculate the mean (or average) number of runways in\nthe graph. Not surprisingly this number is close to 1.5 as as the\nmajority of the airports only have one or two runways.\n\n``` java\n// Average number of runways\nmean=g.V().hasLabel('airport').values('runways').mean().next()\n\n1.4309425014819206\n```\n\nWe also need to know how many airports there are in the graph so that we\ncan calculate the variance as part of the standard deviation\ncalculation.\n\n``` java\n// Total number of airports\ncount = g.V().hasLabel('airport').count().next()\n\n3374\n```\n\nNow we are ready to make use of the square root and power operators and\ncalculate the standard deviation. As a reminder, the standard deviation\nis found by taking the square root of the variance in a data set. The\nvariance itself is calculated by for each airport subtracting the mean\nfrom the number of runways it has and squaring it and then taking the\nsum of those values and finally dividing that sum by the number of\nairports. Let's write a query that can do all of that for us.\n\n``` java\n// Calculate the standard deviation\ng.withSideEffect(\"m\",mean).\n  withSideEffect(\"c\",count).\n  V().hasLabel('airport').values('runways').\n  math('(_ - m)^2').sum().math('_ / c').math('sqrt(_)')\n\n0.7510927827902234\n```\n\nWe could use another query to check on the distribution of runways in\nthe graph to see if we believe our standard deviation result.\n\n``` java\n g.V().hasLabel('airport').groupCount().by('runways')\n\n[1:2316,2:762,3:225,4:51,5:14,6:4,7:1,8:1]\n```\n\nLooking at the distribution, where a large majority of the airports have\neither one or two runways, our result looks pretty reasonable. Clearly\nthe few airports with six, seven or eight runways are the outliers in\nthis sample and would fall well outside of the standard deviation from\nthe mean that we calculated.\n\nJust for fun, let's use the same basic set of steps once again but this\ntime to find the standard deviation for the number of outgoing routes in\nthe graph.\n\nAs before we need to find the mean value for the data set. This time we\nneed to find the average number of outgoing routes in the graph. The\nairport count remains the same of course.\n\n``` java\nmean=g.V().hasLabel('airport').local(out().count()).mean().next()\n\n12.863070539419088\n\ncount = g.V().hasLabel('airport').count().next()\n\n3374\n```\n\nNow we are ready to again calculate the standard deviation for the data\nset representing all outgoing routes per airport.\n\n``` java\ng.withSideEffect(\"m\",mean).\n  withSideEffect(\"c\",count).\n  V().hasLabel('airport').local(out().count()).\n  math('(_ - m)^2').sum().math('_ / c').math('sqrt(_)')\n\n28.356862649682018\n```\n\nThis time we got a much bigger number back as the result compared to\nwhen we looked at runways. This reflects the differing distribution of\nroutes between major and more minor airports.",
            "children": []
          },
          {
            "level": "3.29.7",
            "title": "3.29.7. Calculating a standard deviation in one query {#stddevone}",
            "content": "In the previous section the steps to calculate the standard deviation\nwere broken up into three graph queries. It is possible to perform the\nentire task in a single query as shown below.\n\n``` java\ng.V().hasLabel('airport').\n      values('runways').fold().as('runways').\n      mean(local).as('mean').\n      select('runways').unfold().\n      math('(_-mean)^2').mean().math('sqrt(_)')\n\n0.7510927827902234\n```\n\nUsing this approach means that we can avoid making multiple round trips\nto the graph to generate the values we need. The query is not really a\nlot more complex either. Which technique you find more convenient may\ncome down to personal preference. Making multiple queries in general is\nnot always a bad thing but in this case using a single query I think\nmakes sense as it does not add much additional complexity to the steps\ninvolved.",
            "children": []
          },
          {
            "level": "3.29.8",
            "title": "3.29.8. Using *project* to feed values to *math* {#mathproject}",
            "content": "The *project* step can be used to create a map of key/value pairs that\ncan in turn be passed to a *math* step. First of all let's create a\nquery that generates a simple projection containing the number of\nincoming and outgoing routes at the Austin airport.\n\n``` java\ng.V().has('code','AUS').\n      project('in','out').\n        by(__.in('route').count()).\n        by(out('route').count())\n\n[in:59,out:59]\n```\n\nWe can now add a *math* step that uses the key names from the map\ncreated by the *project* step and adds their values together.\n\n``` java\ng.V().has('code','AUS').\n      project('in','out').\n        by(__.in('route').count()).\n        by(out('route').count()).\n      math('in + out')\n\n118.0\n```\n\nThere are obviously many other operators that I have not provided\nexamples for but hopefully the ones I have provided give you a feel for\nways that the *math* step can be used to create interesting queries.",
            "children": []
          }
        ]
      },
      {
        "level": "3.30",
        "title": "3.30. Including an index with results - introducing *withIndex* and *indexed* {#withindex}",
        "content": "If for any reason you wanted an index value included as part of the\nresults from a query you can use the Groovy *withIndex* or *indexed*\nmethods as shown below.\n\n::: note\nAs covered in the next section, a native Gremlin *index* step was\nintroduced in the Apache TinkerPop 3.4 release.\n:::\n\nThe *withIndex* method adds the index value at the end of a list whereas\nthe *indexed* method adds it at the start. You can provide a starting\nindex value as a parameter. If no value is provided the default value\nfor the first index will be zero.\n\n``` java\ng.V().has('region','US-OK').values('code').withIndex()\n\n[OKC,0]\n[TUL,1]\n[LAW,2]\n[SWO,3]\n```\n\n::: note\nNote that *indexed* and *withIndex* are Groovy methods and not Gremlin\ntraversal steps. They will only work using graph databases that allow\nGroovy code to be included as part of a query.\n:::\n\nHere is the same query as before but using 1 as the starting index.\n\n``` java\ng.V().has('region','US-OK').values('code').withIndex(1)\n\n[OKC,1]\n[TUL,2]\n[LAW,3]\n[SWO,4]\n```\n\nBelow is the query used again but this time with the *indexed* method\nbeing used to generate the index value.\n\n``` java\ng.V().has('region','US-OK').values('code').indexed(1)\n\n[1,OKC]\n[2,TUL]\n[3,LAW]\n[4,SWO]\n```",
        "children": [
          {
            "level": "3.30.1",
            "title": "3.30.1. The new *index* step added in TinkerPop 3.4 {#tp34index}",
            "content": "Apache TinkerPop version 3.4, released at the start of 2019, added a\nnative *index* step to the Gremlin language. A new *with* modulator was\nalso added that can be used to control how the index step behaves.\nUnlike the native *Groovy* methods, there is no way to specify the\nstarting value for the index range.\n\n::: tip\nThe official Apache TinkerPop documentation for the *index* step can be\nfound at the following link\n<http://tinkerpop.apache.org/docs/current/reference/#index-step>.\n:::\n\nThe use of *index* only really makes sense in the context of a\ncollection such as a *list* or a *map*. As shown below, without a *fold*\nstep in the query, the result set will consist of a number of individual\nlists all with an index of zero.\n\n``` java\ng.V().has('code','LHR').\n      out().limit(5).\n      values('code').index()\n\n[[HKG,0]]\n[[PEK,0]]\n[[PVG,0]]\n[[FCO,0]]\n[[BOM,0]]\n```\n\nIf we had a *fold* step before calling *index* however, the results will\nbe indexed in increments of one, starting at zero.\n\n``` java\ng.V().has('code','LHR').\n      out().limit(5).\n      values('code').fold().index()\n\n[[HKG,0],[PEK,1],[PVG,2],[FCO,3],[BOM,4]]\n```\n\nAdding an *unfold* step will yield a set of individual lists with each\ncontaining an airport code and its index.\n\n``` java\ng.V().has('code','LHR').\n      out().limit(5).\n      values('code').fold().index().\n      unfold()\n\n[HKG,0]\n[PEK,1]\n[PVG,2]\n[FCO,3]\n[BOM,4]\n```\n\nThe new *with* modulator can be used to control the type of collection\nthat *index* produces. To have the result returned as a map where the\nkey is the index value the query can be modified as follows.\n\n``` java\ng.V().has('code','LHR').\n      out().limit(5).\n      values('code').fold().\n      index().with(WithOptions.indexer,WithOptions.map)\n\n[0:HKG,1:PEK,2:PVG,3:FCO,4:BOM]\n```\n\nFinally the example below shows a *with* step being used to ask for\nresults as a list which is the default. The results are then sorted in\nreverse order.\n\n::: tip\nAll of the possible values that can be specified using WithOptions can\nbe found in the official Apache TinkerPop JavaDoc documentation [at this\nlocation](http://tinkerpop.apache.org/javadocs/current/full/org/apache/tinkerpop/gremlin/process/traversal/step/util/WithOptions.html).\n:::\n\nNote that this query uses *desc* rather than the now deprecated *decr*\nto ask for descending order results.\n\n``` java\ng.V().has('code','LHR').\n      out().limit(5).\n      values('code').fold().\n      index().with(WithOptions.indexer,WithOptions.list).\n      unfold().\n      order().by(tail(local,1),desc)\n\n[BOM,4]\n[FCO,3]\n[PVG,2]\n[PEK,1]\n[HKG,0]\n```",
            "children": []
          },
          {
            "level": "3.30.2",
            "title": "3.30.2. Using *index* to reverse a list {#index-reverse}",
            "content": "The Gremlin query language does not have a built in step or function\nthat can be used to reverse the contents of a list or other collection.\nHowever, this can be achieved using the *index* step. The example below\ntakes advantage of the index step to give each element of a list an\nindex number.\n\n``` java\ng.inject(['A','B','C','D']).index()\n\n[[A,0],[B,1],[C,2],[D,3]]\n```\n\nGiven that building block, we can use those index values to order the\nlist.\n\n``` java\ng.inject(['A','B','C','D']).index().\n  unfold().\n  order().\n    by(tail(local,1),desc)\n\n[D,3]\n[C,2]\n[B,1]\n[A,0]\n```\n\nThe query can be further refined so that the index values are not part\nof the result.\n\n``` java\ng.inject(['A','B','C','D']).index().\n  unfold().\n  order().\n    by(tail(local,1),desc).\n  limit(local,1).\n  fold()\n\n[D,C,B,A]\n```\n\nThe same technique can be used with any collection generated as part of\na query.\n\n``` java\ng.V().has('code','SAF').out().values('code').fold().index()\n\n[[DFW,0],[LAX,1],[PHX,2],[DEN,3]]\n```\n\nOnce again we can order the results using the index values.\n\n``` java\ng.V().\n  has('code','SAF').\n  out().\n  values('code').\n  fold().\n  index().\n  unfold().\n  order().\n    by(tail(local,1),desc).\n  limit(local,1).\n  fold()\n\n  [DEN,PHX,LAX,DFW]\n```",
            "children": []
          }
        ]
      },
      {
        "level": "3.31",
        "title": "3.31. More examples using concepts we have covered so far {#sx}",
        "content": "The examples in this section build upon the topics that we have covered\nso far. The query below finds cities that can be flown to from any\nairport in the Hawaiian islands.\n\n``` java\n// Which cities can I fly to from any airport in the Hawaiian islands?\ng.V().has('airport','region','US-HI').out().path().by('city')\n```\n\nIf we run the query we would get back results similar to those below.\nOnly a few of the full result set are shown.\n\n``` java\n[Honolulu,San Francisco]\n[Honolulu,Osaka]\n[Honolulu,San Diego]\n[Honolulu,Sapporo]\n[Honolulu,Las Vegas]\n[Honolulu,Sacramento]\n[Honolulu,Denver]\n[Kahului,Portland]\n[Kahului,Sacramento]\n[Kahului,Lahaina]\n[Lihue,Oakland]\n[Lihue,Vancouver]\n[Lihue,Seattle]\n[Lihue,San Francisco]\n```\n\nThe query below looks for airports in Europe using the continent vertex\nwith a code of *EU* as the starting point. The results are sorted in\nascending order and folded into a list.\n\n``` java\n// Find all the airports that are in Europe (The graph stores continent information\n// as \"contains\" edges connected from a \"continent\" vertex to each airport vertex.\ng.V().has('continent','code','EU').out('contains').values('code').order().fold()\n```\n\nHere is what we get back from running the query.\n\n``` java\n[AAL,AAQ,AAR,ABZ,ACE,ACH,ACI,AER,AES,AEY,AGB,AGF,AGH,AGP,AHO,AJA,AJR,ALC,ALF,AMS,ANE,ANG,ANR,ANX,AOI,AOK,ARH,ARN,ARW,ASF,ATH,AUR,AVN,AXD,BAY,BCM,BCN,BDS,BDU,BEB,BEG,BES,BFS,BGO,BGY,BHD,BHX,BIA,BIO,BIQ,BJF,BJZ,BLE,BLK,BLL,BLQ,BMA,BNN,BNX,BOD,BOH,BOJ,BOO,BRE,BRI,BRN,BRQ,BRR,BRS,BRU,BSL,BTS,BUD,BVA,BVE,BVG,BWK,BZG,BZK,BZO,BZR,BZZ,CAG,CAL,CCF,CDG,CDT,CEE,CEG,CFE,CFN,CFR,CFU,CGN,CHQ,CIA,CIY,CLJ,CLY,CMF,CND,CPH,CRA,CRL,CSH,CSY,CTA,CUF,CVT,CVU,CWC,CWL,DBV,DCM,DEB,DIJ,DLE,DME,DND,DNK,DNR,DOK,DOL,DRS,DSA,DTM,DUB,DUS,EAS,EBA,EBJ,EBU,EDI,EFL,EGC,EGO,EGS,EIN,EMA,ENF,EOI,ERF,ESL,ETZ,EVE,EVG,EXT,FAE,FAO,FCO,FDE,FDH,FIE,FKB,FLR,FLW,FMM,FMO,FNC,FNI,FOA,FRA,FRO,FSC,FUE,GCI,GDN,GDZ,GEV,GIB,GLA,GLO,GMZ,GNB,GOA,GOJ,GOT,GPA,GRO,GRQ,GRV,GRW,GRX,GRZ,GSE,GVA,GWT,HAA,HAD,HAJ,HAM,HAU,HDF,HEL,HER,HFS,HFT,HHN,HMV,HOR,HOV,HRK,HUY,IAR,IAS,IBZ,IEV,IFJ,IFO,IJK,ILD,ILY,INI,INN,INV,IOA,IOM,ISC,IST,IVL,JER,JIK,JKG,JKH,JKL,JMK,JNX,JOE,JSH,JSI,JSY,JTR,JTY,JYV,KAJ,KAO,KBP,KEF,KEM,KGD,KGS,KHE,KID,KIR,KIT,KIV,KKN,KLR,KLU,KLV,KLX,KOI,KOK,KRF,KRK,KRN,KRP,KRR,KRS,KSC,KSD,KSF,KSJ,KSO,KSU,KTT,KTW,KUF,KUN,KUO,KVA,KVK,KVX,KZI,KZN,KZR,KZS,LAI,LBA,LBC,LCG,LCJ,LCY,LDE,LDY,LED,LEH,LEI,LEJ,LEN,LEQ,LGG,LGW,LHR,LIG,LIL,LIN,LIS,LJU,LKL,LKN,LLA,LMP,LNZ,LPA,LPI,LPK,LPL,LPP,LPY,LRH,LRS,LRT,LSI,LTN,LUG,LUX,LUZ,LWK,LWO,LXS,LYC,LYR,LYS,MAD,MAH,MAN,MCX,MEH,MHG,MHQ,MJF,MJT,MJV,MLA,MLN,MLO,MME,MMK,MMX,MOL,MPL,MQF,MQN,MRS,MRV,MSQ,MST,MUC,MXP,MXX,NAL,NAP,NBC,NCE,NCL,NDY,NDZ,NNM,NOC,NQY,NRK,NRL,NRN,NTE,NUE,NVK,NWI,NYO,ODS,OER,OGZ,OLA,OLB,OMO,OMR,OPO,ORB,ORK,ORY,OSD,OSI,OSL,OSR,OST,OSW,OSY,OTP,OUL,OVD,OZH,PAD,PAS,PDL,PDV,PED,PEE,PEG,PES,PEZ,PGF,PGX,PIK,PIS,PIX,PJA,PLQ,PMF,PMI,PMO,PNA,PNL,POR,POZ,PPW,PRG,PRN,PSA,PSR,PSV,PUF,PUY,PVK,PXO,RDZ,REG,REN,RET,REU,RGS,RHO,RIX,RJK,RJL,RKV,RLG,RMI,RNB,RNN,RNS,ROV,RRS,RTM,RTW,RVK,RVN,RYG,RZE,SBZ,SCN,SCQ,SCV,SCW,SDL,SDN,SDR,SEN,SFT,SGD,SIP,SJJ,SJZ,SKE,SKG,SKN,SKP,SKU,SKX,SLM,SMA,SMI,SNN,SOF,SOG,SOJ,SOU,SOY,SPC,SPU,SRP,SSJ,STN,STR,STW,SUF,SUJ,SVG,SVJ,SVL,SVO,SVQ,SXB,SXF,SYY,SZG,SZY,SZZ,TAY,TBW,TEQ,TER,TFN,TFS,TGD,TGK,TGM,THN,TIA,TIV,TKU,TLL,TLN,TLS,TMP,TOS,TPS,TRD,TRE,TRF,TRN,TRS,TSF,TSR,TUF,TXL,TYF,TZL,UCT,UDJ,UFA,UIP,UKS,ULV,ULY,UME,URE,URO,URS,USK,UTS,UUA,VAA,VAR,VAW,VBY,VCE,VDB,VDE,VDS,VGO,VHM,VIE,VIN,VIT,VKO,VLC,VLL,VLY,VNO,VOG,VOL,VOZ,VRN,VST,VTB,VUS,VXO,WAT,WAW,WIC,WMI,WRO,WRY,XCR,XFW,XRY,ZAD,ZAG,ZAZ,ZIA,ZQW,ZRH,ZTH]\n```\n\nThe next queries show two ways of finding airports with 6 or more\nrunways.\n\n``` java\ng.V().where(values('runways').is(gte(6))).values('code')\n\ng.V().has('runways',gte(6)).values('code')\n```\n\nNext, let's look at two ways of finding flights from airports in South\nAmerica to Miami. The first query uses *select* which is what we would\nhave had to do in the TinkerPop 2 days. The second query, which feels\ncleaner to me, uses the *path* and *by* step combination introduced in\nTinkerPop 3.\n\n``` java\ng.V().has('continent','code','SA').out().as('x').out().as('y').\n      has('code','MIA').select('x','y').by('code')\n\ng.V().has('continent','code','SA').out().out().\n      has('code','MIA').path().by('code')\n```\n\nThis query finds the edge that connects Austin (AUS) with Dallas Ft.\nWorth (DFW) and returns the *dist* property of that edge so we know how\nfar that journey is.\n\n``` java\n// How far is it from DFW to AUS?\ng.V().has('code','DFW').outE().as('a').inV().has('code','AUS').select('a').values('dist')\n\n190\n```\n\nAs an alternative approach, we could return a path that would include\nboth airport codes and the distance. Notice how we need to use *outE*\nand *inV* rather than just *out* as we still need the edge to be part of\nour path so that we can get its *dist* property using a *by* step.\n\n``` java\ng.V().has('code','DFW').outE().inV().has('code','AUS').path().by('code').by('dist')\n\n[DFW,190,AUS]\n```\n\nIf we wanted to find out if there are any ways to get from Brisbane to\nAustin with only one stop, this query will do nicely!\n\n``` java\n// Routes from BNE to AUS with only one stop\ng.V().has('code','BNE').out().out().has('code','AUS').path().by('code')\n\n[BNE,LAX,AUS]\n```\n\nThis is another way of doing the same thing but, once again, to me using\n*path* feels more concise. The only advantage of this query is that if\nall you want is the name of any intermediate airports then that's all\nyou get!\n\n``` java\ng.V().has('code','BNE').out().as('stop').\n                        out().has('code','AUS').select('stop').values('code')\n\nLAX\n```\n\nA common thing you will find yourself doing when working with a graph is\ncounting things. This next query looks for all the airports that have\nfewer than five outgoing routes and counts them. It does this by\ncounting the number of airports that have fewer than five outgoing edges\nwith a *route* label. There are a surprisingly high number of airports\nthat offer this small number of destinations.\n\n``` java\n// Airports with fewer than 5 outgoing edges\ng.V().hasLabel('airport').where(out('route').count().is(lt(5))).count()\n\n2058\n```\n\nIn a similar vein this query finds the airports with more than 200\noutgoing routes. The second query shows that *where* is a synonym for\n*filter* in many cases.\n\n``` java\ng.V().hasLabel(\"airport\").where(outE('route').count().is(gt(200))).values('code')\n\ng.V().hasLabel(\"airport\").filter(outE(\"route\").count().is(gt(200))).values('code')\n```\n\nHere are two more queries that look for things that meet a specific\ncriteria. The first finds routes where the distance is exactly 100 miles\nand returns the source and destination airport codes. The first query\nuses *as* and *select* while the second one uses *path* and includes the\ndistance in the result.\n\n``` java\n// List ten (or less) routes where the distance is exactly 100 miles\ng.V().as('a').outE().has('dist',eq(100)).limit(10).inV().as('b').\n      select('a','b').by('code')\n\n[a:IAD,b:RIC]\n[a:HNL,b:OGG]\n[a:OGG,b:HNL]\n[a:SJO,b:LIR]\n[a:SVG,b:KRS]\n[a:RIC,b:IAD]\n[a:LIR,b:SJO]\n[a:KRS,b:SVG]\n[a:CYB,b:GCM]\n[a:GCM,b:CYB]\n```\n\nSimilar to the prior query but using *path* and displaying the distance\nas well as the airport codes.\n\n``` java\ng.V().outE().has('dist',eq(100)).limit(10).inV().path().by('code').by('dist')\n\n[IAD,100,RIC]\n[HNL,100,OGG]\n[OGG,100,HNL]\n[SJO,100,LIR]\n[SVG,100,KRS]\n[RIC,100,IAD]\n[LIR,100,SJO]\n[KRS,100,SVG]\n[CYB,100,GCM]\n[GCM,100,CYB]\n```\n\nThis query looks for any airports that have an elevation above 10,000\nfeet. Two ways of achieving the more or less the same result are shown.\nThe first uses *valueMap* and the second uses a *project* step instead.\n\n``` java\n// Airports above 10,000ft sorted by ascending elevation\ng.V().has('airport','elev', gt(10000)).\n      order().by('elev',asc).valueMap('city','elev')\n\n\ng.V().has('airport','elev', gt(10000)).order().by('elev',asc).\n      project('city','elevation').by('city').by('elev')\n```\n\nIf we ran the query that uses the *project* step here is what we should\nget back.\n\n``` java\n[city:Xiahe,elevation:10510]\n[city:Leh,elevation:10682]\n[city:Shangri-La,elevation:10761]\n[city:Cusco,elevation:10860]\n[city:Jauja,elevation:11034]\n[city:Andahuaylas,elevation:11300]\n[city:Jiuzhaigou,elevation:11327]\n[city:Navoi,elevation:11420]\n[city:Hongyuan,elevation:11598]\n[city:Lhasa,elevation:11713]\n[city:Oruro,elevation:12152]\n[city:Xigaze,elevation:12408]\n[city:Golog,elevation:12427]\n[city:Juliaca,elevation:12552]\n[city:Yushu,elevation:12816]\n[city:Potosi,elevation:12913]\n[city:Quijarro,elevation:12972]\n[city:La Paz / El Alto,elevation:13355]\n[city:Shiquanhe,elevation:14022]\n[city:Kangding,elevation:14042]\n[city:Bangda,elevation:14219]\n[city:Daocheng,elevation:14472]\n```\n\nThe next query finds any routes between Austin and Sydney that only\nrequire one stop.The *by* step offers a clean way of doing this query by\ncombining it with *path*.\n\n``` java\ng.V().has('code','AUS').out().out().has('code','SYD').path().by('code')\n```\n\nThe following three queries all achieve the same result. They find\nflights from any airport in Africa to any airport in the United States.\nThese queries are intresting as the continent information is represented\nin the graph as edges connecting an airport vertex with a continent\nvertex. This is about as close as Gremlin gets to a SQL join statement!\n\nThe first query starts by looking at airports the second starts from the\nvertex that represents Africa. The third query uses *where* to show an\nalternate way of achieving the same result.\n\n``` java\ng.V().hasLabel('airport').as('a').in('contains').has('code','AF').\n      select('a').out().has('country','US').as('b').select('a','b').by('code')\n\ng.V().hasLabel('continent').has('code','AF').out().as('a').\n      out().has('country','US').as('b').\n      select('a','b').by('code')\n\ng.V().hasLabel('airport').where(__.in('contains').has('code','AF')).as('a').\n      out().has('country','US').as('b').select('a','b').by('code')\n```\n\nIf we run the query we should get results that look like this. I have\nlaid them out in two columns to save space.\n\n``` java\n[a:JNB, b:ATL]    [a:ACC, b:JFK]\n[a:JNB, b:JFK]    [a:CMN, b:IAD]\n[a:CAI, b:JFK]    [a:CMN, b:JFK]\n[a:ADD, b:IAD]    [a:GCK, b:DFW]\n[a:ADD, b:EWR]    [a:DKR, b:IAD]\n[a:LOS, b:ATL]    [a:DKR, b:JFK]\n[a:LOS, b:IAH]    [a:LFW, b:EWR]\n[a:LOS, b:JFK]    [a:RAI, b:BOS]\n[a:ACC, b:IAD]\n```\n\nThe query below shows how to use the *project* step that was introduced\nin TinkerPop 3, along with *order* and *select* to produce a sorted\ntable of airports you can fly to from AUSTIN along with their runway\ncounts. The *limit* step is used to only return the top ten results. You\nwill find several examples elsewhere in this book that use variations of\nthis collection of steps.\n\n``` java\ng.V().has('code','AUS').out().project('ap','rw').by('code').by('runways').\n      order().by(select('rw'),desc).limit(10)\n```\n\nHere are the results we get from running the query.\n\n``` java\n[ap:ORD, rw:8]\n[ap:DFW, rw:7]\n[ap:BOS, rw:6]\n[ap:DEN, rw:6]\n[ap:DTW, rw:6]\n[ap:YYZ, rw:5]\n[ap:MDW, rw:5]\n[ap:ATL, rw:5]\n[ap:IAH, rw:5]\n[ap:FRA, rw:4]\n```",
        "children": []
      }
    ]
  },
  {
    "level": "4",
    "title": "4. BEYOND BASIC QUERIES {#beq}",
    "content": "So far we have looked mostly at querying an existing graph. In the\nfollowing sections we will look at many other topics that it is also\nimportant to be familiar with when working with Gremlin. These topics\ninclude mixing in some Groovy or Java code with your queries, as well as\nadding vertices (nodes), edges and properties to a graph and also\ndeleting them. We will also look at how to create a sub-graph and how to\nsave a graph to an XML or JSON file and a lot more. Let's start off with\na short discussion of query layout, reserved words and data modelling.",
    "children": [
      {
        "level": "4.1",
        "title": "4.1. A word about layout and indentation {#indents}",
        "content": "As you begin to write more complex Gremlin queries they can get quite\nlengthy. In order to make them easier for others to read it is\nrecommended to spread them over multiple lines and indent them in a way\nthat makes sense. I am not going to propose an indentation standard, I\nbelieve this should be left to personal preference however there are a\nfew things I want to mention in passing. When working with the Gremlin\nconsole, if you want to spread a query over multiple lines then you will\nneed to end each line with a backslash character or with a character\nsuch as a period or a comma that tells the Gremlin parser that there is\nmore to come.\n\nThe following example shows the query we already looked at in the\nBoolean operations section of this book but this time edited so that it\ncould be copy and pasted directly into the Gremlin console.\n\n``` java\ng.V().hasLabel('airport') \\\n     .has('region',within('US-TX','US-LA','US-AZ','US-OK'))   \\\n     .order().by('region',asc)   \\\n     .valueMap().select('code','region')\n```\n\nWe can avoid the use of backslash characters if we lay the query out as\nfollows. Each line ends with a period which tells the parser that there\nare more steps coming.\n\n``` java\ng.V().hasLabel('airport').\n      has('region',within('US-TX','US-LA','US-AZ','US-OK')).\n      order().by('region',asc).\n      valueMap().select('code','region')\n```\n\nIf we do not give the parser one of these clues that there is more to\ncome, the Gremlin console will try and execute each line without waiting\nfor the next line.\n\nSome people find it easier to read queries when each step or modulator\nis given its own line and indented appropriately. So we could layout the\nquery as shown below and it will still work just fine.\n\n``` java\ng.V().hasLabel('airport').\n      has('region',within('US-TX','US-LA','US-AZ','US-OK')).\n      order().\n        by('region',asc).\n      valueMap().\n      select('code','region')\n```\n\nWhether you decide to use the backslash as a continuation character or\nleave the period on the previous line is really a matter of personal\npreference. Just be sure to do one or the other if you want to use\nmultiple line queries within the Gremlin console. There is no golden\nrule as to how many lines and how much indenting you should use when\nlaying out your more complex queries. However, whatever you decide to\ndo, it is worth remembering that others reading your work may find well\nlaid out and appropriately indented steps easier to read and understand.",
        "children": []
      },
      {
        "level": "4.2",
        "title": "4.2. A warning about reserved word conflicts and collisions {#rword}",
        "content": "Most of the time the issue I am about to describe will not be a problem.\nHowever, there are cases where names of Gremlin steps conflict with\nreserved words and method names in Groovy. Remember that Gremlin is\ncoded in Groovy and Java. If you hit one of these cases, often the error\nmessage that you will get presented with does not make it at all clear\nthat you have run into this particular issue. Let's look at some\nexamples. One step name in Gremlin that can sometimes run into this\nnaming conflict is the *in* step. However, you do not have to worry\nabout this in all cases. First take a look at the following query.\n\n``` java\ng.V().has('code','AUS').in()\n```\n\nThat query does not cause an error and correctly returns all of the\nvertices that are connected by an incoming edge, to the *AUS* vertex.\nThere is no conflict of names here because it is clear that the *in*\nreference applies to the result of the has step. However, now take a\nlook at this query.\n\n``` java\ng.V().has('code','AUS').union(in(),out())\n```\n\nIn this case the *in* is on its own and not *dot connected* to a\nprevious step. The Gremlin runtime (which remember is written in Groovy)\nwill try to interpret this and will throw an error because it thinks\nthis is a reference to its own *in* method. To make this query work we\nhave to adjust the syntax slightly as follows.\n\n``` java\ng.V().has('code','AUS').union(__.in(),out())\n```\n\nNotice that I added the *\\\"\\_\\_.\\\"* (underscore underscore period) in\nfront of the *in* step. This is shorthand for *\\\"the thing we are\ncurrently looking at\\\"*, so in this case, the result of the *has* step.\n\nThere are currently not too many Groovy reserved words to worry about.\nThe three that you have to watch out for are *in*, *not* and *as* which\nhave special meanings in both Gremlin and Groovy. Remember though, you\nwill only need to use the *\\\"\\_\\_.\\\"* notation when it is not clear what\nthe reserved word, like *in*, applies to.\n\nYou will find an example of *not* being used with the *\\\"\\_\\_.\\\"* prefix\nin the \\\"[Modelling an ordered binary tree as a graph](#btree)\\\" section\na bit later on.",
        "children": []
      },
      {
        "level": "4.3",
        "title": "4.3. Thinking about your data model {#dmodel}",
        "content": "As important as it is to become good at writing effective Gremlin\nqueries, it is equally important, if not more so, to put careful\nconsideration into how you model your data as a graph. Ideally you want\nto arrange your graph so that it can efficiently support the most common\nqueries that you foresee it needing to handle.\n\nConsider this query description. \\\"Find all flight routes that exist\nbetween airports anywhere in the continent of Africa and the United\nStates\\\". When putting the *air-routes* graph together I decided to\nmodel continents as their own vertices. So each of the seven continents\nhas a vertex. Each vertex is connected to airports within that continent\nby an edge labeled \\\"contains\\\".\n\nI could have chosen to just make the continent a property of each\nairport vertex but had I done that, to answer the question about\n\\\"routes starting in Africa\\\" I would have to look at every single\nairport vertex in the graph just to figure out which continent contained\nit. By giving each continent its own vertex I am able to greatly\nsimplify the query we need to write.\n\nTake a look at the query below. We first look just for vertices that are\ncontinents. We then only look at the Africa vertex and the connections\nit has (each will be to a different airport). By starting the query in\nthis way, we have very efficiently avoided looking at a large number of\nthe airports in the graph altogether. Finally we look at any routes from\nairports in Africa that end up in the United States. This turns out to\nyield a nice and simple query in no small part because our data model in\nthe graph made it so easy to do.\n\n``` java\n// Flights from any Airport in Africa to any airport in the United States\ng.V().hasLabel('continent').has('code','AF').out().as('a').\n      out().has('country','US').as('b').select('a','b').by('code')\n```\n\nWe could also have started our query by looking at each airport and\nlooking to see if it is in Africa but that would involve looking at a\nlot more vertices. The point to be made here is that even if our data\nmodel is good we still need to always be thinking about the most\nefficient way to write our queries.\n\n``` java\n// Gives same results but not as efficient\ng.V().hasLabel('airport').as('a').in('contains').has('code','AF').\n     .select('a').out().has('country','US').as('b').select('a','b').by('code')\n```\n\nNow for a fairly simple graph, like *air-routes*, this discussion of\nefficiency is perhaps not such a big deal, but as you start to work with\nlarge graphs, getting the data model right can be the difference between\ngood and bad query response times. If the data model is bad you won't\nalways be able to work around that deficiency simply by writing clever\nqueries!",
        "children": [
          {
            "level": "4.3.1",
            "title": "4.3.1. Keeping information in two places within the same graph {#_keeping_information_in_two_places_within_the_same_graph}",
            "content": "Sometimes, to improve query efficiency I find it is actually worth\nhaving the data available more than one place within the same graph. An\nexample of this in the air routes graph would be the way I decided to\nmodel countries. I have a unique vertex for each country but I also\nstore the country code as a property of each airport vertex. In a small\ngraph this perhaps is overkill but I did it to make a point. Look at the\nfollowing two queries that return the same results - the cities in\nPortugal that have airports in the graph.\n\n``` java\ng.V().has('country','code','PT').out(\"contains\").values('city')\n\ng.V().has('airport','country','PT').values('city')\n```\n\nThe first query finds the country vertex for Portugal and then, finds\nall of the countries connected to it. The second query looks at all\nairport vertices and looks to see if they contain *PT* as the country\nproperty.\n\nIn the first example it is likely that a lot fewer vertices will get\nlooked at than the first even though a few edges will also get walked as\nthere are over 3,000 airport vertices but fewer than 300 country\nvertices. Also, in a production system with an index in place finding\nthe *Portugal* vertex should be very fast.\n\nConversely, if we were already looking at an airport vertex for some\nother reason and just wanted to see what country it is in, it is more\nconvenient to just look at the *country* property of that vertex.\n\nSo there is no golden rule here but it is something to think about while\ndesigning your data model.",
            "children": []
          },
          {
            "level": "4.3.2",
            "title": "4.3.2. Using a graph as an index into other data sources {#_using_a_graph_as_an_index_into_other_data_sources}",
            "content": "While on the topic of what to keep in the graph, something to resist\nbeing drawn into in many cases is the desire to keep absolutely\neverything in the graph. For example, in the air routes graph I do not\nkeep every single detail about an airport (radio frequencies, runway\nnames, weather information etc.) in the airport vertices. That\ninformation is available in other places and easy to find. In a\nproduction system you should consider carefully what needs to be in your\ngraph and what more naturally belongs elsewhere. One thing I could do is\nadd a URL as a property of each airport vertex that points to the\nairports home page or some other resource that has all of the\ninformation. In this way the graph becomes a high quality index into\nother data sources. This is a common and useful pattern when working\nwith graphs. This model of having multiple data sources working together\nis sometimes referred to as *Polyglot storage*.",
            "children": []
          },
          {
            "level": "4.3.3",
            "title": "4.3.3. A few words about *supernodes* {#_a_few_words_about_supernodes}",
            "content": "When a vertex in a graph has a large number of edges and is\ndisproportionately connected to many of the other vertices in the graph\nit is likely that many, if not all, graph traversals of any consequence\nwill include that vertex. Such vertices (nodes) are often referred to as\n*supernodes*. In some cases the presence of *supernodes* may be\nunavoidable but with careful planning as you design your graph model you\ncan reduce the likelihood that vertices become *supernodes*. The reason\nwe worry about *supernodes* is that they can significantly impact the\nperformance of graph traversals. This is because it is likely that any\ngraph traversal that goes via such a vertex will have to look at most if\nnot all of the edges connected to that vertex as part of a traversal.\n\nThe *air-routes* graph does not really have anything that could be\nclassed as a *supernode*. The vertex with the most edges is the\ncontinent vertex for North America that has approximately 980 edges. The\nbusiest airports are IST and AMS and they both have just over 530 total\nedges. So in the case of the *air-routes* graph we do not have to worry\ntoo much.\n\nIf we were building a graph of a social network that included famous\npeople we might have to worry. Consider some of the people on Twitter\nwith millions of followers. Without taking some precautions, such a\nsocial network, modelled as a graph, could face issues.\n\nAs you design your graph model it is worth considering that some things\nare perhaps better modelled as a vertex property than as a vertex with\nlots of edges needing to connect to it. For example in the air routes\ngraph there are country vertices and each airport is connected to one of\nthe country vertices. In the air routes graph this is not a problem as\neven if all of the airports in the graph were in the same country that\nwould still give us fewer than 3,500 edges connected to that vertex.\nHowever, imagine if we were building a graph of containing a very large\nnumber of people. If we had several million people in the graph all\nliving in same the country that would be a guaranteed way to get a\n*supernode* if we modelled that relationship by connecting every person\nvertex to a country vertex using a *lives in* edge. In such situations,\nit would be far more sensible to make the country where a person lives a\nproperty of their own vertex.\n\nA detailed discussion of *supernode* mitigation is beyond the scope of\nthis book but I encourage you to always be thinking about their\npossibility as you design your graph and also be thinking about how you\ncan prevent them becoming a big issue for you.",
            "children": []
          }
        ]
      },
      {
        "level": "4.4",
        "title": "4.4. Making Gremlin even Groovier {#grv}",
        "content": "As we have already discussed, the Gremlin console builds upon the Groovy\nconsole, and Groovy itself is coded in Java. This means that all of the\nclasses and methods that you would expect to have available while\nwriting Groovy or Java programs are also available to you as you work\nwith the Gremlin Console. You can intermix additional features from\nGroovy and Java classes along with the features provided by the\nTinkerPop 3 classes as needed. This capability makes Gremlin\nadditionally powerful. You can also take advantage of these features\nwhen working with Gremlin Server and with other TinkerPop enabled graph\nservices with the caveat that some features may be blocked if viewed as\na potential security risk to the server or simply because they are not\nsupported.\n\nEvery Gremlin query we have demonstrated so far is also, in reality,\nvalid Groovy. We have already shown examples of storing values into\nvariables and looping using Groovy constructs as part of a single or\nmulti part Gremlin query.\n\nIn this section we are going to go one step further and actually define\nsome methods, using Groovy syntax, that can be run while still inside\nthe Gremlin Console. By way of a simple example, let's define a method\nthat will tell us how far apart two airports are and then invoke it.\n\n``` java\n// A simple function to return the distance between two airports\ndef dist(g,from,to) {\n  d=g.V().has('code',from).outE().as('a').inV().has('code',to)\n         .select('a').values('dist').next()\n  return d }\n\n// Can be called like this\ndist(g,'AUS','MEX')\n```\n\nThis next example shows how to define a slightly longer method that\nprints out information about the degree of a vertex in a nice, human\nreadable, form.\n\n``` java\n// Groovy function to display vertex degree\ndef degree(g,s) {\n  v = g.V().has('code',s).next();\n  o=g.V(v).out().count().next();\n  i=g.V(v).in().count().next() ;\n  println \"Edges in  : \" + i;\n  println \"Edges out : \" + o;\n  println \"Total     : \" +(i+o);\n}\n\n// Can be called like this\ndegree(g,'LHR')\n```\n\nHere is an example that shows how we can query the graph, get back a\nlist of values and then use a *for* loop to display them. Notice this\ntime how we initially store the results of the query into the variable\n*x*. The call to *toList* ensures that *x* will contain a list (array)\nof the returned values.\n\n``` java\n// Using a Groovy for() loop to iterate over a list returned by Gremlin\nx=g.V().hasLabel('airport').limit(10).toList()\nfor (a in x) {println(a.values('code').next()+\" \"+a.values('icao').next()+\" \"+a.values('desc').next())}\n\n// We can also do this just using a 'for' loop and not storing anything into a variable.\nfor (a in g.V().hasLabel('airport').limit(10).toList()) {println(a.values('code').next()+\"\"+a.values('icao').next())}\n```\n\nSometimes (as you have seen above) it is necessary to make a call to\n*next* to get the result you expect returned to your variable.\n\n``` java\nnumber = g.V().hasLabel('airport').count().next()\nprintln \"The number of airports in the graph is \" + number\n```\n\nHere is another example that makes a Gremlin query inside a *for* loop.\n\n``` java\nfor (a in 1..10) print g.V().has(id,a).values('code').next()+\" \"\n```\n\nThis example returns a hash of vertices, with vertex labels as the keys\nand the code property as the values. It then uses the label names to\naccess the returned hash.\n\n``` java\na=g.V().group().by(label).by('code').next()\nprintln(a[\"country\"].size())\nprintln(a[\"country\"][5])\nprintln(a[\"airport\"][2])\n```\n\nHere is another example. This time we define a method that takes as\ninput a traversal object and the code for an airport. It then uses those\nparameters to run a simple Gremlin query to retrieve all of the places\nthat you can fly to from that airport. It then uses a simple *for* loop\nto print the results in a table. Note the use of *next* as part of the\n*println*. This is needed in order to get the actual values that we are\nlooking for. If we did not include the calls to *next* we would actually\nget back the iterator object itself and not the actual values.\n\n``` java\n// Given a traversal and an airport code print a list of all the places you can\n// fly to from there including the IATA code and airport description.\ndef from(g,a) {\n  places=g.V().has('code',a).out().toList();\n  for (x in places) {println x.values('code').next()+\" \"+x.values('desc').next()}\n}\n\n// Call like this\nfrom(g,'AUS')\n```\n\nThis example creates a hash map of all the airports, using their IATA\ncode as the key. We can then access the map using the IATA code to query\ninformation about those airports. Remember that the *;\\[\\]* at the end\nof the query just stops the console from displaying unwanted output.\n\n``` java\n// Create a map (a) of all vertices with the code property as the key\na=g.V().group().by('code').next();[]\n\n// Show the description stored in the JFK vertex\na['JFK'][0].values('desc')\n```\n\nAnother useful way to work with variables is to establish the variable\nand then use the *fill* step to place the results of a query into it.\nThe example below creates an empty list called *german*. The query then\nfinds all the vertices for airports located in Germany and uses the\n*fill* step to place them into the variable.\n\n``` java\ngerman = []\ng.V().has('airport','country','DE').fill(german)\n```\n\nWe can then use our list as you would expect. Remember that as we are\nrunning inside the Gremlin console we do not have to explicitly iterate\nthrough the list as you would if you were writing a standalone Groovy\napplication.\n\n``` java\n// How many results did we get back?\ngerman.size\n\n32\n\n// Query some values from one of the airports in the list\ngerman[0].values('city','code')\n\nFRA\nFrankfurt\n\n// Feed an entry from our list back into a traversal\ng.V(german[1]).values('city')\n\nMunich\n\ng.V(german[1]).out().count()\n\n237\n```\n\nTowards the end of the book, in the \\\"[Working with TinkerGraph from a\nGroovy application](#groovyapp)\\\" section, we will explore writing some\nstandalone Groovy code that can use the TinkerPop API and issue Gremlin\nqueries while running outside of the Gremlin Console as a standalone\napplication.",
        "children": [
          {
            "level": "4.4.1",
            "title": "4.4.1. Using a variable to feed a traversal {#varaus}",
            "content": "Sometimes it is very useful to store the result of a query in a variable\nand then, later on, use that variable to start a new traversal. You may\nhave noticed we did that in the very last example of the prior section\nwhere we fed the *german* variable back in to a traversal. By way of\nanother simple example, the code below stores the result of the first\nquery in the variable *austin* and then uses it to look for routes from\nAustin in second query. Notice how we do this by passing the variable\ncontaining the Austin vertex into the *V()* step.\n\n``` java\n austin=g.V().has('code','AUS').next()\n g.V(austin).out()\n```\n\nYou can take this technique one step further and pass an entire saved\nlist of vertices to *V()*. In the next example we first generate a list\nof all airports that are in Scotland and then pass that entire list into\n*V()* to first of all count how many routes there are from those\nairports and then we start another query that looks for any route from\nthose airports to airports in Germany.\n\n``` java\n// Find all airports in Scotland\na=g.V().hasLabel('airport').has('region','GB-SCT').toList()\n\n// How many routes from these airports?\ng.V(a).out().count()\n\n// How many of those routes end up in Germany?\ng.V(a).out().has('country','DE').values('code')\n```\n\nIn this example of using with variables to drive traversals, we again\ncreate a list of airports. This time we find all the airports in Texas.\nWe then use a Groovy *each* loop to iterate through the list. For each\nairport in the list we print the code of the starting airport and then\nthe codes of every airport that you can fly to from there.\n\n``` java\n// Find all of the airports in Texas\ntexas=g.V().has('region','US-TX').toList()\n\n// For each airport, print a list of all the airports that you can fly to from there.\ntexas.each {println it.values('code').next() + \"===>\" +\n                    g.V(it).out().values('code').toList()}\n```\n\nThis example, which is admittedly a bit contrived, we use a variable\ninside of a *has* step. We initially create a list containing all of the\nIATA codes for each airport in the graph. We then iterate through that\nlist and calculate how many outgoing routes there are from each place\nand print out a string containing the airport IATA code and the count\nfor that airport. Note that this could easily be done just using a\nGremlin query with no additional Groovy code. The point of this example\nis more to show another example of mixing Gremlin, Groovy and variables.\nKnowing that you can do this kind of thing may come in useful as you\nstart to write more complicated graph database applications that use\nGremlin. You will see this type of query done using just Gremlin in the\nsection called \\\"[Finding unwanted parallel edges](#unwantededges)\\\"\\\"\nlater in this book.\n\n``` java\nm=g.V().hasLabel('airport').values('code').toList()\nfor (a in m) println a + \" : \" + g.V().has('code',a).out().count().next()\n```\n\nLastly, here is an example that uses an array of values to seed a query.\n\n``` java\n['AUS','RDU','MCO','LHR','DFW'].\n     each {println g.V().has('code','JFK').outE().inV().\n                         has('code',it).path().by('code').by('dist').next()}\n```\n\nHere is the output from running the code.\n\n``` java\n[JFK, 1520, AUS]\n[JFK, 427, RDU]\n[JFK, 945, MCO]\n[JFK, 3440, LHR]\n[JFK, 1390, DFW]\n```",
            "children": []
          }
        ]
      },
      {
        "level": "4.5",
        "title": "4.5. Adding vertices, edges and properties {#addnodes}",
        "content": "So far in this book we have largely focussed on loading a graph from a\nfile and running queries against it. As you start to build your own\ngraphs you will not always start with a graph saved as a text file in\nGraphML, CSV, GraphSON or some other format. You may start with an empty\ngraph and incrementally add vertices and edges. Just as likely you may\nstart with a graph like the air routes graph, read from a file, but want\nto add vertices, edges and properties to it over time. In this section\nwe will explore various ways of doing just that.\n\nVertices and edges can be added directly to the graph using the *graph*\nobject or as part of a graph traversal. We will look at both of these\ntechniques over course of the following pages.",
        "children": [
          {
            "level": "4.5.1",
            "title": "4.5.1. Adding an airport (vertex) and a route (edge) {#_adding_an_airport_vertex_and_a_route_edge}",
            "content": "The following code uses the *graph* object that we created when we first\nloaded the *air-routes* graph to create a new airport vertex (node) and\nthen adds a route (edge) from it to the existing DFW vertex. We can\nspecify the label name (*airport*) and as many properties as we wish to\nwhile creating the vertex. In this case we just provide three. We can\nadditionally add and delete vertex properties after a vertex has been\ncreated. While using the *graph* object in this way works, it is\nstrongly recommended that the traversal source object *g* be used\ninstead and that vertices and edges be added using a traversal. Examples\nof how to do that are coming up next.\n\n``` java\n// Add an imaginary airport with a code of 'XYZ' and connect it to DFW\nxyz = graph.addVertex(label,'airport',\n                      'code','XYZ',\n                      'icao','KXYZ',\n                      'desc','This is not a real airport')\n\n// Find the DFW vertex\ndfw = g.V().has('code','DFW').next()\n\n// Create a route from our new airport to DFW\nxyz.addEdge('route',dfw)\n```\n\nIn many cases it is more convenient, and also recommended, to perform\neach of the previous operations using just the traversal object *g*. The\nfollowing example does just that. We first create a new airport vertex\nfor our imaginary airport and store its vertex in the variable *xyz*. We\ncan then use that stored value when we create the edge also using a\ntraversal. As with many parts of the Gremlin language, there is more\nthan one way to achieve the same results.\n\n``` java\n// Add an imaginary airport with a code of 'XYZ' and connect it to DFW\nxyz = g.addV('airport').property('code','XYZ').\n                        property('icao','KXYZ').\n                        property('desc','This is not a real airport').next()\n```\n\nNotice, in the code above, how each property step can be chained to the\nprevious one when adding multiple properties. Whether you need to do it\nwhile creating a vertex or to add and edit properties on a vertex at a\nlater date you can use the same *property* step.\n\n::: note\nIt is strongly recommended that the traversal source object *g* be used\nwhen adding, updating or deleting vertices and edges. Using the *graph*\nobject directly is not viewed as a TinkerPop best practice.\n:::\n\nWe can now add a route from DFW to XYZ. We are able to use our *xyz*\nvariable to specify the destination of the new route using a *to* step.\n\n``` java\n// Add a route from DFW to XYZ\ng.V().has('code','DFW').addE('route').to(xyz)\n```\n\nWe could have written the previous line to use a second *V()* step if we\nhad not previously saved anything in a variable. Note that while this\nuse of a second *V()* step will work locally, if you are sending queries\nto a Gremlin Server (a topic we will discuss later in this book) this\nsyntax is not supported and will not work.\n\n``` java\ng.V().has('code','DFW').addE('route').to(V().has('code','XYZ'))\n```\n\nWe might also want to add a returning route from XYZ back to DFW. We can\ndo this using the *from* step in a similar way as we used the *to* step\nabove.\n\n``` java\n// Add the return route back to DFW\ng.V().has('code','DFW').addE('route').from(xyz)\n```\n\nAnother way that we could have chosen to create our edge involves\nlabelling the \\\"XYZ\\\" vertex using an `as` step. The example below\ndemonstrates this. Notice also how a *V* step is used to start a new\ntraversal midway through the current one. The label created using the\n`as` step is used to instruct the `to` step about the target vertex for\nthe new edge.\n\n``` java\ng.V().has('code','XYZ').as('a').V().has('code','DFW').addE('route').to('a')\n```\n\n::: note\nIn earlier versions of Apache TinkerPop there was an `addOutE` step.\nThat step has since been deprecated and removed from the language in\nfavor of always using `addE`.\n:::\n\nYou will see a bigger example that uses *as* steps while creating\nvertices and edges in the \\\"[Quickly building a graph for\ntesting](#testgraph)\\\" section that is coming up soon.",
            "children": []
          },
          {
            "level": "4.5.2",
            "title": "4.5.2. Using a traversal to determine a new label name {#addlabeldynamic}",
            "content": "In TinkerPop 3.3.1 a new capability was added to the *addV* and *addE*\nsteps. This new capability allows us to use a traversal to determine\nwhat the label used by a new vertex or edge should be. Take a look at\nthe query below. We have seen this type of query used earlier in the\nbook. It simply tells us what label the vertex representing the Austin\n(AUS) airport has.\n\n``` java\ng.V().has('code','AUS').label()\n\nairport\n```\n\nWhat the new capability added in TinkerPop 3.3.1 allows us to do is\ninclude the traversal above inside of an *addV* step as shown below. The\nfirst string result returned by the provided traversal will be used as\nthe label name.\n\n``` java\ng.addV(V().has('code','AUS').label()).property('code','XYZ')\n\nv[53768]\n```\n\nWe can inspect the new vertex using *valueMap* to make sure that our\nlabel was correctly assigned.\n\n``` java\ng.V(53768).valueMap(true)\n\n[id:53768,code:[XYZ],label:airport]\n```\n\n::: tip\nThese features require that the graph database system you are using\nsupports a TinkerPop version of 3.3.1 or higher.\n:::\n\nWe can now do something similar to dynamically work out what the label\nshould be for an edge between our new airport and Austin.\n\n``` java\ng.V(53768).addE(V().has('code','AUS').outE().limit(1).label()).\n           to(V().has('code','AUS'))\n\ne[53770][53768-route->3]\n```\n\n::: note\nLater in the book we will build upon these concepts to show how the\nproperty keys and values from one vertex, as well as the label, can be\ncopied into a new vertex using a single query.\n:::\n\nOnce again, we can use a *valueMap* step to make sure our new edge label\nlooks OK.\n\n``` java\ng.E(53770).valueMap(true)\n\n[id:53770,label:route]\n```",
            "children": []
          },
          {
            "level": "4.5.3",
            "title": "4.5.3. Using a traversal to seed a property with a list {#proptraversal}",
            "content": "You can use the results of a traversal to create or update properties.\nThe example below creates a new property called *places* for the Austin\nairport vertex. The values of the property are the results of finding\nall of the places that you can travel to from that airport and folding\ntheir *code* values into a list.\n\n``` java\n// Add a list as a property value\ng.V().has('code','AUS').property('places',out().values('code').fold())\n```\n\nWe can use a *valueMap* step to make sure the property was created as we\nexpected it to be. As you can see a new property called *places* has\nbeen created containing as its value a list of codes.\n\n``` java\ng.V().has('code','AUS').valueMap('places')\n\n[places:[[YYZ, LHR, FRA, MEX, PIT, PDX, CLT, CUN, MEM, CVG, IND, MCI, DAL, STL, ABQ, MDW, LBB, HRL, GDL, PNS, VPS, SFB, BKG, PIE, ATL, BNA, BOS, BWI, DCA, DFW, FLL, IAD, IAH, JFK, LAX, MCO, MIA, MSP, ORD, PHX, RDU, SEA, SFO, SJC, TPA, SAN, LGB, SNA, SLC, LAS, DEN, MSY, EWR, HOU, ELP, CLE, OAK, PHL, DTW]]]\n```\n\nTo gain access to these values from your code or Gremlin console\nqueries, we can use the *next* step. A simple example is given below\nwhere *values* is used to retrieve the values of the *places* property\nand then we use *size* to see how many entries there are in the list.\n\n``` java\ng.V().has('code','AUS').values('places').next().size()\n\n59\n```\n\nOnce we have access to the list of values we can access them using the\nnormal Groovy array syntax. The example below returns the three values\nwith an index between 2 and 4.\n\n``` java\ng.V().has('code','AUS').values('places').next()[2..4]\n\nFRA\nMEX\nPIT\n```",
            "children": []
          },
          {
            "level": "4.5.4",
            "title": "4.5.4. Using *inject* to specify new vertex ID values {#injectid}",
            "content": "If the graph database you are using supports user provided ID values,\nyou can use an *inject* step as one way to specify what you want the ID\nvalue of a new vertex to be. For example consider the example below.\n\n``` java\ng.inject(99999L).addV().property(id,identity())\n\nv[99999]\n```\n\nYou can also specify more than one ID value if you want to create\nmultiple vertices.\n\n``` java\ng.inject(99997L,99998L).addV().property(id,identity())\n\nv[99997]\nv[99998]\n```\n\nI chose to show use of *inject* as it provides an interesting example.\nHowever, it is not required to create new IDs in this way. Both of the\nexamples below are also valid ways to do the same thing. The first\nexample just uses a literal value.\n\n``` java\ng.addV().property(id,99999L)\n\nv[99999]\n```\n\nAlternatively we could pass in a variable.\n\n``` java\nn=99999L;\ng.addV().property(id,n)\n\nv[99999]\n```\n\n::: note\nRemember that these methods of specifying an ID value will only work if\nthe graph database that you are using allows you to specify your own ID\nvalues. This varies by graph database implementation and you should\ncheck the documentation for the system you are using before assuming\nthat you can create your own custom ID values.\n:::\n\nEven if the graph database that you are using does support user provided\nID values you should check to see what data types can be used for them.\nAll of the examples above used LONG values. However, as one example,\nsome graph databases that do allow you to specify custom IDs only\nsupport String values. So the key thing is to check the documentation\nbefore you start building your graph.\n\nEven if a graph database does support custom ID values, if you try to\ncreate a vertex using an ID that already exists the operation will fail.\nThe example below shows what happens when we try to add a vertex using\nan ID that already exists to a TinkerGraph.\n\n``` java\ng.inject(99999L).addV().property(id,identity())\n\nVertex with id already exists: 99999\n```",
            "children": []
          },
          {
            "level": "4.5.5",
            "title": "4.5.5. Quickly building a graph for testing {#testgraph}",
            "content": "Sometimes for testing and for when you want to report a problem or ask\nfor help on a mailing list it is handy to have a small standalone graph\nthat you can use. The code below will create a mini version of the air\nroutes graph in the Gremlin Console. Note how all of the vertices and\nedges are created in a single query with each step joined together.\n\n``` java\ngraph=TinkerGraph.open()\ng=graph.traversal()\ng.addV('airport').property('code','AUS').as('aus').\n  addV('airport').property('code','DFW').as('dfw').\n  addV('airport').property('code','LAX').as('lax').\n  addV('airport').property('code','JFK').as('jfk').\n  addV('airport').property('code','ATL').as('atl').\n  addE('route').from('aus').to('dfw').\n  addE('route').from('aus').to('atl').\n  addE('route').from('atl').to('dfw').\n  addE('route').from('atl').to('jfk').\n  addE('route').from('dfw').to('jfk').\n  addE('route').from('dfw').to('lax').\n  addE('route').from('lax').to('jfk').\n  addE('route').from('lax').to('aus').\n  addE('route').from('lax').to('dfw')\n```\n\n::: note\nThe form of *addV* that used to allow creation of a vertex and a\nproperty using something like\n*g.addV(label,\\\"airport\\\",\\\"code\\\",\\\"AUS\\\")* is now deprecated and\nshould not be used.\n:::",
            "children": []
          },
          {
            "level": "4.5.6",
            "title": "4.5.6. Adding vertices and edges using a loop {#addloop}",
            "content": "Sometimes it is more efficient to define the details of the vertices or\nedges that you plan to add to the graph in an array and then add each\nvertex or edge using a simple *for* loop that iterates over it. The\nfollowing example adds our imaginary airports directly to the graph\nusing such a loop. Notice that we do not have to specify the ID that we\nwant each vertex to have. The graph will assign a unique ID to each new\nvertex for us.\n\n``` java\nvertices = [[\"WYZ\",\"KWYZ\"],[\"XYZ\",\"KXYZ\"]]\nfor (a in vertices) {graph.addVertex(label,\"airport\",\"code\",a[0],\"iata\",a[1])}\n```\n\nWe could also have added the vertices using the traversal object *g* as\nfollows. Notice the call to *next()*. Without this the vertex creation\nwill not work as expected.\n\n``` java\nvertices = [[\"WYZ\",\"KWYZ\"],[\"XYZ\",\"KXYZ\"]]\nfor (a in vertices) {g.addV(\"airport\").property(\"code\",a[0],\"iata\",a[1]).next()}\n```\n\nThis technique of creating vertices and/or edges using a *for* loop can\nalso be useful when working with graphs remotely over HTTP connections.\nIt is a very convenient way to combine a set of creation steps into a\nsingle REST API call.\n\nIf you prefer a more Groovy like syntax you can also do this.\n\n``` java\nvertices = [[\"WYZ\",\"KWYZ\"],[\"XYZ\",\"KXYZ\"]]\nvertices.each {g.addV(\"airport\").property(\"code\",it[0],\"iata\",it[1]).next()}\n```",
            "children": []
          },
          {
            "level": "4.5.7",
            "title": "4.5.7. Using *coalesce* to only add a vertex if it does not exist {#coaladdv}",
            "content": "In the [Combining with a value](#coalconst) section we looked at how\ncoalesce could be used to return a constant value if the other entities\nthat we were looking for did not exist. We can reuse that pattern to\nproduce a traversal that will only add a vertex to the graph if that\nvertex has not already been created.\n\nLet's assume we wanted to add a new airport, with the code *\\\"XYZ\\\"* but\nwe are not sure if the airport might have already been added.\n\nWe can check to see if the airport exists, using a basic *has* step.\n\n``` java\ng.V().has('code','XYZ')\n```\n\nIf it does not exist yet, which in this case it does not, nothing will\nbe returned. We could go one step further and change the query to return\nan empty list *\\[\\]* if the airport does not exist by adding a *fold*\nstep to the query.\n\n``` java\ng.V().has('code','XYZ').fold()\n\n[]\n```\n\nNow that we have a query that can return an empty list if a vertex does\nnot exist we can take advantage of this in a *coalesce* step. The query\nbelow looks to see if the airport already exists and passes the result\nof that into a *coalesce* step. Remember, *coalesce* will return the\nresult of the first traversal it looks at that returns a good result. We\ncan make the first parameter passed to *coalesce* and *unfold* step.\nThis way in the case where the airport does not exist, *unfold* will\nreturn nothing and so *coalesce* will attempt the second step. In this\ncase our second step creates a vertex for the airport *\\\"XYZ\\\"*.\n\n``` java\ng.V().has('code','XYZ').fold().coalesce(unfold(),addV().property('code','XYZ'))\n\nv[53865]\n```\n\nAs you can see the query above created a new vertex with an ID of\n*53865* as the *XYZ* airport did not already exist. However, if we run\nthe same query again, notice that we get the same vertex back that we\njust created and not a new one. This is because this time, the\n*coalesce* step **does** find a result from the *unfold* step and so\ncompleted before attempting the *addV* step.\n\n``` java\ng.V().has('code','XYZ').fold().coalesce(unfold(),addV().property('code','XYZ'))\n\nv[53865]\n```",
            "children": []
          },
          {
            "level": "4.5.8",
            "title": "4.5.8. Using *coalesce* to derive an *upsert* pattern {#upsert}",
            "content": "Using *coalesce* in this way provides us with a nice pattern for a\ncommonly performed task of checking to see if something already exists\nbefore we try to update it and otherwise create it. This is often called\nan *\\\"upsert\\\"* pattern as the operation potentially updates or inserts\na vertex based on its existence or not.\n\nThe query below is perhaps a better example of an *\\\"upsert\\\"*. The\nquery looks to see if the vertex with an ID of 3 already exists. If it\ndoes it updates the *runways* property of that vertex be the value 3. If\nit does not exist it creates a new vertex and the property. As vertex\nv\\[3\\] already exists that is what the query returns, having first\nupdated the *runways* property.\n\n``` java\ng.V(3).fold().\n       coalesce(unfold().property('runways',3),\n       addV('airport').property('runways',3))\n\nv[3]\n```\n\nIf we now examine the properties of the vertex v\\[3\\] we can see that\nthe *runways* value has been set to 3.\n\n``` java\ng.V(3).valueMap().unfold()\n\ncountry=[US]\ncode=[AUS]\nlongest=[12250]\ncity=[Austin]\nelev=[542]\nicao=[KAUS]\nlon=[-97.6698989868164]\ntype=[airport]\nregion=[US-TX]\nrunways=[3]\nlat=[30.1944999694824]\ndesc=[Austin Bergstrom International Airport]\n```\n\nIn the air routes graph there is no vertex with an ID of 9999999. So if\nwe rerun the previous *\\\"upsert\\\"* query, this time a new vertex will be\ncreated.\n\n``` java\ng.V(9999999).fold().\n             coalesce(unfold().property('runways','3'),\n             addV('airport').property('runways',3))\n\nv[57343]\n```\n\nIf we look at the *valueMap* for the new vertex we can see that it was\ncreated as we would have expected.\n\n``` java\ng.V(57343).valueMap().unfold()\n\nrunways=[3]\n```\n\nThis technique is currently the recommended way of doing *\\\"upsert\\\"*\noperations with Gremlin.",
            "children": []
          },
          {
            "level": "4.5.9",
            "title": "4.5.9. Creating one vertex based on another {#vertexcopy}",
            "content": "It is sometimes useful to be able to create a new vertex using the label\nand properties from an existing vertex. We have already looked, in the\n\\\"[Using a traversal to determine a new label name](#addlabeldynamic)\\\"\nsection, at some ways to create a new label using the value of other\nlabels but we have not yet looked at how to clone the properties from\none vertex onto another. A technique for doing that is discussed in the\n\\\"[Making a copy of the DFW vertex](#dfwcopy)\\\" section. Feel free to\nskip ahead but be aware that the techniques used in that section have\nnot yet been fully covered so you may want to also take a look at some\nother sections along the way.",
            "children": []
          }
        ]
      },
      {
        "level": "4.6",
        "title": "4.6. Deleting vertices, edges and properties {#deleting}",
        "content": "So far in this book we have looked at several examples where we created\nnew vertices, edges and properties but we have not yet looked at how we\ncan delete them. Gremlin provides the *drop* step that we can use to\nremove things from a graph.",
        "children": [
          {
            "level": "4.6.1",
            "title": "4.6.1. Deleting a vertex {#_deleting_a_vertex}",
            "content": "In some of our earlier examples we created a fictitious airport vertex\nwith a code of *XYZ* and added it to the air routes graph. If we now\nwanted to delete it we could use the following Gremlin code. Note that\nremoving the vertex will also remove any edges we created connected to\nthat vertex.\n\n``` java\n// Remove the XYZ vertex\ng.V().has('code','XYZ').drop()\n```",
            "children": []
          },
          {
            "level": "4.6.2",
            "title": "4.6.2. Deleting an edge {#deledge}",
            "content": "We can also use *drop* to remove specific edges. The following code will\nremove the flights, in both directions between AUS and LHR.\n\n``` java\n// Remove the flight from AUS to LHR (both directions).\ng.V().has('code','AUS').outE().as('e').inV().has('code','LHR').select('e').drop()\ng.V().has('code','LHR').outE().as('e').inV().has('code','AUS').select('e').drop()\n```",
            "children": []
          },
          {
            "level": "4.6.3",
            "title": "4.6.3. Deleting a property {#delprop}",
            "content": "Lastly, we can use *drop* to delete a specific property value from a\nspecific vertex. Let's start by querying the properties defined by the\n*air-routes* graph for the San Francisco airport.\n\n``` java\ng.V().has('code','SFO').valueMap()\n\n[country:[US],code:[SFO],longest:[11870],city:[San Francisco],elev:[13],icao:[KSFO],lon:[-122.375],type:[airport],region:[US-CA],runways:[4],lat:[37.6189994812012],desc:[San Francisco International Airport]]\n```\n\nLet's now drop the *desc* property and re-query the property values to\nprove that it has been deleted.\n\n``` java\ng.V().has('code','SFO').properties('desc').drop()\n\ng.V().has('code','SFO').valueMap()\n\n[country:[US],code:[SFO],longest:[11870],city:[San Francisco],elev:[13],icao:[KSFO],lon:[-122.375],type:[airport],region:[US-CA],runways:[4],lat:[37.6189994812012]]\n```\n\nIf we wanted to delete all of the properties currently associated with\nthe SFO airport vertex we could do that as follows.\n\n``` java\ng.V().has('code','SFO').properties().drop()\n```",
            "children": []
          },
          {
            "level": "4.6.4",
            "title": "4.6.4. Removing all the edges or vertices in the graph {#_removing_all_the_edges_or_vertices_in_the_graph}",
            "content": "This may not be something you want to do very often, but should you wish\nto remove every edge in the graph you could do it, using the traversal\nobject, *g*, as follows. Note that for very large graphs this may not be\nthe most efficient way of doing it depending upon how the graph store\nhandles this request.\n\n``` java\n// Remove all the edges from the graph\ng.E().drop()\n```\n\nYou could also use the *graph* object to do this. The code below uses\nthe graph object to retrieve all of the edges and then iterates over\nthem dropping them one by one. Again for very large graphs this may not\nbe an ideal approach as this requires reading all of the edge\ndefinitions into memory. Note that in this case we call the *remove*\nmethod rather than use *drop* as we are not using a graph traversal in\nthis case.\n\n``` java\n// Remove all the edges from the graph\ngraph.edges().each{it.remove()}\n```\n\nYou could also delete the whole graph, vertices and edges, by deleting\nall of the vertices!\n\n``` java\n// Delete the entire graph!\ng.V().drop()\n```",
            "children": []
          }
        ]
      },
      {
        "level": "4.7",
        "title": "4.7. Property keys and values revisited {#pkvrevisited}",
        "content": "We have already looked, earlier in the book, at numerous queries that\nretrieve, create or manipulate in some way the value of a given\nproperty. There are still however a few things that we have not covered\nin any detail concerning properties. Most of the property values we have\nlooked at so far have been simple types such as a String or an Integer.\nIn this section we shall look more closely at properties and explain how\nthey can in fact be used to store lists and sets of values. We will also\nintroduce in this section the concept of a property ID.",
        "children": [
          {
            "level": "4.7.1",
            "title": "4.7.1. The *Property* and *VertexProperty* interfaces {#vertexprop}",
            "content": "In a TinkerPop 3 enabled graph, all properties are implementations of\nthe *Property* interface. Vertex properties implement the\n*VertexProperty* interface which itself extends the *Property*\ninterface. These interfaces are documented as part of the Apache\nTinkerPop 3 JavaDoc. The interface defines the methods that you can use\nwhen working with a vertex property object in your code. One important\nthing to note about vertex properties is that they are immutable. You\ncan create them but once created they cannot be updated.\n\nWe will look more closely at the Java interfaces that TinkerPop 3\ndefines in the \\\"[Working with TinkerGraph from a Java\nApplication](#javatinker)\\\" section a bit later in this book.\n\nThe VertexProperty interface does not define any \\\"setter\\\" methods\nbeyond the basic constructor itself. Your immediate reaction to this is\nlikely to be \\\"but I know you can change a property's value using the\n*property* step\\\". Indeed we have already discussed doing just that in\nthis book. However, behind the scenes, what actually happens when you\nchange a property, is that a new property object is created and used to\nreplace the prior one. We will examine this more in a minute but first\nlet's revisit a few of the basic concepts of properties.\n\nIn a *property graph* both vertices and edges can contain one or more\nproperties. We have already seen a query like the one below that\nretrieves the values from each of the property keys associated with the\nDFW airport vertex.\n\n``` java\ng.V().has('airport','code','DFW').values()\n\nUS\nDFW\n13401\nDallas\n607\nKDFW\n-97.0380020141602\nairport\nUS-TX\n7\n32.896800994873\nDallas/Fort Worth International Airport\n```\n\nWhat we have not mentioned so far, however, is that the previous query\nis a shortened form of this one.\n\n``` java\ng.V().has('airport','code','DFW').properties().value()\n\nUS\nDFW\n13401\nDallas\n607\nKDFW\n-97.0380020141602\nairport\nUS-TX\n7\n32.896800994873\nDallas/Fort Worth International Airport\n```\n\nIf we wanted to retrieve the VertexProperty (*vp*) objects for each of\nthe properties associated with the DFW vertex we could do that too. In a\nlot of cases it will be sufficient just to use *values* or *valueMap* to\naccess the values of one or more properties but there are some cases, as\nwe shall see when we look at property IDs, where having access to the\nvertex property object itself is useful.\n\n``` java\ng.V().has('airport','code','DFW').properties()\n\nvp[country->US]\nvp[code->DFW]\nvp[longest->13401]\nvp[city->Dallas]\nvp[elev->607]\nvp[icao->KDFW]\nvp[lon->-97.0380020141602]\nvp[type->airport]\nvp[region->US-TX]\nvp[runways->7]\nvp[lat->32.896800994873]\nvp[desc->Dallas/Fort Worth In]\n```\n\nWe have already seen how each property on a vertex or edge is\nrepresented as a key and value pair. If we wanted to retrieve a list of\nall of the property keys associated with a given vertex we could write a\nquery like the one below that finds all of the property keys associated\nwith the DFW vertex in the *air-routes* graph.\n\n``` java\ng.V().has('airport','code','DFW').properties().key()\n\ncountry\ncode\nlongest\ncity\nelev\nicao\nlon\ntype\nregion\nrunways\nlat\ndesc\n```\n\nWe could likewise find the names, with duplicates removed, of any\nproperty keys associated with any outgoing edges from the DFW vertex\nusing this query. Note that edge properties are implementations of\n*Property* and not *VertexProperty*.\n\n``` java\ng.V().has('code','DFW').outE().properties().key().dedup()\n\ndist\n```\n\nWe can use the fact that we now know how to specifically reference both\nthe key and value parts of any property to construct a query like the\none below that adds up the total length of all the longest runway values\nand number of runways in the graph and groups them by property key first\nand sum of the values second.\n\n``` java\ng.V().hasLabel(\"airport\").\n      properties(\"runways\",\"longest\").\n      group().by(key).by(value().sum())\n\n[longest:25497644, runways:4816]\n```",
            "children": []
          },
          {
            "level": "4.7.2",
            "title": "4.7.2. The *propertyMap* traversal step {#propmap}",
            "content": "We have previously used the *valueMap* step to produce a map of\nkey/value pairs for all of the properties associated with a vertex or\nedge. There is also a *propertyMap* step that can be used that yields a\nsimilar result but the map includes the vertex property objects for each\nproperty.\n\n``` java\ng.V().has('code','AUS').propertyMap()\n```\n\nHere are the properties returned.\n\n``` java\n[country:[vp[country->US]], code:[vp[code->AUS]], longest:[vp[longest->12250]], city:[vp[city->Austin]], lon:[vp[lon->-97.6698989868164]], type:[vp[type->airport]], places:[vp[places->[YYZ, LHR, FRA, MEX,]], elev:[vp[elev->542]], icao:[vp[icao->KAUS]], region:[vp[region->US-TX]], runways:[vp[runways->2]], lat:[vp[lat->30.1944999694824]], desc:[vp[desc->Austin Bergstrom Int]]]\n```",
            "children": []
          },
          {
            "level": "4.7.3",
            "title": "4.7.3. Properties have IDs too {#propid}",
            "content": "We have seen many examples already that show how both vertices and edges\nhave a unique ID. What may not have been obvious however is that\nproperties also have an ID. Unlike vertex and edge IDs property IDs are\nnot guaranteed to be unique across the graph. Certainly with TinkerGraph\nI have encountered cases where a vertex and a property share the same\nID. This is not really an issue because they are used in different ways\nto access their associated graph element.\n\nThe query below returns the vertex property object (vp) for any property\nin the graph that has a value of *London*.\n\n``` java\ng.V().properties().hasValue('London')\n```\n\nThe query finds several London values.\n\n``` java\nvp[city->London]\nvp[city->London]\nvp[city->London]\nvp[city->London]\nvp[city->London]\nvp[city->London]\n```\n\nAt first glance, each of the values returned above looks identical.\nHowever, let's now query their ID values.\n\n``` java\ng.V().properties().hasValue('London').id()\n```\n\nAs you can see each property has a different, and unique, ID.\n\n``` java\n583\n595\n1051\n1123\n2467\n7783\n```\n\nWe can use these ID values in other queries in the same way as we have\nfor vertices and edges in some of our earlier examples.\n\n``` java\ng.V().properties().hasId(583)\n\nvp[city->London]\n```\n\nWe can query the value of this property as you would expect.\n\n``` java\ng.V().properties().hasId(583).value()\n\nLondon\n```\n\nWe can retrieve the name of the property key as follows.\n\n``` java\ng.V().properties().hasId(583).key()\n\ncity\n```\n\nWe could also have used *label* instead of *key*\n\n``` java\ng.V().properties().hasId(583).label()\n\ncity\n```\n\nWe can also find out which element (vertex or edge) that this property\nbelongs to.\n\n``` java\ng.V().properties().hasId(583).next().element()\n\nv[49]\n```\n\nWe can also look at other property values of the element containing our\nproperty with an ID of 583.\n\n``` java\ng.V().properties().hasId(583).next().element().values('desc')\n\nLondon Heathrow\n```\n\nShould you need to you can also find out which graph this property is\npart of. In this case it is part of a TinkerGraph.\n\n``` java\ng.V().has('airport','code','DFW').properties('city').next().graph()\n\ntinkergraph[vertices:3619 edges:50148]\n```\n\nTo further show that each property has an ID the following code\nretrieves a list of all the vertex properties associated with vertex\n*V(3)* and prints out the property key along with its corresponding ID.\n\n``` java\np = g.V(3).properties().toList()\np.each {println it.key + \"\\t:\" + it.id}\n\ncountry :28\ncode    :29\nlongest :30\ncity    :31\nelev    :32\nicao    :33\nlon     :34\ntype    :35\nregion  :36\nrunways :37\nlat     :38\ndesc    :39\n```\n\n::: note\nIf you update a property, its ID value will also be changed as you have\nin reality replaced the property with a new one which is allocated a new\nID.\n:::\n\nTake a look at the example below. First of all we query the ID of the\n*city* property from vertex *V(4)*. Next we change its value to be\n*newname* and then query the property ID again. Note that the ID has\nchanged. As mentioned above, vertex properties are immutable. When you\nupdate a property value using the *property* step, a new property object\nis created that replaces the prior one.\n\n``` java\ng.V(4).properties('city').id()\n\n43\n\ng.V(4).property('city','newname')\n\ng.V(4).properties('city').id()\n\n53361\n```\n\nThe fact that every property in a graph has an ID can improve\nperformance of accessing properties, especially in large graphs.",
            "children": []
          },
          {
            "level": "4.7.4",
            "title": "4.7.4. Attaching multiple values (lists or sets) to a single property {#listprop}",
            "content": "A vertex property value can be a basic type such as a String or an\nInteger but it can also be something more sophisticated such as a Set or\na List containing multiple values. You can think of these values as\nbeing an array but depending on how you create them you have to work\nwith them differently. In this section we will look at how we can create\nmultiple values for a single property key. Such values can be setup when\nthe vertex is first created or added afterwards. These more complex type\nof property values are not supported on edges.\n\nIf we wanted to store the IATA and ICAO codes for the Austin airport in\na list associated with a single property rather than as separate\nproperties we could have created them when we created the Austin vertex\nfollows. You can also add properties to an existing vertex that have\nlists of values. We will look at how to do that later in this section.\n\n``` java\ng.addV().property('code','AUS').property('code','KAUS')\n```\n\n::: note\nThe version of *addV* that allowed you to specify something like\n*g.addV(\\'code*,*AUS*,*code*,*KAUS*)\\' is now deprecated and should not\nbe used.\n:::\n\nBy creating the *code* property in this way, its cardinality type is now\neffectively *LIST* rather than *SINGLE*. While working with TinkerGraph\nwe do not need to setup explicit schemas for our property types.\nHowever, once we start working with a more sophisticated graph system\nsuch as JanusGraph, that is something that we will both want and need to\nbe able to do. We cover the topic of cardinality in detail in the \\\"[The\nJanusGraph management API](#janusmgmt)\\\" section later in the book.\n\nNow that we have created the *code* property to have a list of values we\ncan query either one of the values in the list. If we look at the value\nmap we get back from the following example queries you can see both\nvalues in the list we associated with the property *code*.\n\n``` java\ng.V().has('code','AUS').valueMap()\n\n[code:[AUS,KAUS]]\n\ng.V().has('code','KAUS').valueMap()\n\n[code:[AUS,KAUS]]\n```\n\nwe can also query the values as normal.\n\n``` java\ng.V().has('code','AUS').values()\n\nAUS\nKAUS\n```\n\nWe can also use the *properties* step to get the result back as vertex\nproperties (vp). We discuss vertex properties in detail in the \\\"[The\nand interfaces](#vertexprop)\\\" section.\n\n``` java\ng.V().has('code','AUS').properties()\n\nvp[code->AUS]\nvp[code->KAUS]\n```\n\nFor completeness we could also do this.\n\n``` java\ng.V().properties().hasValue('AUS')\n\nvp[code->AUS]\n```",
            "children": []
          },
          {
            "level": "4.7.5",
            "title": "4.7.5. A word of caution - behavior differences with *property* {#propertycaution}",
            "content": "::: formalpara-title\n**Be aware!**\n:::\n\nThere is a subtlety to be aware of when using *property*. What happens\ncan vary depending on the context in which it is used. Only when done as\npart of an *addV* step immediately followed by multiple *property* steps\nusing the same key value will a list be created. Look at the two\nexamples below. They do not produce the same results.\n\n``` java\ng.addV().property('one','hi').\n         property('one','hello').\n         property('two','goodbye').\n         property('one','hello again').\n         valueMap()\n\n[one:[hi,hello,hello again],two:[goodbye]]\n```\n\nSo our first query create a property with a key called *one* followed by\na list containing *\\[hi,hello,hello again\\]*. Let's do the same test\nagain but this time create the vertex first and use an already created\nvertex to add properties to.\n\n``` java\nv = g.addV().next()\n\ng.V(v).property('one','hi').\n       property('one','hello').\n       property('two','goodbye').\n       property('one','hello again').\n       valueMap()\n\n[one:[hello again],two:[goodbye]]\n```\n\nThis time, as we were not creating the vertex as part of the same set of\nsteps, the behavior changes. Each time the property key of *one* is used\nthe existing value is replaced rather than being added as part of a\nlist. I have seen this behavior cause confusion more than once and it is\nsomething to be aware of! In the next section we will ask Gremlin to\nexplain this behavior to us!",
            "children": []
          },
          {
            "level": "4.7.6",
            "title": "4.7.6. What did Gremlin do? - introducing *explain* {#explainstep}",
            "content": "If you ever want to know how Gremlin compiles your query into a form\nthat it is able to execute you can ask it to tell you by adding an\n*explain* step to the end of your query. The query will not execute,\ninstead you will be shown how Gremlin decided to optimize your query. It\nactually shows you all the choices it considered but in the examples\nbelow I am just going to show the one it picked in each case.\n\nSo, thinking about our previous discussion of how *property* works\ndifferently depending upon the context, if you were to use the *explain*\nstep to have Gremlin show us the way it is going to execute our query\nyou can see clearly the difference between the two forms. I have\ntruncated the output to keep things simple.\n\nHere is what Gremlin shows us for the first query when we use an\n*explain* step. As you can see our query has been compiled into an\n*AddVertexStep* with two properties one of which is a list.\n\n``` java\ng.addV().property('one','hi').\n         property('one','hello').\n         property('two','goodbye').\n         property('one','hello again').\n         explain()\n\nFinal Traversal    [AddVertexStartStep({one=[hi, hello, hello\n                      again], two=[goodbye]})]\n```\n\nNow if we look at the case where we have already created a vertex let's\nsee what *explain* returns. What we find is that this time Gremlin has\ncompiled our query to a *TinkerGraphStep* and is handling each property\none by one. This has the result that each time the same key is reused,\nthe previous value is replaced.\n\n``` java\ng.V(v).property('one','hi').\n       property('one','hello').\n       property('two','goodbye').\n       property('one','hello again').\n       explain()\n\nFinal Traversal  [TinkerGraphStep(vertex,[v[54800]]),\n                    AddPropertyStep({value=[hi], key=[one]}),\n                    AddPropertyStep({value=[hello], key=[one]}),\n                    AddPropertyStep({value=[goodbye], key=[two]}\n                    ), AddPropertyStep({value=[hello again], key=[one]})]\n```\n\nIf you need to work with properties and treat them as lists once the\nvertex has been created, you need to explicitly add the *list* keyword\nas part of the *property* step as we shall see in the next section.",
            "children": []
          },
          {
            "level": "4.7.7",
            "title": "4.7.7. Updating properties stored in a list {#updatelist}",
            "content": "So now we know how to create a vertex with property values in a list we\nneed a way to update those properties. We can do this using a special\nform of the *property* step where the first parameter is *list* to show\nthat what follows are updates to the existing list and not replacements\nfor the whole list.\n\nThe example below adds another code that is sometimes used when talking\nabout the Austin airport to our list of codes. If we left off the *list*\nparameter the whole property would be overwritten with a value of\n*ABIA*.\n\n``` java\ng.V().has('code','AUS').property(list,'code','ABIA')\n```\n\nIf we query the properties again we can see that there are now three\nvalues for the *code* property.\n\n``` java\ng.V().has('code','AUS').properties()\nvp[code->AUS]\nvp[code->KAUS]\nvp[code->ABIA]\n```\n\nWe can observe the same thing by looking at our *valueMap* results\nagain.\n\n``` java\ng.V().has('code','AUS').valueMap()\n[code:[AUS,KAUS,ABIA]]\n```\n\nIf we want to delete one of the properties from the list we can do it\nusing *drop*. If we look the value map after dropping *ABIA* we can\nindeed see that it is gone from the list.\n\n``` java\ng.V().has('code','AUS').properties().hasValue('ABIA').drop()\n\ng.V().has('code','AUS').valueMap()\n[code:[AUS,KAUS]]\n```\n\nIf we want to drop an entire property containing one or more values we\ncan do it as follows.\n\n``` java\ng.V().has('code','AUS').properties('code').drop()\n```\n\nTo add multiple values to the same property key in the same query we\njust need to chain the *property* steps together as shown below.\n\n``` java\ng.V().has('code','AUS').\n      property(list,'desc','Austin Airport').\n      property(list,'desc','Bergstrom')\n```\n\nThis technique can be used to update an existing property that already\nhas a list of values or to add a new property with a list of values.\n\nThe same value can appear more than once with a property that has LIST\ncardinality. The code fragment below creates a new vertex, with some\nduplicate values associated with the *dups* property.\n\n``` java\ng.addV('test').property('dups','one').property('dups','two').property('dups','one')\n\ng.V().hasLabel('test').valueMap()\n\n[dups:[one,two,one]]\n```\n\nWe can add additional duplicate values after the vertex has been\ncreated.\n\n``` java\ng.V().hasLabel('test').property(list,'dups','two')\n\ng.V().hasLabel('test').valueMap()\n\n[dups:[one,two,one,two]]\n```",
            "children": []
          },
          {
            "level": "4.7.8",
            "title": "4.7.8. Creating properties that store sets {#propsets}",
            "content": "So far we have just created values in a list that have *LIST*\ncardinality which means that duplicate values are allowed. If we wanted\nto prevent that from happening we can use the *set* keyword when adding\nproperties to force a cardinality of *SET*.\n\nIn the example below we create a new property called *hw* for vertex\n*V(3)* with multiple values but using the *set* keyword rather than the\n*list* keyword that we have used previously. We then look at the\nvalueMap for the *hw* property to check that inded our set was created.\n\n``` java\ng.V(3).property(set,'hw','hello').property(set,'hw','world')\n\ng.V(3).valueMap('hw')\n\n[hw:[hello,world]]\n```\n\nLet's now test that our set is really working as a set by adding a\ncouple of additional values. Note that we have already added the value\n*hello* in the prior steps so with the cardinality being *SET* we expect\nthat value to be ignored as there is already a value of *hello* in the\nset. We again display the valueMap to prove that the set only has unique\nvalues in it.\n\n``` java\ng.V(3).property(set,'hw','hello').property(set,'hw','apple')\n\ng.V(3).valueMap('hw')\n\n[hw:[hello,world,apple]]\n```",
            "children": []
          },
          {
            "level": "4.7.9",
            "title": "4.7.9. One more note about sets and lists {#setlistnote}",
            "content": "Note that the other examples we have shown in this section are not the\nsame as just adding a list directly as a property value. In the example\nbelow the entire list is treated as a single value.\n\n``` java\ng.V().has('code','AUS').property('x',['AAAA','BBBB'])\n\ng.V().has('code','AUS').valueMap('x')\n\n[x:[[AAAA,BBBB]]]\n```",
            "children": []
          },
          {
            "level": "4.7.10",
            "title": "4.7.10. Adding properties to other properties (meta properties) {#metaprop}",
            "content": "TinkerPop 3 introduced the ability to add a property to another\nproperty. Think of this in a way as being able to add a bit of metadata\nabout a property to the property itself. This capability, not\nsurprisingly, is often referred to as *\\\"adding a meta property to a\nproperty\\\"*. There are a number of use cases where this capability can\nbe extremely useful. Common ones might be adding a date that a property\nwas last updated or perhaps adding access control information to a\nproperty.\n\nThe example below adds a meta property with a key of *date* and a value\nof *6/6/2017* to the property with a key of *code* and a value of *AUS*.\n\n``` java\ng.V().has('code','AUS').properties().hasValue('AUS').property('date','6/6/2017')\n```\n\nIf you wanted to add the date to the *code* property regardless of its\ncurrent value, then you could just do this.\n\n``` java\ng.V().has('code','AUS').properties('code').property('date','6/6/2017')\n```\n\nWe can retrieve all of the meta properties on a specific property, such\nas the *code* property as follows.\n\n``` java\ng.V().has('code','AUS').properties('code').properties()\n\np[date->6/6/2017]\n```\n\nIf you want to find all the properties associated with the AUS vertex\nthat have a meta property with a date of *6/6/2017* you can do that as\nfollows.\n\n``` java\ng.V().has('code','AUS').properties().has('date','6/6/2017')\n\nvp[code->AUS]\n```\n\nWe can query for a specific meta property as follows, which will return\nany meta properties that have a key of *date*.\n\n``` java\ng.V().has('code','AUS').properties().hasValue('AUS').properties('date')\n\np[date->6/6/2017]\n```\n\nYou can add multiple meta properties to a property while creating it.\nThe following will add a property called *comment* to vertex *V(3)* and\nalso add two meta properties to it representing the date the comment was\nmade and who made it.\n\n``` java\ng.V(3).property('comment','I like this airport','date','6/6/2017','user','Kelvin')\n```\n\nWe can query the graph to make sure everything worked as expected.\n\n``` java\ng.V(3).properties('comment')\n\nvp[Comment->I like this airport]\n\ng.V(3).properties('comment').properties()\n\np[date->6/6/2017]\np[user->Kelvin]\n```\n\nYou can use *drop* to remove meta properties but take care when doing\nso. Take a look at the query below, which looks like it might drop the\nmeta property *date*, but will in fact drop the whole vertex.\n\n``` java\ng.V().has('code','AUS').properties().hasValue('AUS').property('date','6/6/2017').drop()\n```\n\nTo remove a single meta property we need to use drop in this way\n\n``` java\n g.V().has('code','AUS').properties('code').properties('date').drop()\n```\n\nNote that you cannot chain meta properties together endlessly. The main\nproperties on a vertex are *VertexProperty* types. The meta property is\na *Property* type and you cannot add another property to those. You can\nhowever add more than one meta property to the same vertex property.\n\nSo as mentioned above, the meta property provides a way to attach\nmetadata to another property. This enables a number of important use\ncases including being able to attach a date or ACL information to\nindividual properties.",
            "children": []
          },
          {
            "level": "4.7.11",
            "title": "4.7.11. Using *unfold* and *WithOptions* with Meta Properties {#tp34vmmetaprop}",
            "content": "A new feature was introduced in Apache TinkerPop version 3.4 that allows\nus to more easily include both properties and their meta properties in\nthe result from a *valueMap* step that follows a *properties* step.\n\n::: tip\nAll of the possible values that can be specified using WithOptions can\nbe found in the official Apache TinkerPop JavaDoc documentation [at this\nlocation](http://tinkerpop.apache.org/javadocs/current/full/org/apache/tinkerpop/gremlin/process/traversal/step/util/WithOptions.html).\n:::\n\nTo use this new capability requires that the graph database you are\nusing has support for both meta properties and TinkerPop version 3.4.\nThe examples below build upon the examples shown in the previous\nsection.\n\nFirst of all, we know how to inspect the properties present for any\nvertex using the *properties* step.\n\n``` java\ng.V().has('code','AUS').properties()\n\nvp[country->US]\nvp[code->AUS]\nvp[longest->12250]\nvp[city->Austin]\nvp[elev->542]\nvp[icao->KAUS]\nvp[lon->-97.6698989868164]\nvp[type->airport]\nvp[region->US-TX]\nvp[runways->2]\nvp[lat->30.1944999694824]\nvp[desc->Austin Bergstrom ...]\n```\n\nWe also know how to look at the meta properties by following the\n*properties* step with a *valueMap* step or a second *properties* step.\nHowever, a value is returned only when a property has a meta property.\nFor all other properties the result is simply an empty list.\n\n``` java\ng.V().has('code','AUS').properties().valueMap()\n\n[]\n[date:6/6/2017]\n[]\n[]\n[]\n[]\n[]\n[]\n[]\n[]\n[]\n[]\n```\n\nUsing the new *with* step and specifying options using *WithOptions* we\ncan generate a result from *valueMap* that includes the property values\nand their respective meta properties. The example below generates a map\ncontaining the values for all properties plus the key and value for any\nmeta properties present.\n\n``` java\ng.V().has('code','AUS').\n      properties().\n      valueMap().with(WithOptions.tokens,WithOptions.values)\n```\n\nThe values are shown for all properties but for the case where we have a\n*date* meta property, that is also shown.\n\n``` java\n[value:US]\n[value:AUS,date:6/6/2017]\n[value:12250]\n[value:Austin]\n[value:542]\n[value:KAUS]\n[value:-97.6698989868164]\n[value:airport]\n[value:US-TX]\n[value:2]\n[value:30.1944999694824]\n[value:Austin Bergstrom International Airport]\n```\n\nSimilarly we could just decide to include the key names in the results.\n\n``` java\ng.V().has('code','AUS').\n      properties().\n      valueMap().with(WithOptions.tokens,WithOptions.keys)\n```\n\nOnce again the key and value are shown for the *date* meta property.\n\n``` java\n[key:country]\n[key:code,date:6/6/2017]\n[key:longest]\n[key:city]\n[key:elev]\n[key:icao]\n[key:lon]\n[key:type]\n[key:region]\n[key:runways]\n[key:lat]\n[key:desc]\n```\n\nTo include both the keys and the values in the result along with the\nmeta properties, *WithOptions.all* can be used.\n\n``` java\ng.V().has('code','AUS').\n      properties().\n      valueMap().with(WithOptions.tokens,WithOptions.all)\n```\n\nNote that in this case, the ID for each property is also shown.\n\n``` java\n[id:28,key:country,value:US]\n[id:29,key:code,value:AUS,date:6/6/2017]\n[id:30,key:longest,value:12250]\n[id:31,key:city,value:Austin]\n[id:32,key:elev,value:542]\n[id:33,key:icao,value:KAUS]\n[id:34,key:lon,value:-97.6698989868164]\n[id:35,key:type,value:airport]\n[id:36,key:region,value:US-TX]\n[id:37,key:runways,value:2]\n[id:38,key:lat,value:30.1944999694824]\n[id:39,key:desc,value:Austin Bergstrom International Airport]\n```",
            "children": []
          }
        ]
      },
      {
        "level": "4.8",
        "title": "4.8. Deducing the schema of a graph using queries {#deduce}",
        "content": "Sometimes, you may find yourself working with a graph while being unsure\nof its data model or schema. Using some simple Gremlin queries we can\nquite easily figure out the major elements that a graph contains. This\ntechnique should only be used if the graph database you are using does\nnot provide an explicit API for working with the schema of a graph.\nFirst of all, we can figure out the vertex labels that are in use as\nshown below. The *dedup* step insures that we get a list of unique label\nnames back.\n\n``` java\ng.V().label().dedup()\n\nversion\nairport\ncountry\ncontinent\n```\n\nSimilarly, we can find out the names of the edge labels in the graph.\n\n``` java\ng.E().label().dedup()\n\nroute\ncontains\n```\n\nNow that we know the label names it is very easy to get the names of the\nproperty keys for a vertex with a given label. The query below will\ndisplay the names of the property keys found in an *airport* vertex.\n\n``` java\ng.V().hasLabel('airport').limit(1).next().keys()\n\ncountry\ncode\nlongest\ncity\nelev\nicao\nlon\ntype\nregion\nrunways\nlat\ndesc\n```\n\nYou could easily put the previous query inside a simple loop if you\nwanted to iterate through each of the vertex labels that were\ndiscovered. As with vertices we can also query edges to discover their\nkey names. The query below finds the property key names for *route*\nedges.\n\n``` java\ng.E().hasLabel('route').limit(1).next().keys()\n\ndist\n```\n\nLastly now that we know the label names and we know how to find out the\nproperty key names, we can also figure out the types associated with\neach key. The code below creates an array called *pkeys* containing all\nof the property key names for an *airport* vertex. Having done that, the\ncode iterates through the list in a simple loop to find the type for\neach key. The code as shown is intended to be run inside the Gremlin\nConsole.\n\n``` java\npkeys=g.V().hasLabel('airport').limit(1).next().keys()\n\npkeys.each {\n  printf(\"%10s : %s\\n\" , it,\n          g.V().hasLabel('airport').limit(1).\n            values(it).next().class)};[]\n```\n\nWhen run, we get back a nicely formatted table showing the key names and\ntheir types.\n\n``` java\n   country : class java.lang.String\n      code : class java.lang.String\n   longest : class java.lang.Integer\n      city : class java.lang.String\n      elev : class java.lang.Integer\n      icao : class java.lang.String\n       lon : class java.lang.Double\n      type : class java.lang.String\n    region : class java.lang.String\n   runways : class java.lang.Integer\n       lat : class java.lang.Double\n      desc : class java.lang.String\n```\n\nLater, in the \\\"[The JanusGraph management API](#janusmgmt)\\\" section,\nwe will look at how JanusGraph allows us to define an explicit schema\nand also to query the schema using its Graph Management API.",
        "children": []
      },
      {
        "level": "4.9",
        "title": "4.9. Collections revisited {#collrev}",
        "content": "As we have seen in many of the prior examples, very often, either in the\nmiddle or at the end of a traversal, or both, we generate some kind of\ncollection. In this section we are going to take a more focused look at\nthese collections and how to work with them. In the following section we\nwill look at collections and how they can be used effectively in\nconjunction with so called *reducing barrier* traversal steps.",
        "children": [
          {
            "level": "4.9.1",
            "title": "4.9.1. Steps that generate collections {#collsteps}",
            "content": "Let's start this discussion by first reviewing a few ways that a\ncollection can be generated. A simple example of a collection is the map\nthat is generated by the *group* step as shown in the example below.\n\n``` java\ng.V(1..5).group().by('code').by('runways')\n\n[BNA:[4],ANC:[3],BOS:[6],ATL:[5],AUS:[2]]\n```\n\nSimilarly a map is created when the *groupCount* step is used.\n\n``` java\ng.V().hasLabel('airport').limit(40).groupCount().by('region')\n\n[US-FL:5,PR-U-A:1,US-NV:1,US-MN:1,US-HI:1,US-IL:1,US-TX:6,US-AK:1,US-WA:1,US-VA:1,US-NY:4,US-CO:1,US-NC:1,US-LA:1,US-MD:1,US-IA:1,US-MA:1,US-CA:6,US-DC:1,US-UT:1,US-AZ:1,US-GA:1,US-TN:1]\n```\n\nLikewise, when we use the fold step a list is generated. We can use the\n*order* step with a *local* scope to order the contents of the list.\n\n``` java\ng.V().hasLabel('airport').limit(20).values('runways').\n      fold().order(local)\n\n[2,2,2,3,3,3,3,3,4,4,4,4,4,4,4,5,5,6,7,8]\n```\n\nHere is an example of a *union* step followed by a *fold* step that\ngenerates a list of two values. The *union* step contains an *identity*\nstep to indicate that we want the value of the incoming vertex as the\nfirst item of the union. We union that vertex with a count of all routes\nfrom that vertex (DFW) and finally use a *fold* step to generate a list.\n\n``` java\ng.V().has('airport','code','DFW').union(identity(),out().count()).fold()\n\n[v[8],221]\n```\n\nNote that the above syntax, is a shorthand form of the following.\n\n``` java\ng.V().has('airport','code','DFW').as('a').union(select('a'),out().count()).fold()\n\n[v[8],221]\n```\n\nIf we wanted to generate a map with keys and values rather than a list,\nwe could use a *group* step. In this case the vertex is the keys and the\nnumber of outgoing routes is the value.\n\n``` java\ng.V().has('airport','code','DFW').group().by().by(out().count())\n\n[v[8]:221]\n```\n\nAnother way that a map can be created is when the *project* step is\nused.\n\n``` java\ng.V().has('airport','country','IE').project('loc','iata').by('city').by('code')\n\n[loc:Dublin,iata:DUB]\n[loc:Shannon,iata:SNN]\n[loc:Cork,iata:ORK]\n[loc:Charleston,iata:NOC]\n[loc:Killarney,iata:KIR]\n[loc:Waterford,iata:WAT]\n[loc:Donegal,iata:CFN]\n```\n\nAlso using a *project* step, but a little more complex, this example\ncreates a map with two keys. The first, called *dfw*, will contain the\nvertex for the DFW airport and the second, called *route_count*, will\ncontain the number of outgoing routes from DFW. Notice how the first\n*by* step has no parameters so it returns the actual vertex (rather than\nsay a property from the vertex that we could select).\n\n``` java\n g.V().has('code','DFW').project('dfw','route_count').\n       by().by(outE().count())\n\n[dfw:v[8],route_count:221]\n```\n\nAs well as generating maps, we can also generate a set using a *store*\nstep so that duplicate values are not stored. The *withSideEffect* step\ncan be used to initialize the set. The *cap* step emits the collection\nresulting from the side effect that we created using the *store* step.\nAmong other things this allows us to return this collection as the final\nresult of a query.\n\n``` java\ng.withSideEffect('s', [] as Set).\n  V().hasLabel('airport').limit(20).values('runways').\n      store('s').cap('s').order(local)\n\n[2,3,4,5,6,7,8]\n```\n\nThe *store* step can also be used in conjunction with a *by* modulator\nto specify exactly what is *stored*. The query below uses a *store* step\nto create a collection of runways but avoids the need to use a *values*\nstep.\n\n``` java\ng.V().has('region','US-TX').store('r').by('runways').cap('r')\n\n[2,2,2,2,2,2,2,2,7,5,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,1]\n```\n\nThe *aggregate* step also generates a collection as shown below. The\ncollection is actually a *BulkSet* as we shall confirm shortly. The\n*store* step also generates a BulkSet.\n\n``` java\ng.V().has('airport','country','IE').aggregate('ireland').cap('ireland')\n\n[v[60],v[91],v[311],v[477],v[635],v[785],v[1269]]\n```\n\nThe query below uses an *aggregate* step to find all the countries that\nyou can fly to from airports in Ireland but excludes routes that are\nbetween airports within Ireland.\n\n``` java\ng.V().has('airport','country','IE').aggregate('ireland').\n      out().where(without('ireland')).\n      values('country').\n      dedup().fold().order(local)\n```\n\nAs you can see by looking at the results, the country code for Ireland,\n*IE*, is not present in the list.\n\n``` java\n[AE,AT,BE,BG,CA,CH,CY,CZ,DE,DK,ES,ET,FI,FR,GR,HR,HU,IM,IS,IT,JE,LT,LU,LV,MA,MD,MT,NL,NO,PL,PT,QA,RO,SE,SK,TR,UK,US]\n```\n\nWhile *aggregate* and *store* on the surface appear identical, they\nactually behave differently. The *aggregate* step will block and\nimmediately gather up everything from the prior traversal, whereas the\n*store* step will only add things to its collection as they are seen.\nThis is sometimes referred to as *lazy aggregation*. Note also that even\nthough we specified a *limit* of 2, the *store* step collected three\nelements as the third has already been seen before the limit step is\napplied.\n\n``` java\ng.V().has('airport','country','IE').store('a').limit(2).cap('a')\n\n[v[60],v[91],v[311]]\n\ng.V().has('airport','country','IE').aggregate('a').limit(2).cap('a')\n\n[v[60],v[91],v[311],v[477],v[635],v[785],v[1269]]\n```\n\nBoth *aggregate* and *store* can be followed by a *by* modulator to\nspecify more precisely what should be collected. For example, if we\nwanted to store the number of runways that each airport in Ireland has\nwe could do so as follows.\n\n``` java\ng.V().has('airport','country','IE').\n      aggregate('ireland').by('runways').cap('ireland')\n\n[2,2,2,5,1,1,1]\n```\n\nIf we are ever unsure what type of object has been created a call to\n*getClass* can be used to find out.\n\n``` java\ng.V(1..5).group().by('code').by('runways').next().getClass()\n\nclass java.util.HashMap\n\ng.V(1..5).aggregate('a').cap('a').next().getClass()\n\nclass org.apache.tinkerpop.gremlin.process.traversal.step.util.BulkSet\n```\n\nNow that we have examined the various ways in which collections may get\ngenerated during a traversal, it is important to understand how the\ncontents of a collection can be accessed and manipulated.",
            "children": []
          },
          {
            "level": "4.9.2",
            "title": "4.9.2. Accessing the contents of a collection {#collaccess}",
            "content": "The keywords *keys* and *values* can be used to access the respective\nparts of a collection that is a map. Take a look at the query below\nwhich returns a map where airport codes are the keys and their city\nnames are the values.\n\n``` java\ng.V().hasLabel('airport').limit(5).group().by('code').by('city')\n\n[BNA:[Nashville],ANC:[Anchorage],BOS:[Boston],ATL:[Atlanta],AUS:[Austin]]\n```\n\nWe can use a *count* step with *local* scope to find out how big the\ncollection is.\n\n``` java\ng.V().hasLabel('airport').limit(5).group().by('code').by('city').count(local)\n\n5\n```\n\nThe queries below extract the keys and values from the map that the\n*group* step creates.\n\n``` java\ng.V().hasLabel('airport').limit(5).group().by('code').by('city').select(keys)\n\n[BNA,ANC,BOS,ATL,AUS]\n\ng.V().hasLabel('airport').limit(5).group().by('code').by('city').select(values)\n\n[[Nashville],[Anchorage],[Boston],[Atlanta],[Austin]]\n```\n\nWe can also extract the keys and values from the results of the\n*project* step we used earlier. Note that the values comeback as a list\ncontaining a the DFW vertex and the number of routes from DFW.\n\n``` java\ng.V().has('code','DFW').project('dfw','route_count').\n      by().by(outE().count()).select(values)\n\n[v[8],221]\n```\n\nLikewise the keys come back in a list.\n\n``` java\ng.V().has('code','DFW').project('dfw','route_count').\n      by().by(outE().count()).select(keys)\n\n[dfw,route_count]\n```\n\nWe could also be even more specific and select which values we are\ninterested in.\n\n``` java\ng.V().has('code','DFW').project('dfw','route_count').\n       by().by(outE().count()).select('route_count')\n\n221\n```\n\nWe can also access the DFW vertex directly from the map.\n\n``` java\ng.V().has('code','DFW').project('dfw','route_count').\n      by().by(outE().count()).select('dfw')\n\nv[8]\n```\n\nHaving extracted the vertex we can retrieve values from it. A bit later\nwe will look at ways we could continue our traversal from this point if\nwe needed to, perhaps looking at outgoing routes from DFW or adding a\nnew route. You will find that discussion in the \\\"[Collections and\nreducing barrier steps](#rbarriers)\\\" section.\n\n``` java\ng.V().has('code','DFW').project('dfw','route_count').\n      by().by(outE().count()).select('dfw').values('desc')\n\nDallas/Fort Worth International Airport\n```\n\nAs we shall see in the next two sections, sometimes it is necessary to\nuse the *unfold* step to access the contents of a collection and it is\nalso sometimes necessary to use *local* scope.",
            "children": []
          },
          {
            "level": "4.9.3",
            "title": "4.9.3. Using *unfold* to unbundle a collection {#unbundle}",
            "content": "Sometimes it is desirable to unbundle a collection so that we can work\non it further. This is what the *unfold* step does. If we apply *unfold*\nto the previous query you can see what is generated. The collection that\nthe *group* step generates is a Java HashMap. The *unfold* step turns\nthe HashMap into a series of HashMap.Node elements.\n\n``` java\ng.V().hasLabel('airport').limit(5).group().by('code').by('city').unfold()\n\nBNA=[Nashville]\nANC=[Anchorage]\nBOS=[Boston]\nATL=[Atlanta]\nAUS=[Austin]\n```\n\nIf we wanted a list of values we could use *unfold* again as shown\nbelow. You will recall from our earlier discussion that vertex\nproperties are stored as lists even if there is only one property - a\nlist of length one in other words. Note that this shows that a single\n*unfold* step will not recursively unbundle elements from a collection.\n\n``` java\ng.V().hasLabel('airport').limit(5).group().by('code').by('city').\n      select(values).unfold()\n\n[Nashville]\n[Anchorage]\n[Boston]\n[Atlanta]\n[Austin]\n```\n\nWe could add a second *unfold* to just get the city names back and\nremove the containing lists.\n\n``` java\ng.V().hasLabel('airport').limit(5).group().by('code').by('city').\n      select(values).unfold().unfold()\n\nNashville\nAnchorage\nBoston\nAtlanta\nAustin\n```\n\nAs an alternative, *repeat* can be used when you want to unfold more\nthan once as shown below.\n\n``` java\ng.V().hasLabel('airport').limit(5).group().by('code').by('city').\n      select(values).repeat(unfold()).times(2)\n\nNashville\nAnchorage\nBoston\nAtlanta\nAustin\n```\n\nIf we were not sure how many times we needed to *unfold* we could change\nthe query as follows. The *repeat* loop will unfold until there is only\na list of lists left. The final unfold will remove the remaining lists\nleaving us with just the text values.\n\n``` java\ng.V().hasLabel('airport').limit(5).group().by('code').by('city').\n      select(values).repeat(unfold()).until(count(local).is(1)).unfold()\n\nNashville\nAnchorage\nBoston\nAtlanta\nAustin\n```\n\nHaving used *unfold* to extract just the city names as strings, we could\nre-fold one time to produce a list of airport names using the *fold*\nstep. This pattern of unfolding, performing an operation and refolding\nis one that comes in handy quite often, especially in more complex\nqueries.\n\n``` java\ng.V().hasLabel('airport').limit(5).group().by('code').by('city').\n      select(values).unfold().unfold().fold()\n\n[Nashville,Anchorage,Boston,Atlanta,Austin]\n```\n\nIt is probably worth pointing out that the *keys* and *values* keywords\ncan also be used with something as simple as a *valueMap* step. Here is\na simple example.\n\n``` java\ng.V(3).valueMap().select(keys)\n\n[country,code,longest,city,elev,icao,lon,type,region,runways,lat,desc]\n\ng.V(3).valueMap().select(values)\n\n[[US],[AUS],[12250],[Austin],[542],[KAUS],[-97.6698989868164],[airport],[US-TX],[2],[30.1944999694824],[Austin Bergstrom International Airport]]\n```",
            "children": []
          },
          {
            "level": "4.9.4",
            "title": "4.9.4. Using *local* scope with collections {#localcollect}",
            "content": "Sometimes if you want to work on the contents of a collection, whether\nto sort it or perhaps select some subset of it it is often necessary to\nuse *local* scope. There are other ways the following examples could be\nwritten but I wanted to show some ways that *local* scope can be\ncombined with the *order*, *range*, *limit* and *tail* steps while\nworking with collections.\n\nFirst of all let's, once again produce a collection using airports in\nIreland. This time we produce a map where the keys are the airport codes\nand the values are the number of runways at that airport.\n\n``` java\ng.V().has('airport','country','IE').\n      group().by('code').by('runways')\n\n[DUB:[2],SNN:[5],NOC:[1],KIR:[2],ORK:[2],CFN:[1],WAT:[1]]\n```\n\nWe already know how to select the keys from the map using our prior\nexamples but for completeness let's take a another look.\n\n``` java\ng.V().has('airport','country','IE').\n      group().by('code').by('runways').select(keys)\n\n[DUB,SNN,NOC,KIR,ORK,CFN,WAT]\n```\n\nIf we wanted to sort the keys by ascending order we could use an *order*\nstep with *local* scope.\n\n``` java\ng.V().has('airport','country','IE').\n      group().by('code').by('runways').select(keys).order(local)\n\n[CFN,DUB,KIR,NOC,ORK,SNN,WAT]\n```\n\nIt is worth noting that this is a case where we could have used the\n*unfold* and *fold* pattern instead as shown below.\n\n``` java\ng.V().has('airport','country','IE').\n      group().by('code').by('runways').select(keys).\n      unfold().order().fold()\n\n[CFN,DUB,KIR,NOC,ORK,SNN,WAT]\n```\n\nThe next example also uses *local* scope along with a *limit* step to\nretrieve the first two airport keys.\n\n``` java\ng.V().has('airport','country','IE').\n      group().by('code').by('runways').select(keys).limit(local,2)\n\n[DUB,SNN]\n```\n\nWe can use the same *local* scope with the *tail* step to select the\nlast three keys.\n\n``` java\ng.V().has('airport','country','IE').\n      group().by('code').by('runways').select(keys).tail(local,3)\n\n[ORK,CFN,WAT]\n```\n\nAs you would expect we can also specify *local* scope on a *range* step.\n\n``` java\ng.V().has('airport','country','IE').\n      group().by('code').by('runways').select(keys).range(local,3,5)\n\n[KIR,ORK]\n```\n\nYou can combine the *limit* and *tail* steps with *local* scope to\nextract the beginning or ending entries from a list of values as shown\nbelow. The following query creates a list containing the IATA codes for\nall airports in Texas.\n\n``` java\ng.V().has('region','US-TX').values('code').fold()\n\n[AUS,DFW,IAH,SAT,HOU,ELP,DAL,LBB,HRL,MAF,CRP,ABI,ACT,CLL,BPT,AMA,BRO,GGG,GRK,LRD,MFE,SJT,SPS,TYR,VCT,AFW]\n```\n\nUsing *local* scope with a *limit* step we can extract just the first\ntwo entries from the list.\n\n``` java\ng.V().has('region','US-TX').values('code').fold().limit(local,2)\n\n[AUS,DFW]\n```\n\nLikewise, using *local* scope with a *tail* step we can extract just the\nlast two entries from the list.\n\n``` java\ng.V().has('region','US-TX').values('code').fold().tail(local,2)\n\n[VCT,AFW]\n```\n\nIt is worth noting that *local* scope can also be used with a *dedup*\nstep. The query below finds airports in the US and produces a sorted\nlist of the unique region codes by only allowing one airport from each\nregion to proceed to the next steps of the traversal.\n\n``` java\ng.V().has('country','US').dedup().by('region').values('region').order().fold()\n```\n\nThe rewritten version of the query below allows the region codes for\nevery airport to be collected and then the *dedup* is applied to the\nresultant collection using *local* scope. The prior query is likely to\nbe the more efficient way of doing this but I wanted to make it clear\nthat existing collections of values can have *dedup* applied to them\nusing *local* scope.\n\n``` java\ng.V().has('country','US').values('region').order().fold().dedup(local)\n```\n\nWhen either query is run, here are the results that are returned.\n\n``` java\n[US-AK,US-AL,US-AR,US-AZ,US-CA,US-CO,US-CT,US-DC,US-DE,US-FL,US-GA,US-HI,US-IA,US-ID,US-IL,US-IN,US-KS,US-KY,US-LA,US-MA,US-MD,US-ME,US-MI,US-MN,US-MO,US-MS,US-MT,US-NC,US-ND,US-NE,US-NH,US-NJ,US-NM,US-NV,US-NY,US-OH,US-OK,US-OR,US-PA,US-RI,US-SC,US-SD,US-TN,US-TX,US-UT,US-VA,US-VT,US-WA,US-WI,US-WV,US-WY]\n```\n\nLastly, we can combine some of the prior examples to limit, order and\ndeduplicate the contents of a group. The query below does not include a\n*limit* step so it retrieves all possible results. The goal of the query\nis to build a group, with labels as the keys and vertex *code*\nproperties as the values for both incoming and outgoing edges connected\nto AUS (Austin). The results are deduplicated so that no airport code\nappears twice.\n\n``` java\ng.V().has('code','AUS').\n      both().\n      group().\n        by(label).\n        by(values('code').fold().dedup(local).order(local))\n```\n\nWhen run it returns the following results.\n\n``` java\n[continent:[NA],country:[US],airport:[ABQ,ATL,BKG,BNA,BOS,BWI,CLE,CLT,CUN,CVG,DAL,DCA,DEN,DFW,DTW,ELP,EWR,FLL,FRA,GDL,HOU,HRL,IAD,IAH,IND,JFK,LAS,LAX,LBB,LGB,LHR,MCI,MCO,MDW,MEM,MEX,MIA,MSP,MSY,OAK,ORD,PDX,PHL,PHX,PIE,PIT,PNS,RDU,SAN,SEA,SFB,SFO,SJC,SLC,SNA,STL,TPA,VPS,YYZ]]\n```\n\nHowever, let's assume we wanted to limit the query to a maximum of ten\nresults for any of the keys in the group. We can do so by adding a\n*limit* step with *local* scope as shown below.\n\n``` java\ng.V().has('code','AUS').\n      both().\n      group().\n        by(label).\n        by(values('code').fold().dedup(local).order(local).limit(local,10))\n```\n\nThis time when run, the amount of results returned is restricted.\n\n``` java\n[continent:[NA],country:[US],airport:[ABQ,ATL,BKG,BNA,BOS,BWI,CLE,CLT,CUN,CVG]]\n```\n\nIn the next section we will continue our look at Gremlin's collections\nand how they can be used in conjunction with *reducing barrier* steps to\nstill achieve a desired result. We will also see other cases where\n*unfold* is needed to access the parts of a collection that we care\nabout.",
            "children": []
          }
        ]
      },
      {
        "level": "4.10",
        "title": "4.10. Collections and reducing barrier steps {#rbarriers}",
        "content": "If you look at commonly asked questions about writing Gremlin queries on\nthe Gremlin Users discussion list, one area that repeatedly seems to\ncause people confusion is the behavior of certain traversal steps that\nare known as *reducing barrier* steps. What these steps in essence do is\nreduce the results of the traversal so far to a single traversal, often\njust a value or a collection of some kind and from that point on you\ncannot refer back to things you did earlier in the query.\n\n+-------------+--------------------------------------------------------+\n| max         | Returns the maximum value from a set of values.        |\n+-------------+--------------------------------------------------------+\n| min         | Returns the minimum value from a set of values.        |\n+-------------+--------------------------------------------------------+\n| sum         | Returns the sum of a set of values.                    |\n+-------------+--------------------------------------------------------+\n| count       | Counts the number of current elements.                 |\n+-------------+--------------------------------------------------------+\n| fold        | Aggregates current traversal into a map.               |\n+-------------+--------------------------------------------------------+\n\n: Reducing barrier steps\n\nTake a look at the example below. On the surface, you might expect the\nquery to count all of the routes originating from the DFW airport and\nreturn the count *\\\"b\\\"* along with the airport vertex *\\\"a\\\"*.\n\n``` java\ng.V().has('code','DFW').as('a').outE().count().as('b').select('a','b')\n```\n\nWhat actually happens is that nothing is returned. This is because the\n*count* step is a so called *reducing barrier* step. Once the *count*\nhas been processed, you have crossed the *barrier* and the traversal\nvariable *\\\"a\\\"* is no longer available to us. We can still access\n*\\\"b\\\"* if we reference it by itself as it is defined after the *count*\nstep as shown below.\n\n``` java\ng.V().has('code','DFW').as('a').outE().count().as('b').select('b')\n\n221\n```\n\nIn cases such as this, it is almost always possible to achieve the\nresults that you want by changing the way you write the query. It is\nimportant to gain an understanding of how different traversal steps\nwork. A great way to do that is to experiment using the Gremlin Console\nand look at the way different steps operate. The rewritten query below\nachieves our original goal.\n\n``` java\ng.V().has('code','DFW').group().by().by(outE().count())\n\n[v[8]:221]\n```\n\nIf this was all we needed then our job is done. We have a map containing\nthe vertex as the key and its outgoing route count as the value.\nHowever, there is still an issue if we want to go further with this\nquery. Take a look at the example below. Because the query has reduced\nthe prior traversal to essentially a small map, including a count, we\ncan no longer refer back to *\\\"a\\\"*.\n\n``` java\ng.V().has('code','DFW').as('a').group().by().by(outE().count()).select('a')\n```\n\nIf for some reason, we wanted to retrieve the vertex that we had stored\nin *\\\"a\\\"*, we should instead pull it from the map that the *group* step\ncreated. You can access the keys of a map using the *keys* keyword as a\nparameter to a *select* step.\n\n``` java\ng.V().has('code','DFW').group().by().by(outE().count()).\n                        select(keys)\n\n[v[8]]\n```\n\nWe have still not quite got the result we wanted as the vertex is still\nreturned in a list. So we can modify the query again to *unfold* the map\nbefore we select the keys from it.\n\n``` java\ng.V().has('code','DFW').group().by().by(outE().count()).\n                        unfold().select(keys)\nv[8]\n```\n\nIf we wanted to get the value back instead of the key we can use the\n*values* keyword as follows.\n\n``` java\ng.V().has('code','DFW').group().by().by(outE().count()).\n                        unfold().select(values)\n\n221\n```\n\nTo prove we could carry on adding to the query from here let's get back\nthe airport code that we started with.\n\n``` java\ng.V().has('code','DFW').group().by().by(outE().count()).\n                        unfold().select(keys).values('code')\n\nDFW\n```\n\nSo, lets now add to our query and create a new vertex with a label\n*dfwcount* that is going to store the number of routes originating in\nDFW using a property called *current_count*.\n\n``` java\ng.V().has('code','DFW').group().by().by(outE().count()).as('ct').\n      addV('dfwcount').\n      property('current_count',select('ct').unfold().select(values))\n\nv[54931]\n```\n\nWe can inspect the new vertex to double check that our query worked as\nintended.\n\n``` java\ng.V(54931).valueMap(true)\n\n[id:54931,current_count:[221],label:dfwcount]\n```\n\nHopefully you are starting to see a pattern here. It is important to\nunderstand which steps are *reducing barrier* steps and be able to work\nwith them in a way that allows you to write queries that do what you\nneed.",
        "children": [
          {
            "level": "4.10.1",
            "title": "4.10.1. Calculating the *sum* of a collection {#sumcollection}",
            "content": "The query below returns a map where the keys are airport IATA codes and\nthe values are the number of runways at the airport. The results are\nordered to aid readability.\n\n``` java\ng.V().hasLabel('airport').limit(10).\n      group().by('code').by(values('runways')).\n      order(local).by(values)\n\n[FLL:2,AUS:2,DCA:3,BWI:3,ANC:3,BNA:4,IAD:4,ATL:5,BOS:6,DFW:7]\n```\n\nGiven such a collection of airports and runways, we might want to\ncalculate the total number of runways present. The query below achieves\nthat. Note that in order to select the values from the collection an\n*unfold* step is used to turn the collection back into a stream from\nwhich the values can be selected.\n\n``` java\ng.V().hasLabel('airport').limit(10).\n      group().by('code').by(values('runways')).\n      unfold().\n      select(values).\n      sum()\n\n39\n```\n\nWe can also write the query using *local* scope rather than an *unfold*\nstep as shown below.\n\n``` java\ng.V().hasLabel('airport').limit(10).\n      group().by('code').by(values('runways')).\n      local(select(values).sum(local))\n\n39\n```",
            "children": []
          },
          {
            "level": "4.10.2",
            "title": "4.10.2. Using the *math* step with collections {#mathcollection}",
            "content": "Building on the examples from the previous section, let's now take these\nexperiments one step further and look at ways to apply the *math* step\nto values from one or more collections. Given we know that there are 10\nvalues in our collection we can easily use a *math* step to calculate\nthe average of those values.\n\n``` java\ng.V().hasLabel('airport').limit(10).\n      group().by('code').by(values('runways')).\n      unfold().\n      select(values).\n      sum().\n      math('_ / 10')\n\n3.9\n```\n\nWe may not always know ahead of time how many entries a collection has.\nThe modified example below uses a *project* step to feed the *math* step\nwith two values representing the total number of runways and the number\nof members in the collection.\n\n``` java\ng.V().hasLabel('airport').limit(10).\n      group().by('code').by(values('runways')).\n      project('total','number').\n        by(select(values).unfold().sum()).\n        by(count(local)).\n      math('total / number')\n\n3.9\n```\n\nSometimes you may want to perform computations on the sums of multiple\ncollections. The two queries shown below create maps of airport and\nrunway key/value pairs for all the airports in New Mexico and Arizona\nrespectively.\n\n``` java\ng.V().has('region','US-NM').\n      group().by('code').by(values('runways'))\n\n[ABQ:4,SVC:4,CNM:4,FMN:2,SAF:3,LAM:1,HOB:3,CVN:3,ROW:3]\n```\n\nIf you were to add up the runways at the New Mexico airports you would\nfind there are 27 and likewise there are 26 runways across the Arizona\nairports.\n\n``` java\ng.V().has('region','US-AZ').\n      group().by('code').by(values('runways'))\n\n[YUM:4,PRC:3,FLG:1,PHX:3,IFP:1,TUS:3,GCN:1,AZA:3,SOW:2,PGA:2,IGM:3]\n```\n\nGiven these two collections, we might want to divide the sum of one set\nof values by the other to calculate the ratio between the total number\nof runways in Arizona and New Mexico. The query below does just that.\nWhile at first glance this query looks a bit complicated, it is in fact\njust the result of combining the prior few queries we have looked at\ninto a single query.\n\n``` java\ng.V().has('region','US-NM').\n      group().by('code').by(values('runways')).\n      select(values).\n      unfold().\n      sum().\n      store('a').\n      V().has('region','US-AZ').\n      group().by('code').by(values('runways')).\n      select(values).\n      unfold().\n      sum().\n      store('b').\n      project('first','second').\n        by(select('a').unfold()).\n        by(select('b').unfold()).\n      math('first / second')\n\n1.0384615384615385\n```\n\nGiven we calculated that there were 27 runways in New Mexico and 26 in\nArizona we can verify that we have the right result using the Gremlin\nConsole.\n\n``` console\ngremlin> 27/26\n\n==>1.0384615385\n```",
            "children": []
          }
        ]
      },
      {
        "level": "4.11",
        "title": "4.11. Introducing *sack* as a way to store values {#sackintro}",
        "content": "As is hopefully now becoming apparent, to efficiently write certain\ntypes of queries you need a way to build up a collection of items as the\ntraversal takes place. We have already looked at steps like *aggregate*\nand *store* that can create collections of items during a traversal.\nHowever, the *sack* step offers an additional capability in that we can\nspecify how items are added to the collection. For example they can be\nadded using addition, multiplication, subtraction or division.\nAlternatively we can store the minimum or maximum value of a pair of\nvalues. These and other sack operators will be used in different parts\nof this book.",
        "children": [
          {
            "level": "4.11.1",
            "title": "4.11.1. Basic *sack* operations {#sackbasics}",
            "content": "The *sack* step, as shown in the examples below, is a side effect step,\nmeaning it can store values during a traversal but has no effect on what\nis passed on to the next step.\n\nBy way of an introduction, take a look at the example below. All the\nquery does as it stands is create a list of the number of runways that\neach airport that you can fly to from Santa Fe (SAF) has. We have not\nintroduced a *sack* step into the equation yet.\n\n``` java\ng.V().has('code','SAF').out().values('runways').fold()\n\n[7,4,3,6]\n```\n\nNow let's start to introduce some usage of sacks into the query. When\nworking with a *sack* we typically initialize the sack in some way. The\nexample below initializes a sack with a value of zero but does not yet\ndo anything with it so the result is unchanged.\n\n``` java\ng.withSack(0).V().has('code','SAF').out().\n              values('runways').fold()\n\n[7,4,3,6]\n```\n\nThis time we add the runways to our sack using a sum operation, but as\nour starting value is zero we are not actually changing the end result\nin any way. This is because we essentially perform the operation *0 +\nrunways* for each runway value. The final call to *sack* with no\nparameters causes the current contents of the *sack* to be returned. The\n*fold* step, as before, puts whatever results we got from the *sack*\ninto a list.\n\n``` java\ng.withSack(0).V().has('code','SAF').out().\n              values('runways').sack(sum).sack().fold()\n\n[7,4,3,6]\n```\n\nSo let's finally do something that will change the result. Let's make\nthe starting value one rather than zero and see what happens.\n\n``` java\ng.withSack(1).V().has('code','SAF').out().\n              values('runways').sack(sum).sack().fold()\n\n[8,5,4,7]\n```\n\nNow, each time the number of runways was added to the sack using a *sum*\noperator, the operation that was performed was *1 + runways*. As you can\nsee from the results, in each case, the value returned is one higher\nthan those from the previous query. This is a very simple example but\nhopefully you can start to see how useful sacks can be.\n\nBefore getting into some more interesting examples, it is worth pointing\nout that you can also initialize a sack using the *assign* operator as\nshown below. It is also important to note that this sack initialization\ndoes not have to happen at the start of the query when done in this way.\nIn the example below, a constant value of one is used, but we could\nequally well have used a traversal to initialize that sack as we shall\nsee in the next example.\n\n``` java\ng.V().sack(assign).by(constant(1)).has('code','SAF').\n      out().values('runways').sack(sum).sack().fold()\n\n[8,5,4,7]\n```\n\nLet's now make our query a bit more interesting. There are a couple of\ninteresting new twists shown in the query below. Firstly, the sack is\ninitialized to contain the number of runways from the AUS vertex whereas\nbefore we just used a simple constant. Secondly, notice that rather than\nmake an explicit call to *values* before adding to the sack, we can just\nuse a *by* modulator to specify what we want added to our sack.\n\n``` java\ng.V().has('code','AUS').sack(assign).by('runways').\n  V().has('code','SAF').out().\n      sack(sum).by('runways').sack().fold()\n\n[9,6,5,8]\n```\n\nThis time, as the Austin (AUS) airport has two runways our calculation\nin effect became *2 + runways*.\n\nBefore looking at some slightly more complex queries that use multiple\n*sack* steps, we should take a look at some of the other operators. So\nfar we have just used *sum*. The query below uses *mult* which as its\nname implies will multiply the values together rather than add them.\n\n``` java\ng.V().has('code','AUS').sack(assign).by('runways').\n  V().has('code','SAF').out().\n      sack(mult).by('runways').sack().fold()\n\n[14,8,6,12]\n```\n\nLikewise, minus will subtract the values before putting them into the\nsack. Note that the values are subtracted **from** the sack's\ninitialization value.\n\n``` java\ng.V().has('code','AUS').sack(assign).by('runways').\n  V().has('code','SAF').out().\n      sack(minus).by('runways').sack().fold()\n\n[-5,-2,-1,-4]\n```\n\nIf we wanted to subtract the sack's initial value from the other values\nwe can simply initialize it with a negative value and perform a *sum*\noperation.\n\n``` java\ng.V().sack(assign).by(constant(-1)).has('code','SAF').\n      out().values('runways').sack(sum).sack().fold()\n\n[6,3,2,5]\n```",
            "children": []
          },
          {
            "level": "4.11.2",
            "title": "4.11.2. Using *min* and *max* with a *sack* {#sackminmax}",
            "content": "There are many different operators that can be used with sacks. They are\ndefined as part of the TinkerPop Java Enum called *Operator*. Two such\noperators that we can use are *min* and *max*. The example below looks\nat the distances of all routes that start at SAF and in each case\nreturns the minimum of the distance or 400 which is assigned to the sack\nat the start of the query.\n\n``` java\ng.V().sack(assign).by(constant(400)).has('code','SAF').\n      outE().sack(min).by('dist').sack().fold()\n\n[400,400,369,303]\n```\n\nIn a similar vein, this query picks the maximum of the actual distance\nor 400.\n\n``` java\ng.V().sack(assign).by(constant(400)).has('code','SAF').\n      outE().sack(max).by('dist').sack().fold()\n\n[549,708,400,400]\n```",
            "children": []
          },
          {
            "level": "4.11.3",
            "title": "4.11.3. Doing calculations using a *sack* {#sackcalc}",
            "content": "Now let's look at a more complex, and hopefully more interesting,\nexample. The challenge is to write a query that shows 10 routes that\nstart at Santa Fe (SAF) and have one stop. We also want to return the\ndistance between each hop and the total distance of the two hops. This\nis a perfect example of a query where using a *sack* can help. For\ncompleteness the results are sorted by overall route distance.\n\n``` java\ng.withSack(0).\n  V().has('code','SAF').\n      repeat(outE().sack(sum).by('dist').inV()).times(2).limit(10).\n      order().by(sack()).\n      sack().path().\n      by('code').by('dist').by('code').by('dist').by('code').by()\n```\n\nIf we run our query, we should get back something that looks like the\noutput shown below. Notice how the output from the *sack* (the last item\nin each row) contains the sum of the two prior route distances. So, for\nexample, we can see that the total distance from SAF to ATL with a stop\nin DFW is 1278 miles.\n\n``` java\n[SAF,549,DFW,190,AUS,739]\n[SAF,549,DFW,225,IAH,774]\n[SAF,549,DFW,630,BNA,1179]\n[SAF,549,DFW,729,ATL,1278]\n[SAF,549,DFW,1120,FLL,1669]\n[SAF,549,DFW,1170,IAD,1719]\n[SAF,549,DFW,1190,DCA,1739]\n[SAF,549,DFW,1210,BWI,1759]\n[SAF,549,DFW,1560,BOS,2109]\n[SAF,549,DFW,3030,ANC,3579]\n```\n\nWhat may not be obvious from the query above is that we are in fact\nusing multiple *sack* steps within the same query. If we were to remove\nthe *repeat* and write the query out in full this becomes more obvious.\n\n``` java\ng.withSack(0).\n  V().has('code','SAF').\n      outE().limit(10).sack(sum).by('dist').inV().\n      outE().limit(10).sack(sum).by('dist').inV().\n      sack().path().\n      by('code').by('dist').by('code').by('dist').by('code').by()\n```\n\nLater, in the [Using to calculate the shortest AUS-LHR route with one\nstop](#sackauslhr) section, we will again use a *sack* to help calculate\nmulti hop route distances using an approach similar to the example\nabove.\n\nSo far we have just used simple integer values to initialize our sacks.\nHowever it is also possible to use non primitive types such as maps when\nworking with a sack. You will find an example of *sack* being used to\ngenerate a map in the \\\"[Another example of how can be\nused](#anothersack) section.",
            "children": []
          },
          {
            "level": "4.11.4",
            "title": "4.11.4. Doing calculations without using a *sack* {#nonsackcalc}",
            "content": "A similar result to those from the queries in the previous section can\nactually be achieved without using a *sack*. I find the *sack* form to\nbe quite concise but you can also use a *project* step to achieve\nsimilar results as shown below. The key thing to notice about this query\nis that the path generated by the first half of the query is unfolded to\nget the distances from the edges. As only edges have a *dist* property\nin the `air-routes` graph, a coalesce step is used to generate the\ndistance from the edges or a constant value of zero otherwise. If we did\nnot do this the query would generate an error message as airport\nvertices does not have a *dist* property.\n\n``` java\ng.V().has('code','SAF').\n      repeat(outE().inV().simplePath()).times(2).limit(10).\n        project('path','total').\n          by(path().by('code').by('dist')).\n          by(path().unfold().coalesce(values('dist'),constant(0)).sum()).\n          order().by(select('total'))\n```\n\nWhen run the query produces the following results. Note that the output\nincludes the *path* and *total* key names and also that the path is in a\nlist nested inside another list.\n\n``` java\n[path:[SAF,549,DFW,190,AUS],total:739]\n[path:[SAF,549,DFW,225,IAH],total:774]\n[path:[SAF,549,DFW,630,BNA],total:1179]\n[path:[SAF,549,DFW,729,ATL],total:1278]\n[path:[SAF,549,DFW,1120,FLL],total:1669]\n[path:[SAF,549,DFW,1170,IAD],total:1719]\n[path:[SAF,549,DFW,1190,DCA],total:1739]\n[path:[SAF,549,DFW,1210,BWI],total:1759]\n[path:[SAF,549,DFW,1560,BOS],total:2109]\n[path:[SAF,549,DFW,3030,ANC],total:3579]\n```\n\nThe query can be refined a bit more to remove the *path* and *total* key\nnames from the result by just selecting the values for each.\n\n``` java\ng.V().has('code','SAF').\n      repeat(outE().inV().simplePath()).times(2).limit(10).\n        project('path','total').\n          by(path().by('code').by('dist')).\n          by(path().unfold().coalesce(values('dist'),constant(0)).sum()).\n          order().by(select('total')).\n          select(values)\n```\n\nNow the results are exactly the same as from the version of the query\nthat used *sack*. This was a longer query to write but in some cases,\ndepending upon the graph database implementation, could be more\nefficient as processing of results is left until the second half of the\nquery.\n\n``` java\n[[SAF,549,DFW,190,AUS],739]\n[[SAF,549,DFW,225,IAH],774]\n[[SAF,549,DFW,630,BNA],1179]\n[[SAF,549,DFW,729,ATL],1278]\n[[SAF,549,DFW,1120,FLL],1669]\n[[SAF,549,DFW,1170,IAD],1719]\n[[SAF,549,DFW,1190,DCA],1739]\n[[SAF,549,DFW,1210,BWI],1759]\n[[SAF,549,DFW,1560,BOS],2109]\n[[SAF,549,DFW,3030,ANC],3579]\n```\n\nWe can add one more refinement to make the results exactly the same as\nthose from the version of the query that used *sack* by unfolding the\nresults and then refolding them with *local* scope.\n\n``` java\ng.V().has('code','SAF').\n      repeat(outE().inV().simplePath()).times(2).limit(10).\n        project('path','total').\n          by(path().by('code').by('dist')).\n          by(path().unfold().coalesce(values('dist'),constant(0)).sum()).\n          order().by(select('total')).\n          select(values).local(unfold().unfold().fold())\n```\n\nNow the results look just the same was those we got using *sack*.\n\n``` java\n[SAF,549,DFW,190,AUS,739]\n[SAF,549,DFW,225,IAH,774]\n[SAF,549,DFW,630,BNA,1179]\n[SAF,549,DFW,729,ATL,1278]\n[SAF,549,DFW,1120,FLL,1669]\n[SAF,549,DFW,1170,IAD,1719]\n[SAF,549,DFW,1190,DCA,1739]\n[SAF,549,DFW,1210,BWI,1759]\n[SAF,549,DFW,1560,BOS,2109]\n[SAF,549,DFW,3030,ANC,3579]\n```\n\nThe query can also be written using the same *path* and *coalesce*\napproach but this time using a *union* step with *local* scope. This is\nmore concise than the version that uses *project* and may be sufficient\nif you do not need to select parts of the result individually using a\nkey name.\n\n``` java\ng.V().has('code','SAF').\n      repeat(outE().inV().simplePath()).times(2).limit(10).\n      local(union(path().by('code').by('dist').unfold(),\n                  path().unfold().coalesce(values('dist'),constant(0)).sum()).fold()).\n      order().by(tail(local,1))\n```\n\nOnce again we have the same results as we had when using *sack* or\n*project*.\n\n``` java\n[SAF,549,DFW,190,AUS,739]\n[SAF,549,DFW,225,IAH,774]\n[SAF,549,DFW,630,BNA,1179]\n[SAF,549,DFW,729,ATL,1278]\n[SAF,549,DFW,1120,FLL,1669]\n[SAF,549,DFW,1170,IAD,1719]\n[SAF,549,DFW,1190,DCA,1739]\n[SAF,549,DFW,1210,BWI,1759]\n[SAF,549,DFW,1560,BOS,2109]\n[SAF,549,DFW,3030,ANC,3579]\n```\n\nAs we have seen, the *sack* form is quite concise however, the *project*\nand *union* forms have a nice feature that they will work unchanged no\nmatter how long the resultant path is. As you may have noticed in the\nprior section the *sack* version of the query was tailored to produce\nresults for a two hop query. We could of course rewrite the *sack*\nversion to be equally flexible as shown below. The key difference is\nthat the result from the sack is not included in the path but factored\nin later inside a *union* step.\n\n``` java\ng.withSack(0).\n  V().has('code','SAF').\n      repeat(outE().sack(sum).by('dist').inV()).times(2).limit(10).\n      order().by(sack()).\n      local(union(path().by('code').by('dist'),\n                  sack()).fold()).\n      local(unfold().unfold().fold())\n```\n\nAgain we have the same results.\n\n``` java\n[SAF,549,DFW,190,AUS,739]\n[SAF,549,DFW,225,IAH,774]\n[SAF,549,DFW,630,BNA,1179]\n[SAF,549,DFW,729,ATL,1278]\n[SAF,549,DFW,1120,FLL,1669]\n[SAF,549,DFW,1170,IAD,1719]\n[SAF,549,DFW,1190,DCA,1739]\n[SAF,549,DFW,1210,BWI,1759]\n[SAF,549,DFW,1560,BOS,2109]\n[SAF,549,DFW,3030,ANC,3579]\n```\n\nSo in summary, as is almost always the case, there is more than one way\nto get the results you need using a Gremlin query.",
            "children": []
          },
          {
            "level": "4.11.5",
            "title": "4.11.5. Computing hop counts using a *sack* {#sackpathlength}",
            "content": "The next query we are going to look at uses a *sack* to keep track of\nhow many flight segments (or hops) a *path* consists of. This means that\nalong with the *path* result we can also return the path's *hop count*.\n\nThe query below looks for routes between Austin and Wellington and\nreturns the first 10 results found along with the number of flights that\nwould need to be taken between the source and destination airports. As\npart of the *repeat* step, each time an *out* step is taken a *constant*\nvalue of one is added to the sack for that individual path. Finally a\n*union* step is used to combine the individual path with its hop count.\n\n``` java\ng.withSack(0).V().\n  has('code','AUS').\n  repeat(out().simplePath().sack(sum).by(constant(1))).\n    until(has('code','WLG')).\n  limit(10).\n  local(union(path().by('code'),sack()).fold())\n```\n\nWhen run the query returns ten lists containing the airports visited and\nthe number of hops in each individual list.\n\n``` java\n[[AUS,DFW,SYD,WLG],3]\n[[AUS,IAH,AKL,WLG],3]\n[[AUS,LAX,SYD,WLG],3]\n[[AUS,LAX,MEL,WLG],3]\n[[AUS,LAX,AKL,WLG],3]\n[[AUS,LAX,BNE,WLG],3]\n[[AUS,SFO,SYD,WLG],3]\n[[AUS,SFO,AKL,WLG],3]\n[[AUS,YYZ,HND,SYD,WLG],4]\n[[AUS,YYZ,HND,AKL,WLG],4]\n```\n\nTo return the results with the longer routes coming first we could use\nthe values in the sack along with an *order* step.\n\n``` java\ng.withSack(0).V().\n  has('code','AUS').\n  repeat(out().simplePath().sack(sum).by(constant(1))).\n    until(has('code','WLG')).\n  limit(10).\n  order().by(sack(),desc).\n  local(union(path().by('code'),sack()).fold())\n```\n\nThis time the four hop routes appear first in the results.\n\n``` java\n[[AUS,YYZ,HND,SYD,WLG],4]\n[[AUS,YYZ,HND,AKL,WLG],4]\n[[AUS,DFW,SYD,WLG],3]\n[[AUS,IAH,AKL,WLG],3]\n[[AUS,LAX,SYD,WLG],3]\n[[AUS,LAX,MEL,WLG],3]\n[[AUS,LAX,AKL,WLG],3]\n[[AUS,LAX,BNE,WLG],3]\n[[AUS,SFO,SYD,WLG],3]\n[[AUS,SFO,AKL,WLG],3]\n```\n\nAs a side note, if we wanted to include the path's length rather than\nthe hop count we could change the query as shown below. In this case a\n*sack* step is not needed as we can just count the length of each path.\n\n``` java\ng.V().has('code','AUS').\n      repeat(out().simplePath()).\n        until(has('code','WLG')).\n      limit(10).\n      local(union(path().by('code'),path().count(local)).fold())\n```\n\nThis time the number shown is one bigger than in the previous example as\nthe starting airport is included in the overall count.\n\n``` java\n[[AUS,DFW,SYD,WLG],4]\n[[AUS,IAH,AKL,WLG],4]\n[[AUS,LAX,SYD,WLG],4]\n[[AUS,LAX,MEL,WLG],4]\n[[AUS,LAX,AKL,WLG],4]\n[[AUS,LAX,BNE,WLG],4]\n[[AUS,SFO,SYD,WLG],4]\n[[AUS,SFO,AKL,WLG],4]\n[[AUS,YYZ,HND,SYD,WLG],5]\n[[AUS,YYZ,HND,AKL,WLG],5]\n```",
            "children": []
          },
          {
            "level": "4.11.6",
            "title": "4.11.6. Using boolean operators with a *sack* {#sackbooleans}",
            "content": "You can also use the boolean operators *or* and *and* when working with\na *sack*. The examples below just test the basic functionality using\nconstants of *true* and *false*. In the first example the result\nreturned in the *sack* is *false* as we used an *and* operator to *and*\ntogether the sack's initial value of *true* and a constant value of\n*false*.\n\n``` java\ng.V(3).sack(assign).by(constant(true)).sack(and).by(constant(false)).sack()\n\nfalse\n```\n\nThis time we replace the *and* operator with an *or* and the result, as\nwe would expect, is *true*.\n\n``` java\ng.V(3).sack(assign).by(constant(true)).sack(or).by(constant(false)).sack()\n\ntrue\n```\n\nWhile proving we can do boolean operations using constants is\ninteresting it is perhaps not that useful. Where this functionality\nbecomes more interesting is if the values being used come from, for\nexample, a vertex property. So let's create a couple of vertices that\neach have a boolean property.\n\n``` java\ng.addV('happy').property('happy',true)\n\nv[54852]\n\ng.addV('sad').property('happy',false)\n\nv[54854]\n```\n\nWe can now write a query that uses a boolean operator to generate a\nresult in our sack. The example below is a bit arbitrary but it shows\nhow the boolean operators can be used. We start at the vertex with an ID\nof 3, initialize a *sack* with the constant *true* and the use the *and*\noperator against the *happy* property of the vertex with a label of\n*happy*. We return the results in a path, which will contain the\nstarting vertex and the results of the *and* operation. The result of\nthe *and* is *true* as the *happy* vertex has a value of *true* for its\n*happy* property.\n\n``` java\ng.V(3).sack(assign).by(constant(true)).sack(and).\n       by(V().hasLabel('happy').values('happy')).sack().path()\n\n[v[3],true]\n```\n\nIf we repeat the query but this time use the *sad* vertex, we get the\nexpected result of *false* from the *and* operation.\n\n``` java\ng.V(3).sack(assign).by(constant(true)).sack(and).\n       by(V().hasLabel('sad').values('happy')).sack().path()\n\n[v[3],false]\n```",
            "children": []
          },
          {
            "level": "4.11.7",
            "title": "4.11.7. Using *addAll* and lists with a *sack* {#sackaddall}",
            "content": "So far we have looked at using numbers and boolean values with a sack.\nHowever, sacks can also contain lists and, as we shall see later, maps.\n\nThe example below initializes a sack with an empty list *\\\"\\[\\]\\\"* and\nthen uses the *addAll* operator to store the same results we have seen\ngenerated above in a list. Note that a *fold* step is used to create a\nlist of values that can then be added to the sack. Later we shall look\nat other ways to build up lists with sacks that do not first fold all of\nthe traversal results into a list.\n\n``` java\ng.withSack([]).V().has('code','SAF').out().\n               values('runways').fold().sack(addAll).sack()\n\n[7,4,3,6]\n```\n\nYou might be thinking, and you would be right, that we could have\nachieved the same result without using a *sack* at all and just using a\nfold *step* as shown below. However, the power of using a *sack* becomes\napparent when you need to build up a list containing the results of\nvarious parts of the query.\n\n``` java\ng.V().has('code','SAF').out().values('runways').fold()\n\n[7,4,3,6]\n```\n\nThe next example, below, shows how a list can be built up using more\nthan one *sack* step. The *sack* is initialized with an empty list and\nthe runway counts of the airports reachable from SAF are again added\ninitially to the list using the *addAll* operator. Having done that we\nadd the runway counts for the airports reachable from AUS to the sack.\nYou can see that the output starts with the same 7,4,3,6 sequence we\nhave seen before but is then followed by all the other values that were\nadded by the second *sack* step.\n\n``` java\ng.withSack([]).V().has('code','SAF').out().\n               values('runways').fold().sack(addAll).\n               V().has('code','AUS').out().values('runways').fold().\n               sack(addAll).sack()\n\n[7,4,3,6,3,4,6,5,2,4,2,4,3,2,4,2,4,4,3,3,3,4,4,5,3,3,2,2,2,1,4,1,4,5,4,6,3,3,7,2,4,5,4,4,4,4,4,8,3,3,3,4,3,3,1,3,2,4,4,6,2,3,4,3,3,4]\n```\n\nFinally, here is the previous query again but this time the *sack* is\ninitialized with a list that already has some values in it. You can see\nfrom the output that the values we generated above are added after the\n1,1,1,1 sequence that the sack was initialized with.\n\n``` java\ng.withSack([1,1,1,1]).\n     V().has('code','SAF').out().\n     values('runways').fold().sack(addAll).\n     V().has('code','AUS').out().values('runways').fold().\n     sack(addAll).sack()\n\n[1,1,1,1,7,4,3,6,3,4,6,5,2,4,2,4,3,2,4,2,4,4,3,3,3,4,4,5,3,3,2,2,2,1,4,1,4,5,4,6,3,3,7,2,4,5,4,4,4,4,4,8,3,3,3,4,3,3,1,3,2,4,4,6,2,3,4,3,3,4]\n```\n\nSo far, all of the examples have used a *fold* step before the *sack*\nstep. While this gives us a useful result, it may not always be the\nresult that we want. To put it another way, what we get back is a single\nlist containing all of the values that we generated during the\ntraversal. In some cases what we actually want might be a set of lists\nwhere each list contains whatever the *sack* was initialized with plus\njust the values specific to each path the traverser takes. In other\nwords, we want the *sack* to have more of a local scope and not act like\na global variable.\n\nWhen I was thinking about this and doing some experiments using the\nGremlin Console, my first thought was \\\"I can use a *local* step for\nthis\\\". So, I initially tried the query shown below. However, as you can\nsee, while this definitely generated some different output, it did not\ngenerate what I wanted.\n\n``` java\ng.withSack([1,1,1,1]).V().has('code','SAF').out().\n     values('runways').local(fold().sack(addAll)).sack()\n\n[1,1,1,1,7]\n[1,1,1,1,7,4]\n[1,1,1,1,7,4,3]\n[1,1,1,1,7,4,3,6]\n```\n\nWhat is happening above is that the *sack* is still acting more like a\nglobal variable than a local one. Each *sack* step generated a list that\nwas based on the previous one.\n\nTo get the results I wanted, I needed to use a *clone* operation. This\nquery uses the Groovy closure or *Lambda* syntax. We will investigate\nthat syntax more a bit later in the \\\"[Using Lambda\nfunctions](#lambdas)\\\" section but for now all we need to know is that\nthe *clone* will ensure that each traverser gets its own copy of the\noriginal sack and is not affected by what other traversers do to their\nsacks. Remember that a Gremlin query, or traversal, in essence causes a\nset of traversers to follow the paths through the graph that your query\ndemands.\n\n``` java\ng.withSack{[1,1,1,1]}{it.clone()}V().has('code','SAF').\n       out().values('runways').local(fold().sack(addAll)).sack()\n\n[1,1,1,1,7]\n[1,1,1,1,4]\n[1,1,1,1,3]\n[1,1,1,1,6]\n```\n\nLater in the \\\"[Using lambdas with steps](#lambdasack)\\\" section we will\nrevisit the topic of *sacks* and lambda expressions and see other ways\nthat we could have written the previous query.",
            "children": []
          },
          {
            "level": "4.11.8",
            "title": "4.11.8. Comparing properties and constants to the value of a sack {#sackpredicate}",
            "content": "During a traversal you may want to incrementally modify a sack and then\ncompare a vertex or edge property against the current contents of a\nsack. The examples below show ways of doing this. To keep things simple,\ninitially we will use a sack that is initialized to a value of six and\ndoes not change. This demonstrates how to compare each airport's runway\ncount against the value stored in the sack.\n\n``` java\ng.withSack(6).V().\n  hasLabel('airport').as('a').\n  where(gt('a')).\n    by('runways').\n    by(sack()).\n  values('code')\n\nDFW\nORD\n```\n\nAs I mentioned in the \\\"[A warning that the and steps can also be memory\nintensive](#pathstepwarn)\\\" section, using an *as* step to remember a\nprior part of a traversal can be expensive in terms of memory usage.\nThis will not be an issue with small graphs such as `air-routes`, but\ncan be problematic when working with larger graphs. The query can be\nrewritten without the use of an *as* step as shown below.\n\n``` java\ng.withSack(6).V().\n  hasLabel('airport').\n  filter(project('a','b').\n           by('runways').\n           by(sack()).\n         where('a', gt('b'))).\n  values('code')\n\nDFW\nORD\n```\n\nObviously, while these examples demonstrate the concept, in reality we\nhave not done anything that truly warrants use of a *sack* step so far.\nThe query could easily have been written as shown below. However,\nhopefully this gives you some basic building blocks that enable sack and\nproperty values to be compared.\n\n``` java\ng.V().has('airport','runways',gt(6)).values('code')\n\nDFW\nORD\n```\n\nLet's change our query to make the use of a sack more interesting. The\nquery below starts at Santa Fe (SAF) and traverses outgoing edges until\nthe distance travelled exceeds 10,000 miles. Only five results are\nreturned.\n\n``` java\ng.withSack(0).V().\n  has('code','SAF').\n  repeat(outE().\n         sack(sum).by('dist').\n         inV()).\n  until(sack().is(gt(10000))).\n  limit(5).\n  path().\n    by('code').\n    by('dist')\n```\n\nWhen we run the query we get back a series of routes that stop as soon\nas we have travelled more than 10,000 miles.\n\n``` java\n[SAF,549,DFW,1560,BOS,7952,HKG]\n[SAF,549,DFW,1230,LAX,8287,DOH]\n[SAF,549,DFW,1230,LAX,8372,AUH]\n[SAF,549,DFW,1230,LAX,8314,JED]\n[SAF,549,DFW,1230,LAX,8246,RUH]\n```\n\nFinally, let's modify the query again to keep following routes starting\nat SAF, but this time adding an additional constraint that each route\nmust be no more than 2,500 miles. We keep going until we have travelled\nmore than 8,000 miles. This again demonstrates how we can use a sack to\nstore a running total over the course of a graph traversal. This time,\nthe path that was followed along with the total distance are combined\nusing a *union* step. I also added a *simplePath* step to the query to\nmake sure we do not revisit airports.\n\n::: tip\nSplitting long queries over multiple lines makes them easier to read and\nunderstand.\n:::\n\nYou will notice that I have split the queries in this section over\nmultiple lines to aid readability. As your queries become more complex\nthis becomes more important.\n\n``` java\ng.withSack(0).\n  V().\n  has('code','SAF').\n  repeat(outE().\n         has('dist',lte(2500)).\n         sack(sum).by('dist').\n         inV().\n         simplePath()).\n  until(sack().is(gt(8000))).\n  limit(5).\n  local(union(path().\n                by('code').\n                by('dist').\n              unfold(),\n              sack()).\n        fold())\n```\n\nThe results from running the modified query are shown below.\n\n``` java\n[SAF,708,LAX,2481,OGG,2401,SMF,2492,EWR,8082]\n[SAF,708,LAX,2481,OGG,2401,SMF,2459,HNL,8049]\n[SAF,708,LAX,2481,OGG,2352,SJC,2462,LIH,8003]\n[SAF,708,LAX,2500,KOA,2375,OAK,2440,BWI,8023]\n[SAF,708,LAX,2500,KOA,2375,OAK,2453,LIH,8036]\n```",
            "children": []
          }
        ]
      },
      {
        "level": "4.12",
        "title": "4.12. Using Lambda functions {#lambdas}",
        "content": "Gremlin allows you to include a code fragment (sometimes called a Lambda\nfunction or a closure) as part of a query. This is typically done as\npart of a *filter*, *map* or *sideEffect* step but there are other\nplaces where you will find this concept used such as when working with\n*sacks*. This technique provides a lot of additional flexibility in how\nqueries can be written. However, care should be used. When processing\nyour query, Gremlin will try to optimize it as best as it can. For\nregular traversal steps such as *out* and *has* Gremlin will do this\noptimization for you. However for closures (code inside braces *{}*)\nGremlin cannot do this and will just pass the closure on to the\nunderlying runtime. With people just getting started with Gremlin there\nis a great temptation to over use in-line code. This is a natural thing\nto want to do as for programmers it feels like the programming they are\nused to. However, there is often, if not always, a pure Gremlin\ntraversal step that can be used to do what is needed. Of course with all\nrules there are exceptions.\n\n::: note\nFor reasons of security not all graph databases, especially those that\nare managed as hosted services, allow lambdas to be included in queries.\nYou should always check the documentation for the graph database that\nyou are using.\n:::\n\nBy way of a very simple example, the code below declares a variable\n*\\\"c\\\"* and initializes it to zero. The Gremlin query that follows then\nadds one to *\\\"c\\\"* each time it finds an airport vertex located in\nOregon. We then use a *println* to display the updated value for\n*\\\"c\\\"*.\n\n``` java\nc = 0\ng.V().has('region','US-OR').sideEffect{ c += 1 }.values('code').fold()\n\nprintln \"I found ${c} airports in Oregon\"\n```\n\nWhen we run our query here is what comes back.\n\n``` java\n[PDX,EUG,LMT,MFR,OTH,RDM,PDT]\nI found 7 airports in Oregon\n```\n\nOf course, in reality we would probably just use a *count* when counting\nthings or put them into a list and look at the size of the list returned\nbut the above example gives a nice, and hopefully easy to understand,\nexample of a closure being used as part of a *sideEffect* step.\n\nFor completeness, here is the query re-written a couple of different\nways without the use of a *sideEffect* or closures. If all we wanted was\nthe count we could do this of course.\n\n``` java\nnum = g.V().has('region','US-OR').values('code').count().next()\nprintln \"I found ${num} airports in Oregon\"\n\nI found 7 airports in Oregon\n```\n\nIf we wanted to save a list of the airport codes found and also count\nthem we could do this.\n\n``` java\noregon = []\ng.V().has('region','US-OR').values('code').fill(oregon);[]\nprintln oregon\nprintln \"I found ${oregon.size} airports in Oregon\"\n```\n\nHere is the output, this time with the airport codes and the count.\n\n``` java\n[PDX, EUG, LMT, MFR, OTH, RDM, PDT]\nI found 7 airports in Oregon\n```\n\nHere is another example of a closure being used where a *has* step could\nand should have been used instead.\n\n``` java\n// What airports are located in London?\ng.V().hasLabel('airport').filter{it.get().property('city').value() ==\"London\"}\n```\n\nHere is the same query just using the *has()* step. This is a case where\nwe should not be using a lambda function as Gremlin can handle this just\nfine all by itself.\n\n``` java\n// What airports are located in London?\ng.V().hasLabel('airport').has('city','London')\n```\n\nI think you will agree that the second version is a lot simpler to read\nand enables Gremlin to do its thing.\n\nHere is one more example of a query that contains a *sideEffect* step.\nThe main part of the query finds airports with 6 runways and counts\nthem. That result will still be returned but the side effect will also\ncause the codes of those airports to also be printed. This is a bit of a\ncontrived example but it shows how *sideEffect* behaves when combined\nwith a closure.\n\n``` java\n// Example of the 'sideEffect' step\ng.V().has('runways',6).sideEffect{print it.get().values('code').next()+\" \"}.count()\n```\n\n::: tip\nThe moral here is, avoid closures unless you can genuinely find no other\nway to achieve what you need. It is fair I think to observe that\nsometimes coming up with a closure to do what you want is easier than\nfiguring out the pure Gremlin way to do it but if at all possible using\njust Gremlin steps is still the recommended path to take. Lambda\nfunctions in general are discouraged.\n:::\n\nGremlin currently does not have any regular expression support built in\nto the language. However, as we will explore later in the \\\"[Additional\nJanusGraph text search predicates](#janpred)\\\" section, JanusGraph does\nprovide some support. When working with a graph, such as TinkerGraph,\nthat has no built in regular expression support you can use a *filter*\nstep combined with a Lambda as shown in the following two examples. The\nexamples take advantage of methods provided by the Java String class.\nSupport for additional text search predicates is likely to appear in\nfuture Apache TinkerPop releases.\n\n``` java\ng.V().hasLabel('airport').\n      filter{ it.get().value('city').startsWith('Dal')}.\n      values('city')\n```\n\nWhen the query is run, all the airport city names matching the pattern\nare found.\n\n``` java\nDallas\nDallas\nDalaman\nDalian\nDalcahue\nDalat\nDalanzadgad\n```\n\nThe next example uses a *filter* step combined with a closure to find\nany airport vertex that has a description containing the letter *\\\"F\\\"*\nfollowed by a period, as in *\\\"F.\\\"*. While this makes an interesting\nexample, there are other ways to achieve this result. One such way would\nbe to used a mixed index and special text searching predicates. That,\nhowever, is a topic for quite a bit later on.\n\n``` java\ng.V().hasLabel('airport').as('a').values('desc').\n     filter{it.toString().contains('F.')}.select('a').\n     local(values('code','desc').fold())\n\n[JFK,New York John F. Kennedy International Airport]\n[BDA,Bermuda, L.F. Wade International International Airport]\n[SLU,George F. L. Charles Airport]\n[EUX,F. D. Roosevelt Airport]\n```\n\nYou will see more examples of how to use Lambda expressions with the\n*filter* step in the \\\"[Using regular expressions to do fuzzy\nsearches](#fuzzyregs)\\\" section.",
        "children": [
          {
            "level": "4.12.1",
            "title": "4.12.1. Introducing the *Map* step {#mapstep}",
            "content": "The *map* step will be familiar to users of programming languages such\nas Ruby, Python or indeed Groovy. It is often useful to be able to take\na set of results, or in the case of Gremlin, the current state of a\ngraph traversal, and modify it in some way before passing on those\nresults to the next part of the traversal. This is what the *map* step\nallows us to do.\n\nThe *map* step can accept a traversal or a closure as input. The results\nof the traversal or closure will be passed on to the next step in the\noverall traversal. Below is a simple example of a *map* step using a\ntraversal to modify what is passed on.\n\n``` java\ng.V().hasLabel('airport').limit(10).map(properties('city'))\n```\n\nWhen this query is run the output returned is the selected vertex\nproperties for each of the 10 airports that were selected.\n\n``` java\nvp[city->Atlanta]\nvp[city->Anchorage]\nvp[city->Austin]\nvp[city->Nashville]\nvp[city->Boston]\nvp[city->Baltimore]\nvp[city->Washington D.C.]\nvp[city->Dallas]\nvp[city->Fort Lauderdale]\nvp[city->Washington D.C.]\n```\n\nWe could go one step further and have the *map* step produce a key and\nvalue map for us.\n\n``` java\n g.V().hasLabel('airport').limit(10).\n       map(properties('city').group().by(key()).by(value()))\n\n[city:Atlanta]\n[city:Anchorage]\n[city:Austin]\n[city:Nashville]\n[city:Boston]\n[city:Baltimore]\n[city:Washington D.C.]\n[city:Dallas]\n[city:Fort Lauderdale]\n[city:Washington D.C.]\n```\n\nAs I mentioned above, in many cases, a *map* step is used in the middle\nof a query to change what is passed on to the next step. The example\nbelow takes the output from the *map* step and sorts the results in\ndescending order based on the city names. Obviously there are simpler\nways we could write this query but this demonstrates what *map* does\nquite well.\n\n``` java\ng.V().hasLabel('airport').limit(10).\n      map(properties('city').group().by(key()).by(value())).\n      unfold().order().by(values,asc)\n```\n\nHere is the output from running the query showing the sorted city names.\n\n``` java\ncity=Anchorage\ncity=Atlanta\ncity=Austin\ncity=Baltimore\ncity=Boston\ncity=Dallas\ncity=Fort Lauderdale\ncity=Nashville\ncity=Washington D.C.\ncity=Washington D.C.\n```\n\nIn some cases there are other steps, such as the *values* step that can\nbe used as a shorthand form of a *map* step. The following two queries\nyield the same results for example. There is no need to write an\nexplicit *map* step when a shorthand form exists.\n\n``` java\ng.V().hasLabel('airport').limit(10).map(values('city')).fold()\n\n[Atlanta,Anchorage,Austin,Nashville,Boston,Baltimore,Washington D.C.,Dallas,Fort Lauderdale,Washington D.C.]\n\ng.V().hasLabel('airport').limit(10).values('city').fold()\n\n[Atlanta,Anchorage,Austin,Nashville,Boston,Baltimore,Washington D.C.,Dallas,Fort Lauderdale,Washington D.C.]\n```\n\nNow let's look at an example where a lambda function (closure) is used.\nFirst of all, take a look at the query below. It simply returns us a\nlist containing the IDs of the first ten airports in the graph.\n\n``` java\ng.V().hasLabel('airport').limit(10).id().fold()\n\n[1,2,3,4,5,6,7,8,9,10]\n```\n\nImagine we wanted to write a query, similar to the one above, that will\nmodify each of those IDs returned in the query above by adding one to\neach. Take a look at the query below. We have introduced a *map* step.\nThe *map* step takes as a parameter a closure (or lambda) function\ntelling it how we want it to operate on the values flowing in to it. The\n*it* is Groovy syntax for *\\\"the thing that came in\\\"* (in this case a\ntraversal). The *get* is needed to gain access to the current vertex and\nits properties. Lastly we get the *id* of the vertex and add one to it.\nThe modified values are then passed on to the next step of the traversal\nwhere they are made into a list by the *fold* step.\n\n``` java\ng.V().hasLabel('airport').limit(10).map{it.get().id() + 1}.fold()\n\n[2,3,4,5,6,7,8,9,10,11]\n```\n\n::: note\nThis is an area where Groovy and Java have a similar but different\nsyntax. If you wanted to use the query above in a Java program you would\nneed to use the Java lambda function syntax.\n:::\n\nWhat is nice about the *map* step is that it allows us to do within the\nquery itself what we would otherwise have to do after the query was over\nusing a *for each* type of loop construct.\n\nOne other thing to note about the *map* step is that the closure\nprovided can have multiple steps, separated by semi-colons. The\nfollowing query demonstrates this.\n\n``` java\ng.V().hasLabel('airport').limit(10).map{a=1;b=2;c=a+b;it.get().id() + c}.fold()\n\n[4,5,6,7,8,9,10,11,12,13]\n```\n\nNote that only the value from the last expression in the closure is\nreturned from the *map*. So in the example above the result of *c=a+b*,\n3, is added to each ID.\n\nAs we have already seen, there are often multiple ways to achieve the\nsame result when working with Gremlin. It is also true that some ways\nare almost always better than others in terms of performance or some\nother metric. In the \\\"[Introducing as a way to store\nvalues](#sackintro)\\\" we used a *sack* step to add one to a set of\nresults as follows.\n\n``` java\ng.withSack(1).V().has('code','SAF').out().\n              sack(sum).by('runways').sack().fold()\n\n[8,5,4,7]\n```\n\nWe could achieve the same result using a *map* step. However, doing so\nintroduces the need to use a closure which the version using *sack*\navoids. Avoiding unnecessary use of closures is a Gremlin best practice.\n\n``` java\ng.V().has('code','SAF').out().values('runways').map{it.get() + 1}.fold()\n\n[8,5,4,7]\n```\n\nIn the next section we will take a look at some other cases where lambda\nexpressions are very useful as well as a few more examples of the *map*\nstep being used.",
            "children": []
          },
          {
            "level": "4.12.2",
            "title": "4.12.2. Using lambdas with *sack* steps {#lambdasack}",
            "content": "In the \\\"[Using and lists with a ](#sackaddall)\\\" section we introduced\nways in which *sack* steps could operate on lists. Now that we know a\nbit more about the *map* step and how Gremlin can take advantage of\nGroovy closures (lambda functions) we can explore some additional ways\nof working with sacks.\n\nWhen we looked at *sack* steps and lists earlier we used the query below\nas one of the examples.\n\n``` java\ng.withSack{[1,1,1,1]}{it.clone()}V().has('code','SAF').\n       out().values('runways').local(fold().sack(addAll)).sack()\n\n[1,1,1,1,7]\n[1,1,1,1,4]\n[1,1,1,1,3]\n[1,1,1,1,6]\n```\n\nNow that we have looked at *map* steps, another way we could write the\nquery, not necessarily the best way, but it does illustrate use of a\n*map*, is shown below.\n\n``` java\ng.withSack{[1,1,1,1]}{it.clone()}V().has('code','SAF').out().\n     values('runways').map{x->[x]}.sack(addAll).sack()\n\n[1,1,1,1,7]\n[1,1,1,1,4]\n[1,1,1,1,3]\n[1,1,1,1,6]\n```\n\nJust for completeness, here is what would happen if we ran the same\nquery, without the *clone* (or split) being used.\n\n``` java\ng.withSack([1,1,1,1]).V().has('code','SAF').out().\n     values('runways').map{x->[x]}.sack(addAll).sack()\n\n[1,1,1,1,7]\n[1,1,1,1,7,4]\n[1,1,1,1,7,4,3]\n[1,1,1,1,7,4,3,6]\n```\n\nA different way we could write the query, and this is something that we\nhave not yet examined in this book, is to use a closure directly with\nthe *sack* step itself.\n\n``` java\n g.withSack([1,1,1,1]).V().has('code','SAF').out().\n      values('runways').sack{a,v->a+=[v]}.sack()\n\n[1,1,1,1,7]\n[1,1,1,1,4]\n[1,1,1,1,3]\n[1,1,1,1,6]\n```\n\nWe could also initialize the sack with a map *\\\"\\[:\\]*\\\" instead of a\nlist and use a lambda function to manipulate it as shown below.\n\n``` java\ng.withSack{[:]}{it.clone()}.V().has('code','SAF').out().\n     sack {m,v->m[v.values('code').next()]=v.values('runways').next();m}.sack()\n\n[DFW:7]\n[LAX:4]\n[PHX:3]\n[DEN:6]\n```\n\nJust to show what happens, here is the same query with the *clone* step\nremoved.\n\n``` java\ng.withSack([:]).V().has('code','SAF').out().\n     sack {m,v->m[v.values('code').next()]=v.values('runways').next();m}.sack()\n\n[DFW:7]\n[DFW:7,LAX:4]\n[DFW:7,LAX:4,PHX:3]\n[DFW:7,LAX:4,PHX:3,DEN:6]\n```\n\nIf all we wanted back was a single list of key value pairs, such as the\none in the last line of the output above, we can write a query to do\nthat. One way we could do it is to use a *map* and not use a *sack* step\nat all as shown below.\n\n``` java\ng.V().has('code','SAF').out().\n      map{m=[:];m[it.get().values('code').next()]=\n      it.get().values('runways').next();m}.unfold().fold().next().getClass()\n\n[DFW=7,LAX=4,PHX=3,DEN=6]\n```\n\nHowever, doing it using a *sack* feels cleaner in my view, as shown\nbelow. Note that in this case what is returned is a Java LinkedHashMap\ndata structure whereas the previous query generated an ArrayList of\nLinkedHashMap.Entry objects. Also, it is worth noting that all we had to\ndo to get the result that we wanted in this case was to add a *fold*\nstep between the *sack* steps.\n\n``` java\n g.withSack([:]).V().has('code','SAF').out().\n      sack{m,v -> m[v.value('code')]=v.values('runways').next()}.fold().sack()\n\n[DFW:7,LAX:4,PHX:3,DEN:6]\n```\n\nThere are other ways that you might choose to write queries like these,\nthat avoid the use of closures altogether, but hopefully these examples\nshow some interesting ways that closures can be combined with *sack*\nsteps.",
            "children": []
          },
          {
            "level": "4.12.3",
            "title": "4.12.3. Introducing the *flatMap* step {#flatmap}",
            "content": "There are a set of fundamental steps that the other Gremlin query\nlanguage steps build upon. One of those is *map*. Another, that we have\nnot looked at so far in this book, is *flatMap*. The two steps are\nsimilar but have a fundamental difference that may not be obvious from\nthe examples we have looked at so far. The key difference is as follows.\nIf a *map* step receives multiple inputs it only passes on the first one\nit received to the next step whereas a *flatMap* step passes them all\non. Let's look at a couple of examples that demonstrate this and then\nlook at how we can take advantage of this in practice.\n\nThe example below shows what happens when an *out* step is used inside\nof a *map* step. Only the first vertex that was encountered is returned.\n\n``` java\ng.V().has('code','SAF').map(out())\n\nv[8]\n```\n\nIf we do the same experiment but using a *flatMap* step you can see that\nall of the vertices are returned.\n\n``` java\ng.V().has('code','SAF').flatMap(out())\n\nv[8]\nv[13]\nv[20]\nv[31]\n```\n\nWhere a flatMap can be useful is in a case like the one below. The\nexample is a bit contrived but there are situations where being able to\ndo things like this come in quite handy. Take a look at the query below.\nIt starts off by finding the AUS vertex. Next it traverses all of the\noutgoing edges, finds the vertices at the end of those edges and returns\nall the paths travelled. Notice that both the city names and the edge\nare included in the results.\n\n``` java\ng.V().has('code','AUS').outE().inV().\n      path().by('city').by().limit(3)\n\n[Austin,e[3712][3-route->43],Tucson]\n[Austin,e[3713][3-route->45],Philadelphia]\n[Austin,e[3714][3-route->46],Detroit]\n```\n\nLet's imagine we have a good reason for needing to look at the edge but\nthat we don't want the edge to be part of the result. What we can do is\nput the *outE().inV()* part of the traversal inside a *flatMap*. As we\nknow from our tests above, a *flatMap* will return all of the results\npassed into it, which in this case will be the incoming vertices\nconnected to the edges. When we now perform the *path* step, the edge\ndetails are no longer part of the path because they were essentially\nremoved from the path by the *flatMap* step. This is a useful pattern to\nbe aware of as it can come in handy in some cases.\n\n``` java\n// Hide the edge from the path!\ng.V().has('code','AUS').flatMap(outE().inV()).\n      path().by('city').limit(3)\n\n[Austin,Tucson]\n[Austin,Philadelphia]\n[Austin,Detroit]\n```\n\nWe cannot use a *map* step to achieve the same result as it will only\nreturn the first path as shown below.\n\n``` java\ng.V().has('code','AUS').map(outE().inV()).\n      path().by('city').limit(3)\n\n[Austin,Tucson]\n```\n\nOf course, if all we really wanted was the result from the prior query\nwe could just do this.\n\n``` java\ng.V().has('code','AUS').out().path().by('city').limit(3)\n\n[Austin,Tucson]\n[Austin,Philadelphia]\n[Austin,Detroit]\n```\n\nLastly, here is one more case where a *flatMap* can be useful. In the\nexample below I wanted to check the property on an edge as part of a\n*repeat* step but not have the edge itself be included in the resultant\npaths. The query uses the route distance to filter out routes between\nairports that are shorter than 2,000 miles.\n\n``` java\ng.V().has('code','AUS').\n      repeat(flatMap(outE().has('dist',gt(2000)).inV())).\n      times(2).\n      path().\n      limit(5)\n```\n\nWhen the query is run the results returned only include the vertices.\nNote that once again, the *flatMap* step differs from the *map* step in\nthat for each path being explored, it allows the last result generated,\nin this case the result of the *inV* step, to pass to the next step in\nthe traversal.\n\n``` java\n[v[3],v[49],v[61]]\n[v[3],v[49],v[64]]\n[v[3],v[49],v[67]]\n[v[3],v[49],v[69]]\n[v[3],v[49],v[71]]\n```\n\nThe query below has the *flatMap* step removed.\n\n``` java\ng.V().has('code','AUS').\n      repeat(outE().has('dist',gt(2000)).inV()).\n      times(2).\n      path().\n      limit(5)\n```\n\nWhen run, this time the results do indeed include the edges as well as\nthe vertices.\n\n``` java\n[v[3],e[5162][3-route->49],v[49],e[8448][49-route->61],v[61]]\n[v[3],e[5162][3-route->49],v[49],e[8449][49-route->64],v[64]]\n[v[3],e[5162][3-route->49],v[49],e[8450][49-route->67],v[67]]\n[v[3],e[5162][3-route->49],v[49],e[8452][49-route->69],v[69]]\n[v[3],e[5162][3-route->49],v[49],e[8454][49-route->71],v[71]]\n```",
            "children": []
          },
          {
            "level": "4.12.4",
            "title": "4.12.4. Using regular expressions to do fuzzy searches {#fuzzyregs}",
            "content": "Let's take a look at one case where use of closures might be helpful. It\nis a common requirement when working with any kind of database to want\nto do some sort of fuzzy text search or even to search using a regular\nexpression. TinkerPop 3 itself does not provide direct support for this.\nIn other words there currently is no sophisticated text search method\nbeyond the basic *has()* type steps we have looked at above. However,\nthe underlying graph store can still expose such capabilities.\n\n::: note\nMost TinkerPop enabled graph stores that you are likely to use for any\nsort of serious deployment will also be backed by an indexing technology\nlike Solr or Elasticsearch. In those cases some amount of more\nsophisticated search methods will likely be made available to you. You\nshould always check the documentation for the system you are using to\nsee what is recommended.\n:::\n\nWhen working with Tinkergraph and the Gremlin console if we want to do\nany sort of text search beyond very basic things like *city ==\n\\\"Dallas\\\"* then we will have to fall back on the Lambda function\nconcept to take advantage of underlying Groovy and Java features. Note\nthat even in graph systems backed by a real index the examples we are\nabout to look at should still work but may not be the preferred way.\n\nSo let's look at some examples. First of all, every airport in the air\nroutes graph contains a description which will be something like *Dallas\nFort Worth International Airport* in the case of DFW. If we wanted to\nsearch the vertices in the graph for any airport that has the word\n*Dallas* in the description we could take advantage of the Groovy\n*String.contains()* method and do it like this.\n\n``` java\n// Airport descriptions containing the word 'Dallas'\ng.V().hasLabel('airport').filter{it.get().property('desc').value().contains('Dallas')}\n```\n\nWhere things get even more interesting is when you want to use a regular\nexpression as part of a query. Note that the first example below could\nalso be achieved using a Gremlin *within()* step as it is still really\ndoing exact string comparisons but it gives us a template for how to\nwrite any query containing a regular expression. The example that\nfollows finds all airports in cities with names that begin with *Dal* so\nit will find Dallas, Dalaman, Dalian, Dalcahue, Dalat and Dalanzadgad!.\n\n``` java\n// Using a filter to search using a regular expression\ng.V().has('airport','type','airport').filter{it.get().property('city').value ==~/Dallas|Austin/}.values('code')\n\n// A regular expression to find any airport with a city name that begins with \"Dal\"\ng.V().has('airport','type','airport').filter{it.get().property('city').value()==~/^Dal\\w*/}.values('city')\n```\n\nSo in summary it is useful to know about closures and the way you can\nuse them with filters but as stated above - use them sparingly and only\nwhen a \\\"pure Gremlin\\\" alternative does not present itself.\n\n::: note\nWe could actually go one step further and create a custom predicate (see\nnext section) that handles regular expressions for us.\n:::",
            "children": []
          }
        ]
      },
      {
        "level": "4.13",
        "title": "4.13. Creating custom tests (predicates) {#pred}",
        "content": "TinkerPop comes with a set of built in methods that can be used for\ntesting values. These methods are commonly referred to as *predicates*.\nExamples of existing Gremlin predicates include methods like *gte()*,\n*lte()* and *neq()*. Sometimes, however, it is useful to be able to\ndefine your own custom predicate that can be passed in to a *has(*),\n*where()* or *filter()* step as part of a Gremlin query.\n\nThe following example uses the Groovy closure syntax to define a custom\npredicate, called *f*, that tests the two values passed in to see if *x*\nis greater than twice *y*. This new predicate can then be used as part\nof a *has()* step by using it as a parameter to the *test()* method.\nWhen *f* is called, it will be passed two parameters. The first one will\nbe the value returned in response to asking *has()* to return the\nproperty called *longest*. The second parameter passed to *f* will be\nthe value of *a* that we provide. This is a simple example, but shows\nthe flexibility that Gremlin provides for extending the basic\npredicates.\n\n``` java\n// Find the average longest runway length.\na = g.V().hasLabel('airport').values('longest').mean().next()\n\n// Define a custom predicate\nf = {x,y -> x > y*2}\n\n// Find airports with runways more than twice the average maximum length.\ng.V().hasLabel('airport').has('longest',test(f,a)).values('code')\n```",
        "children": [
          {
            "level": "4.13.1",
            "title": "4.13.1. Creating a regular expression predicate {#_creating_a_regular_expression_predicate}",
            "content": "In the previous section we used a closure to filter values using a\nregular expression. Now that we know how to create our own predicates we\ncould go one step further and create a predicate that accepts regular\nexpressions for us.\n\n``` java\n// Create our method\nf = {x,y -> x ==~ y}\n\n// Use it to find any vertices where the description string starts with 'Dal'\ng.V().has('desc',test(f,/^Dal.*/)).values('desc')\n```\n\nWe can actually go one step further and create a custom method called\n*regex* rather than use the *test* method directly. If the following\ncode seems a bit unclear don't worry too much. It works and that may be\nall you need to know. However if you want to understand the TinkerPop\nAPI in more detail the documentation that can be found on the Apache\nTinkerPop web page explains things like *P* in detail. Also remember\nthat Gremlin is written in Groovy/Java and we take advantage of that\nhere as well.\n\nIn the following example, rather than use *test* directly we use the\n*BiPredicate* functional interface that is part of Java 8. *BiPredicate*\nis sometimes referred to was a *two-arity* predicate as it takes two\nparameters. We will create an implementation of the interface called\n*bp*. The interface requires that we provide one method called *test*\nthat does the actual comparison between two objects and returns a simple\ntrue or false result. Like we did in the previous section we simply\nperform a regular expression compare using the *==\\~* operator.\n\nWe can then use our *bp* implementation to build a named closure that we\nwill call *regex*. TinkerPop includes a predicate class P that is an\nimplementation of the Java Predicate functional interface. We we can use\n*P* to build our new *regex* method. We can then pass *regex* directly\nto steps like *has*.\n\n``` java\n// Create a new BiPredicate that handles regular expression pattern matching\nbp = new java.util.function.BiPredicate<String, String>() {\n         boolean test(String val, String pattern) {\n           return val ==~ pattern  }}\n\n// Create a new closure we can use for regular expression pattern matching.\nregex = {new P(bp, it)}\n\n// Use our new closure to find descriptions that start with 'Dal'. As this\n// unwinds, the contents of 'desc' are passed to the test method as the first parameter\n// and the regex pattern as the second paramter.\ng.V().has('desc', regex(/^Dal.*/)).values('desc')\n```",
            "children": []
          }
        ]
      },
      {
        "level": "4.14",
        "title": "4.14. Unrolling the lists returned by *valueMap* {#vmunroll}",
        "content": "In the \\\"[Changes to introduced in TinkerPop 3.4](#tp34vm)\\\" section, I\nshowed some examples that used *by(unfold())* following a *valueMap*\nstep unroll property values. As you may recall, this means that single\nproperty values are not returned wrapped inside lists. This feature was\nintroduced in TinkerPop 3.4. However, you can achieve the same results\nusing earlier versions of TinkerPop, it just takes a bit more work.\n\nIn case you jumped ahead to this section, here is an example of the new\nfeature and the output it produces.\n\n``` java\ng.V().has('code','SFO').valueMap().by(unfold()).unfold()\n\ncountry=US\ncode=SFO\nlongest=11870\ncity=San Francisco\nelev=13\nicao=KSFO\nlon=-122.375\ntype=airport\nregion=US-CA\nrunways=4\nlat=37.6189994812012\ndesc=San Francisco International Airport\n```\n\nWe could use a query like the one below to achieve the same result. A\n*map* step is used to unpackage and then repackage the results of the\n*valueMap* step with the values unrolled from their lists.\n\n``` java\ng.V().has('code','SFO').\n      valueMap().\n      map(unfold().group().by(keys).by(select(values).unfold())).\n      unfold()\n```\n\nThe output looks just like that from the prior query, which is good.\nHowever, there is still an issue with the query. It will not do quite\nwhat we want if any property has a list or set of values associated with\nit.\n\n``` java\ncountry=US\ncode=SFO\nlongest=11870\ncity=San Francisco\nelev=13\nicao=KSFO\nlon=-122.375\ntype=airport\nregion=US-CA\nrunways=4\nlat=37.6189994812012\ndesc=San Francisco International Airport\n```\n\nLet's imagine we wanted to add an additional region classification of\n\\\"Bay Area\\\" to the San Francisco airport vertex. We might do that as\nshown below.\n\n``` java\ng.V().has('code','SFO').property(list,'region','Bay Area')\n```\n\nWe can look at the valueMap for the *region* property to validate we now\nhave a list.\n\n``` java\ng.V().has('code','SFO').valueMap('region')\n\n[region:[US-CA,Bay Area]]\n```\n\nIf we were to use the *map* step that we just created, it would try to\nunroll this property which in this case is not what we want as we want\nto preserve the list. We can modify this a little to include a *choose*\nstep that only unrolls the list if it has a length of one.\n\n``` java\ng.V().has('code','SFO').\n      valueMap().\n      map(unfold().\n        group().\n          by(keys).\n          by(choose(select(values).count(local).is(1),\n                    select(values).unfold(),\n                    select(values)))).\n      unfold()\n```\n\nThis time the results are still unrolled except for the *region*\nproperty which remained a list.\n\n``` java\ncountry=US\ncode=SFO\nlongest=11870\ncity=San Francisco\nelev=13\nicao=KSFO\nlon=-122.375\ntype=airport\nregion=[US-CA, Bay Area]\nrunways=4\nlat=37.6189994812012\ndesc=San Francisco International Airport\n```",
        "children": []
      },
      {
        "level": "4.15",
        "title": "4.15. Using graph variables to associate metadata with a graph {#graphvars}",
        "content": "TinkerPop 3 introduced the concept of graph variables. A graph variable\nis a key/value pair that can be associated with the graph itself. Graph\nvariables are not considered part of the graph that you would process\nwith Gremlin traversals but are in essence a way to associate metadata\nwith a graph. You can set and retrieve graph variables using the\n*variables* method of the graph object. Let's assume I wanted to add\nsome metadata that allowed me to record who the maintainer of the\n*air-routes* graph is and when it was last updated. We could do that as\nfollows.\n\n``` java\ngraph.variables().set('maintainer','Kelvin')\ngraph.variables().set('updated','July 18th 2017')\n```\n\nYou can use any string that makes sense to you when naming your graph\nvariable keys. We can use the *keys* method to retrieve the names of any\nkeys currently in place as graph variables.\n\n``` java\ngraph.variables().keys()\n\nupdated\nmaintainer\n```\n\nThe *asMap* method will return any graph variables that are currently\nset as a map of key/value pairs.\n\n``` java\ngraph.variables().asMap()\n\nupdated=July 18th 2017\nmaintainer=Kelvin\n```\n\nWe can use the *get* method to retrieve the value of a particular key.\nNote that the value returned is an instance of the *java.util.Optional*\nclass.\n\n``` java\ngraph.variables().get('updated')\n\nOptional[July 18th 2017]\n```\n\nIf you want to delete a graph variable you can use the *remove* method.\nIn this next example we will delete the *maintainer* graph variable and\nre-query the variable map to prove it has been deleted.\n\n``` java\ngraph.variables().remove('maintainer')\ngraph.variables().asMap()\n\nupdated=July 18th 2017\n```",
        "children": []
      },
      {
        "level": "4.16",
        "title": "4.16. Turning graphs into trees {#tre}",
        "content": "TinkerPop defines a Tree API but it is not that well fleshed out and has\nnot been updated in a long time. The *tree* step allows you to create a\ntree from part of a graph using a Gremlin traversal. The example below\ncreates a tree, of depth 3, where the Austin (AUS) vertex is the root of\nthe tree. The next level of the tree is all vertices directly connected\nto AUS. The third level is made up of all the vertices connected by\nroutes to the vertices in the previous level.\n\n``` java\n//Generate a tree the AUS vertex and its neighbors and their neighbors\ntree = g.V().has('code','AUS').\n             repeat(out()).\n               times(2).\n             tree().by('code').next()\n```\n\nThe object returned to our variable *tree* will be an instance of the\n*org.apache.tinkerpop.gremlin.process.traversal.step.util.Tree* class.\nThat class provides a set of methods that can be used when working with\na Tree.\n\n``` java\n// Look at part of the tree directly\ntree['AUS']['DFW']\n\n// You can also use the TinkerPop Tree API to work with the tree\ntree.getLeafObjects()\ntree.getObjectsAtDepth(1)\ntree.getObjectsAtDepth(1)\ntree.getObjectsAtDepth(2)\n```\n\nWe will see the Tree API used again in the \\\"[Modelling an ordered\nbinary tree as a graph](#btree)\\\" section later on.",
        "children": []
      },
      {
        "level": "4.17",
        "title": "4.17. Creating a sub graph {#subgraph}",
        "content": "Using Gremlin, you can create a subgraph which is a subset of the\nvertices and edges in a larger graph you are working with. Once created,\nto work with a sub graph, you create a traversal source object specific\nto that new graph and distinct from the one being used to process the\nmain graph. Subgraphs are created using the *subgraph* traversal step.\nNote that *subgraph* works with edges (not vertices) and adds both those\nedges and the vertices that they connect with to the new subgraph being\ncreated.\n\n::: tip\nYou can find all of the sample data in the book's GitHub repository.\n<https://github.com/krlawrence/graph/tree/main/sample-data>\n:::\n\nLet's start with a simple example. One of the sample data sets shipped\nwith this book is a small version of the main *\\'air-routes*\\' graph\ncalled `air-routes-small.graphml`. It contains routes between just the\nfirst 46 airports in the full graph. We can quite easily write a query\nto generate the subgraph representing the flights between those airports\nby extracting the edges and vertices from the full graph. Take a look at\nthe query below. First we find all the vertices that have an ID between\n1 and 46 inclusive. Then we find all of their outgoing edges but filter\nout any that do not also end up at an airport within the same ID range\nof 1 through 46. Lastly we use a *subgraph* step to add those edges and\nvertices to a new subgraph. Note that the *subgraph* step has to be\ngiven a label. In this case I just used *\\'a\\'*. This allows us, should\nwe need to, to add to a new subgraph from more that one part of a\ntraversal. In this case we have no more to add so a *cap* step is used\nto complete the creating of the *subgraph*. The variable *subg* will now\ncontain a reference to the newly created graph.\n\n``` java\nsubg=g.V(1..46).outE().\n       filter(inV().hasId(within(1L..46L))).\n       subgraph('a').cap('a').next()\n```\n\nNote that when we run the query, Gremlin shows is that we created a new\nTinkerGraph containing 46 vertices and 1326 edges.\n\n``` java\ntinkergraph[vertices:46 edges:1326]\n```\n\nNow that the subgraph is created, we need to create a traversal source\nobject for it so that we can issue queries against it. Gremlin shows us\ndetails of the new traversal source object once it has been created.\n\n``` java\nsgt = subg.traversal()\n\ngraphtraversalsource[tinkergraph[vertices:46 edges:1326], standard]\n```\n\nNow that we have a traversal source object for our newly created\nsubgraph we can run some queries against it.\n\n``` java\n// What airports are in the subgraph?\nsgt.V().values('code').fold()\n\n[ATL,ANC,AUS,BNA,BOS,BWI,DCA,DFW,FLL,IAD,IAH,JFK,LAX,LGA,MCO,MIA,MSP,ORD,PBI,PHX,RDU,SEA,SFO,SJC,TPA,SAN,LGB,SNA,SLC,LAS,DEN,HPN,SAT,MSY,EWR,CID,HNL,HOU,ELP,SJU,CLE,OAK,TUS,SAF,PHL,DTW]\n\n// How many of the 46 airports can you fly to from LAX?\nsgt.V().has('code','LAX').out().count()\n\n40\n```\n\nHere are some more examples of working with subgraphs. The query below\nwill create a subgraph of all vertices and edges directly connected to\nthe Austin (AUS) vertex. Note that using *bothE* means we get incoming\nand outgoing edges. In these examples the more meaningful label\n*subGraph* is used to label the subgraph being created.\n\n``` java\nsubg = g.V().has('code','AUS').bothE().\n             subgraph('subGraph').cap('subGraph').next()\n```\n\nIf we only wanted the outgoing routes from Austin we could change the\nquery to just use an *outE* step instead.\n\n``` java\nsubg = g.V().has('code','AUS').outE('route').\n             subgraph('subGraph').cap('subGraph').next()\n```\n\nThe next example is a little more sophisticated. It will create a\nsubgraph starting with the Austin vertex but this time going out two\nhops. We achieve this using a *repeat* step.\n\n``` java\nsubg = g.V().has('code','AUS').\n       repeat(bothE().subgraph('subGraph').outV()).times(2).\n       cap('subGraph').next()\n\n[tinkergraph[vertices:1294 edges:11336]\n```\n\nAs before we can now work with the newly created subgraph.\n\n``` java\n// Get a traversal source object so that we can traverse\n// the newly created sub graph.\nsgt = subg.traversal()\n\n// What sort of vertices ended up in the subgraph?\nsgt.V().groupCount().by(label)\n\n[continent:2,country:5,airport:1287]\n```\n\nHere is a more complicated example. The query will create a subgraph\njust of airports and routes that are inside Europe. Effectively this\nwill make the Europe only version of the air routes main graph. At first\nglance, this query looks a bit overwhelming but if you read it slowly\nand look at each step you should be able to make sense of what it is\ndoing. It is quite a bit more sophisticated than the previous examples\nin that as well as extracting the routes and airports into the subgraph\nit also extracts all of the relevant countries and continents as\nwell.Note that this query also uses multiple *subgraph* steps.\n\n``` java\n// Create a sub graph only of airports in Europe and routes between those airports\n\nsubg = g.V().hasLabel('continent').has('code','EU').\n             outE('contains').subgraph('eu-air-routes').inV().as('a').\n             inE('contains').subgraph('eu-air-routes').\n             outV().hasLabel('country').\n             select('a').outE().as('r').\n             inV().hasLabel('airport').in().hasLabel('continent').\n             has('code','EU').select('r').subgraph('eu-air-routes').\n             cap('eu-air-routes').next()\n\ntinkergraph[vertices:630 edges:13665]\n```\n\nAs before we can now work with the newly created subgraph.\n\n``` java\n// Create a traversal source object for the subgraph\nsgt = subg.traversal()\n\n// How many routes are there in the subgraph?\nsgt.E().hasLabel('route').count()\n\n12499\n\n// What sort of vertices ended up in the subgraph?\nsgt.V().groupCount().by(label)\n\n[continent:1,country:46,airport:583]\n```\n\nThe following query uses the new Europe only subgraph to find out where\nwe can get to from London Heathrow (LHR) within Europe.\n\n``` java\nsgt.V().has('code','LHR').out().values('code').fold()\n\n[FAO,JMK,FCO,JTR,KBP,AMS,RJK,TLS,PRG,BCN,LED,MAD,OPO,VIE,ZRH,GVA,LCG,BRU,MUC,MAN,INN,CGN,INV,GOT,BLL,VCE,KRK,SNN,MJV,OSL,MPL,ARN,EDI,PUY,GLA,BDS,DME,SVO,ORY,NCE,MXP,ATH,ZAG,BUD,BIO,IBZ,WAW,MLA,SOF,BEG,IST,HAM,STR,PSA,BLQ,NTE,CPH,LUX,DUS,TXL,LIS,GIB,KEF,PMI,AGP,LBA,ABZ,NCL,BSL,SVG,BGO,TLL,ORK,VKO,SPU,BHD,HAJ,LIN,LYS,MRS,OTP,CDG,RTM,FRA,HEL,DUB]\n```\n\nThe ability to create a subgraph from a larger graph is a very powerful\nfeature that Gremlin provides for us. If you have a large graph but only\nwant to work with a part of it it is nice to be able to create a\nsubgraph from it and perhaps even work with that subgraph locally in\nmemory while running some queries.",
        "children": []
      },
      {
        "level": "4.18",
        "title": "4.18. Working with GraphML and GraphSON {#graphmlandjsonintro}",
        "content": "Apache TinkerPop supports the loading and saving of entire graphs using\nGraphML and GraphSON. GraphML is a broadly supported XML standard that\ncan be used to represent entire graphs. GraphSON is a JSON format\ndefined as part of the Apache TinkerPop project that also allows whole\ngraphs to be represented. It is also possible to use GraphSON to\nrepresent the results of a Gremlin graph query in JSON format. In this\nsection we will take a look at all of these topics. The whole subject of\nusing GraphML and GraphSON will be revisited a few more times later in\nthe book. Knowledge of GraphSON becomes especially important once you\nstart working with the Gremlin Server. That topic will be covered in\ndetail as part of the \\\"[INTRODUCING GREMLIN SERVER](#gremlinserver)\\\"\nsection quite a bit later. Both GraphML and GraphSON are covered in\ndetail as part of the \\\"[COMMON GRAPH SERIALIZATION\nFORMATS](#serialize)\\\" section.\n\n::: note\nThe official Apache TinkerPop documentation includes some good coverage\nof this topic. That documentation can be found at\n<http://tinkerpop.apache.org/docs/current/reference/#_gremlin_i_o>.\n:::\n\nThere are currently three versions of GraphSON. The original 1.0 version\nand then versions 2.0 and 3.0 that added type information to the format.\nThese were added in TinkerPop versions 3.2.2 and 3.3 respectively. The\ndefault format unless explicitly specified is currently GraphSON 3.0",
        "children": [
          {
            "level": "4.18.1",
            "title": "4.18.1. Saving (serializing) a graph as GraphML (XML) or GraphSON (JSON) {#sav}",
            "content": "Using TinkerPop 3 you can save a graph either in GraphML or Graphson\nformat. GraphML is an industry standard XML format for describing a\ngraph and is recognized by many other applications such as Gephi.\nGraphSON was defined as part of the TinkerPop project and is less\nbroadly supported outside of TinkerPop enabled tools and graphs.\nHowever, whereas GraphML is considered lossee for some graphs (it does\nnot support all of the data types and structures used by TinkerPop 3).\nGraphSON is not considered lossee.\n\nSaving a graph to a GraphML file can be done using the following Gremlin\nexpression. You might want to try it on one of your graphs and look at\nthe output generated. You can also take a look at the\n`air-routes.graphml` file distribued with this book if you want to look\nat a well laid out (for human readability) GraphML file. Bear in mind\nthat by default, TinkerPop will save your graph in a way that is not\neasily human readable without using a code beautifier first. Most modern\ntext editors can also beautify XML files well.\n\n``` java\n// Save the graph as GraphML\ngraph.io(graphml()).writeGraph('my-graph.graphml')\n```\n\nTinkerPop 3 offers two different JSON packaging options. These are not\nto be confused with the three different syntax versions. The default\nencoding option stores each vertex in a graph and all of its edges as a\nsingle JSON document. This is repeated for every vertex in the graph.\nThis is essentially what is known as *adjacency list* format. If you\nserialize a graph to file using this method and look at the file\nafterwards you will see that each line (which could be very wide) is a\nstandalone JSON obect.\n\nThe second variant is referred to as a *wrapped adjacency list* format.\nIn this flavor all of the vertices and edges are stored in a single\nlarge JSON oject inside of an enclosing *vertices* object.\n\n::: note\nThe GraphSON file generated will not be very human readable without\ndoing some pretty printing on it using something like the Python json\ntool (*python -m json.tool my-graph.json*) or using a text editor that\ncan beautify JSON.\n:::\n\nThe Gremlin line below will create a file containing the *adjacency\nlist* form of GraphSON.\n\n``` java\n// Save the graph as unwrapped JSON\ngraph.io(graphson()).writeGraph(\"my-graph.json\")\n```\n\nThe following will create a file containing the *wrapped adjacency list*\nform of GraphSON.\n\n``` java\n// Create a single (wrapped) JSON file\nfos = new FileOutputStream(\"my-graph.json\")\n\nGraphSONWriter.build().wrapAdjacencyList(true).create().writeGraph(fos,graph)\n```\n\n::: tip\nIf you are ingesting large amounts of data into a TinkerPop 3 enabled\ngraph, the unwrapped flavor of GraphSON is probably a much better choice\nthan GraphML or wrapped GraphSON. Using this format you can stream data\ninto a graph one vertex at a time rather than having to try and send the\nentire graph as a potentially huge JSON file all in one go.\n:::\n\nNote that by default your graph will be saved using the GraphSON 3.0\nformat. Should you wish to use one of the older formats you can still do\nso but will need to explicitly specify which version you want Gremlin to\ngenerate. In the example below the graph is saved using GraphSON 1.0\nformat. Doing this requires the creation and use of a mapper that will\nproduce the format we need.\n\n``` java\nfos = new FileOutputStream(\"my-graph.json\")\n\nmapper = graph.io(IoCore.graphson()).\n         mapper().version(GraphSONVersion.V1_0).create()\n\ngraph.io(IoCore.graphson()).\n    writer().mapper(mapper).\n    create().writeGraph(fos, graph)\n```\n\nIf you want to learn more about the specifics of the GraphML and\nGraphSON formats, they are covered in detail near the end of this book\nin the \\\"[COMMON GRAPH SERIALIZATION FORMATS](#serialize)\\\" section.",
            "children": []
          },
          {
            "level": "4.18.2",
            "title": "4.18.2. Loading a graph stored as GraphML (XML) or GraphSON (JSON) {#reload}",
            "content": "In section 2 we saw how to load the `air-routes.graphml` file. In case\nyou skipped that part lets do a quick recap on loading GraphML files and\nalso look at loading a GraphSON JSON format file.\n\nThe only difference between loading a GraphML file or a GraphSON file is\nin the name of the method from the IoCore Tinkerpop 3 class that we use.\nWhen we want to load a graphML file we specify *IoCore.graphml()*.\n\n``` java\n// Load a graphML file\ngraph.io(IoCore.graphml()).readGraph('my-graph.graphml')\n```\n\nIf we are loading a GraphSON format file we instead specify\n*IoCore.graphson()*.\n\n``` java\n// Load a grapSON file\ngraph.io(IoCore.graphson()).readGraph('my-graph.json')\n```",
            "children": []
          },
          {
            "level": "4.18.3",
            "title": "4.18.3. Turning the results of a query into JSON {#graphsonmapper}",
            "content": "In the sections above we explored how to save and load an entire graph\nusing GraphSON (JSON) or GraphML (XML). However what we have not looked\nat so far are any ways to see query results expressed as JSON objects\nwithin the Gremlin console. As we shall explore in the \\\"[INTRODUCING\nGREMLIN SERVER](#gremlinserver)\\\" section when you communicate with a\nGremlin Server from an application or from the command line using a tool\nsuch as *curl* and send queries to a graph over HTTP or WebSockets the\nresults are returned as JSON objects.\n\n::: note\nThere is not an equivalent XML object mapping capability. This is\nbecause GraphML is designed to contain whole graphs and not query\nresults.\n:::\n\nWhen using the Gremlin Console the results of queries are presented to\nus in a nice and fairly terse way and we are not shown any JSON. Most of\nthe time this is exactly what we want. However, if for any reason you\nwant to see what the JSON for a query result looks like it is possible\nto do just that. You can do this using the regular Gremlin Console and a\nTinkerGraph on your laptop. You do not need to be connected to a Gremlin\nServer to use the examples that I am about to present.\n\nThe first thing you need to do is create an instance of a GraphSON\nmapper that can be used to generate JSON for us from a query result.\nNote that since TinkerPop 3.2.2 there have been multiple versions of the\nGraphSON format. The original 1.0 version did not contain any type\ninformation. Version 2.0 introduced the concept of including data types\nwithin the JSON. As part of TinkerPop 3.3 GraphSON 3.0 was introduced to\nadd a few additional types. All three formats are still supported. The\ndefault is now GraphSON 3.0.\n\nThe example below creates a *GraphSONMapper* object that will generate\nGraphSON 1.0 format JSON.\n\n``` java\njson_mapper = GraphSONMapper.\n                build().\n                version(GraphSONVersion.V1_0).\n                create().\n                createMapper()\n```\n\nNext let's run a simple query that finds the vertex representing the Los\nAngeles (LAX) airport.\n\n``` java\nlax = g.V().has('code','LAX').next()\n```\n\nThe JSON mapper that we just created can now be used to display the\nquery results as JSON\n\n``` java\njson_mapper.writeValueAsString(lax)\n```\n\nHere is the JSON that was generated. I have pretty printed it a bit to\nmake it more readable. Notice that the JSON includes the ID values for\nevery property.\n\n``` json\n{\"id\":13,\"label\":\"airport\",\"type\":\"vertex\",\n \"properties\":\n   {\"country\":[{\"id\":148,\"value\":\"US\"}],\n   \"code\":[{\"id\":149,\"value\":\"LAX\"}],\n   \"longest\":[{\"id\":150,\"value\":12091}],\n   \"city\":[{\"id\":151,\"value\":\"Los Angeles\"}],\n   \"elev\":[{\"id\":152,\"value\":127}],\n   \"icao\":[{\"id\":153,\"value\":\"KLAX\"}],\n   \"lon\":[{\"id\":154,\"value\":-118.4079971}],\n   \"type\":[{\"id\":155,\"value\":\"airport\"}],\n   \"region\":[{\"id\":156,\"value\":\"US-CA\"}],\n   \"runways\":[{\"id\":157,\"value\":4}],\n   \"lat\":[{\"id\":158,\"value\":33.94250107}],\n   \"desc\":[{\"id\":159,\"value\":\"Los Angeles International Airport\"}]}}\n```\n\nLet's create another *GraphSONMapper* instance. This time we will be\ngenerating version 3.0 GraphSON.\n\n``` java\njson_mapper_v3 = GraphSONMapper.\n                 build().\n                 version(GraphSONVersion.V3_0).\n                 create().\n                 createMapper()\n```\n\nAs there is a lot more information contained in the GraphSON 3.0 format\nI decided to use a somewhat simpler query and just generate a *valueMap*\nfor a few of the properties contained in the LAX vertex to avoid having\nto show too much output!\n\n``` java\nlax = g.V().has('code','LAX').valueMap(true,'code','city').next()\n```\n\nAs before, we can use the mapper to generate the JSON.\n\n``` java\njson_mapper_v3.writeValueAsString(lax)\n```\n\nThis time, as you can see, the JSON returned contains a lot more\ninformation. The key thing to notice is the presence of all the *\\@type*\nand *\\@value* keys.\n\n``` json\n{\n  \"@type\": \"g:Map\",\n  \"@value\": [\n    {\n      \"@type\": \"g:T\",\n      \"@value\": \"id\"\n    },\n    {\n      \"@type\": \"g:Int64\",\n      \"@value\": 13\n    },\n    \"code\",\n    {\n      \"@type\": \"g:List\",\n      \"@value\": [\n        \"LAX\"\n      ]\n    },\n    \"city\",\n    {\n      \"@type\": \"g:List\",\n      \"@value\": [\n        \"Los Angeles\"\n      ]\n    },\n    {\n      \"@type\": \"g:T\",\n      \"@value\": \"label\"\n    },\n    \"airport\"\n  ]\n}\n```\n\nAs I mentioned, the subject of JSON will come up again when we start\nlooking at working with a Gremlin Server. This section has hopefully\nshown you how to save and load an entire graph as either GraphML or\nGraphSON and should you so desire to see the results of your queries as\nJSON. Remember that if you do save an entire graph as JSON, unless you\nspecify otherwise, the default format is GraphSON 3.0.",
            "children": []
          }
        ]
      },
      {
        "level": "4.19",
        "title": "4.19. Analyzing the performance of your queries {#performance}",
        "content": "Apache TinkerPop includes a class called TimeUtil that provides methods\nthat you can use to time how long your queries are taking to run. A\nsecond class called ProfileStep provides a way to get a more fine\ngrained analysis of where the time is spent during execution of a query.\nIn this section I am going to provide a few examples of how to use the\nmethods provided to analyze the execution time of a few queries. I ran\nthe tests on a laptop using the Gremlin Console with the *air-routes*\ndata loaded into an in-memory TinkerGraph.",
        "children": [
          {
            "level": "4.19.1",
            "title": "4.19.1. Timing a query - introducing *clock* and *clockWithResult* {#clock}",
            "content": "The *TimeUtil* class provides several methods that can be used when\nworking with time. I am just going to focus on two of them, namely,\n*clock* and *clockWithResult*. These methods allow you to have a query\nrun one or more times while the execution time is tracked. After all\niterations have completed, the average time the query took in\nmilliseconds is returned. Note that, especially for longer queries, the\ntime returned will not appear to be the same as if you tried to measure\nthe same *clock* procedure using a stopwatch. This is because these\nmethods both perform a warm up pass before doing the actual timing. The\nwarm up simply consists of running the query one time before timing\nstarts. This means that for a single timing iteration, the *human\nperceived time* will be roughly double the time returned by the *clock*\nanalysis. Let's take a look at a few examples.\n\nBelow is a very simple example of using a *clock* step to measure the\ntime it takes to find all airport vertices in the graph that are in\nChina. Note that the clock step takes two parameters. The first is an\ninteger telling it how many times to run the query. The second is a\nquery to execute wrapped in braces *\\\"{...​}\\\"*. In other words a\nclosure. In the example below, the query is only run once as a parameter\nof 1 is passed to the *clock* method. From the result we can see that\nrunning this query one time on my laptop took a bit more than 1.3\nmilliseconds.\n\n``` java\nclock(1) {g.V().has('airport','country','CN').next()}\n\n1.364199\n```\n\nTo get a more accurate assessment of how long a query takes it is\nsometimes a good idea to average out the time over multiple attempts.\nThis should reduce the impact of any random system events from impacting\nyour overall result. The example below repeats the previous query but\nmeasures the average time taken across 100 iterations. Note that,\nespecially for longer running queries, the time returned will not be the\nsame as if you tried to time this process yourself using a stopwatch.\nThis is because the clock steps do a warm up pass before doing the\nactual testing. The warm up step basically runs the query one time\nbefore it starts timing anything. This means that for a single iteration\nthe *human perceived time* will be roughly double the time returned by\nthe *clock* analysis. You can see from the results that when averaged\nover 100 iteration the time taken is a bit less. You should not use\nthese numbers as hard and fast answers but rather use them to get a\nsense of in general how long a query takes. If you repeated this test\nfive times you would definitely get five different results of a similar\nbut not identical magnitude.\n\n``` java\nclock(100) {g.V().has('country','CN').next()}\n\n0.70694013\n```\n\nHere is the same query run 1000 times just to verify that the timings\nstay more or less the same.\n\n``` java\nclock(1000) {g.V().has('country','CN').next()}\n\n0.6931818670000001\n```\n\nWe have seen the following query before in the \\\"[Shortest paths\n(between airports) - introducing ](#sp)\\\" section. As you may recall it\nfinds 10 routes between Austin and Agra. Because there are not that many\nways to get to Agra this query requires a lot of graph traversals and so\ntakes a while to complete. Let's time how long it takes to execute this\nquery one time.\n\n``` java\nclock(1){\n    g.V().has('airport','code','AUS').\n          repeat(out()).until(has('code','AGR')).\n          limit(10).path().by('code').toList()}\n\n4643.605562\n```\n\nAs you can see it took quite a bit longer to run than our search for\nChinese airports. In fact it took well over 4 seconds to run. Let's run\nthe same query 100 times and see what the average time taken looks like.\n\n``` java\nclock(100){\n    g.V().has('airport','code','AUS').\n          repeat(out()).until(has('code','AGR')).\n          limit(10).path().by('code').toList()}\n\n4816.6515936999995\n```\n\nSo running the query 100 times gave a very similar result in this case.\nBy way of an interesting observation, notice the difference in time\ntaken if we start in Agra and look for routes to Austin. The average\ntime over 100 iterations is less than 10 milliseconds. So we have\nuncovered an interesting possible optimization. Because there are a lot\nmore ways to get to Austin, finding 10 routes did not take very long.\nThis may not always be possible but keep in mind as you model your graph\nand design your queries that where you start from can make a big\ndifference!\n\n``` java\nclock(100){\n   g.V().has('airport','code','AGR').\n         repeat(out()).until(has('code','AUS')).\n         limit(10).path().by('code').toList()}\n\n9.068097369999998\n```\n\nYou may have noticed that the *clock* method only shows us the time that\na query takes to run and does not show us the actual result of running\nthe query. This is where the *clockWithResult* method comes into play.\nWe can reuse our *airports in China* query but this time notice that we\nalso get the result of the query back.\n\n``` java\nclockWithResult(1) {g.V().has('country','CN').count().next()}\n\n0.918276\n209\n```\n\nIf we run the *Austin to Agra* query using *clockWithResult* you can see\nthat we do indeed get the routes back as well as the timing.\n\n``` java\nclockWithResult(1){\n    g.V().has('airport','code','AUS').\n          repeat(out()).until(has('code','AGR')).\n          limit(10).path().by('code').toList()}\n\n4266.584279\n\n[[AUS,YYZ,BOM,AGR],[AUS,LHR,BOM,AGR],[AUS,FRA,BOM,AGR],[AUS,EWR,BOM,AGR],[AUS,CLE,YYZ,BOM,AGR],[AUS,CLE,EWR,BOM,AGR],[AUS,OAK,EWR,BOM,AGR],[AUS,PHL,EWR,BOM,AGR],[AUS,PHL,YYZ,BOM,AGR],[AUS,PHL,LHR,BOM,AGR]]\n```\n\nJust for fun, the next four queries look for all the ways you can fly\nbetween Austin (AUS) and Los Angeles (LAX) with zero, one, two or three\nstops. The query avoids any routes that revisit Austin and uses\n*simplePath* to avoid repeating the same route twice. As you can see by\nthe time we get to the last query, that takes three stops, the query\ntakes quite a bit of time to complete.\n\n``` java\nclockWithResult(1){\n    g.V().has('code','AUS').as('a').\n          repeat(out().where(neq('a'))).times(1).simplePath().\n          has('code','LAX').path().by('code').count().next()}\n\n1.698357\n1\n```\n\nAs you would expect, looking for routes with exactly one stop, does not\ntake too long.\n\n``` java\nclockWithResult(1) {\n    g.V().has('code','AUS').as('a').\n          repeat(out().where(neq('a'))).times(2).simplePath().\n          has('code','LAX').path().by('code').count().next()}\n\n7.988092999999999\n51\n```\n\nLooking for routes with exactly two stops takes quite a bit longer but\nis still fairly fast.\n\n``` java\nclockWithResult(1) {\n    g.V().has('code','AUS').as('a').\n          repeat(out().where(neq('a'))).times(3).simplePath().\n          has('code','LAX').path().by('code').count().next()}\n\n435.423921\n3389\n```\n\nAs you can see by the time we get to the last query, that looks for\nexactly three stops, things take a lot longer to complete.\n\n``` java\nclockWithResult(1) {\n    g.V().has('code','AUS').as('a').\n          repeat(out().where(neq('a'))).times(4).simplePath().\n          has('code','LAX').path().by('code').count().next()}\n\n35295.633811\n203359\n```\n\nNotice that for the *clock* and *clockWithResult* methods to work\ncorrectly you need to end the query with a termination step such as\n*next* or *toList*. Alternatively you can end the query with *iterate*.\nIn my testing I found things did not always work correctly when using\n*iterate* so I tend to avoid it.",
            "children": []
          },
          {
            "level": "4.19.2",
            "title": "4.19.2. Analyzing where time is spent - introducing *profile* {#profile}",
            "content": "You can use the *profile* step to ask Gremlin to give you a more fine\ngrained summary of where the time is spent processing your query. Take a\nlook at the example below.\n\n``` java\ng.V().has('region','US-TX').out().has('region','US-CA').\n                            out().has('country','DE').profile()\n```\n\nAfter you run the query, instead of showing you the results, Gremlin\nwill show you where the time was spent processing the components of the\nquery.\n\n``` console\nStep                                       Count  Traversers  Time (ms)    % Dur\n===============================================================================\nTinkerGraphStep(vertex,[region.eq(US-TX)])   26          26      1.810     9.71\nVertexStep(OUT,vertex)                      701         701      0.877     4.70\nHasStep([region.eq(US-CA)])                  47          47      0.561     3.01\nVertexStep(OUT,vertex)                     3464        3464     12.035    64.54\nNoOpBarrierStep(2500)                      3464         224      3.157    16.93\nHasStep([country.eq(DE)])                    59           4      0.206     1.11\n   >TOTAL                                     -           -     18.650        -\n```\n\nIf we profile the *Austin to Agra* query from the previous section you\ncan see that almost all the time was spent inside the *repeat* loop\nlooking for routes. In this case that is not surprising but for more\ncomplex queries *profile* can help you to refine them.\n\n``` java\ng.V().has('airport','code','AUS').\n      repeat(out()).until(has('code','AGR')).limit(10).\n      path().by('code').profile()\n```\n\nHere is the *profile* report. I truncated some of the text with\n\\'\\\"...​\\\" so that it will fit on a single page.\n\n``` console\nStep                              Count  Traversers       Time (ms)    % Dur\n============================================================================\nTinkerGraphStep(vertex,[~l...         1           1           2.125     0.02\nRepeatStep([VertexStep(OUT,..        11          11        9357.962    99.97\n  HasStep([code.eq(AGR)])                                  2627.621\n  VertexStep(OUT,vertex)        1799981     1799981         509.392\n  RepeatEndStep                      11          11        8848.030\nRangeGlobalStep(0,10)                10          10           0.278     0.00\nPathStep([value(code)])              10          10           0.126     0.00\n   >TOTAL                             -           -        9360.493        -\n```",
            "children": []
          },
          {
            "level": "4.19.3",
            "title": "4.19.3. Introducing TinkerGraph indexes {#tinkerindex}",
            "content": "TinkerGraph provides a rudimentary indexing capability but using it can\nstill improve overall performance of your queries. Two methods\n*createIndex* and *dropIndex* are provided for creating and deleting\nindexes. Vertex and Edge properties can be indexed as needed. A third\nmethod, *getIndexedKeys* can be used to query what indexes have been\ncreated. The example below runs the query we used in some of our prior\ntests with and without an index being present for the *code* vertex\nproperty.\n\n``` java\nclock(1){\n    g.V().has('code','AUS').repeat(out().simplePath()).\n          until(has('code','AGR')).limit(10).path().by('code').toList()}\n\n2019.8820959999998\n```\n\nLet's now create an index for the *code* property of every vertex and\ntry the query again. Note that *Vertex* as used below is shorthand for\n*Vertex.class*.\n\n``` java\ngraph.createIndex('code',Vertex)\n\n clock(1){\n     g.V().has('code','AUS').repeat(out().simplePath()).\n           until(has('code','AGR')).limit(10).path().by('code').toList()}\n\n1298.386245\n```\n\nWe can query what indexes we have creates as follows.\n\n``` java\ngraph.getIndexedKeys(Vertex)\n\ncode\n```\n\nNow let's drop the index.\n\n``` java\ngraph.dropIndex('code',Vertex)\n```\n\nBecause the air routes graph is small, a Vertex property index has\nlittle effect on overall performance. However, as there are a lot more\nedges, perhaps creating an edge property index could help some queries.\nLet's try an experiment. The following query looks for all edges that\nhave a *dist* property of 1000.\n\n``` java\nclockWithResult(100) {g.E().has('dist',1000).count().next()}\n\n9.80906926\n24\n```\n\nLet's now create an index for the edge property called *dist* and run\nthe query again. We can also, as before, check to see what edge indexes\nhave been created.\n\n``` java\ngraph.createIndex('dist',Edge)\n\ngraph.getIndexedKeys(Edge)\n\ndist\n```\n\nThis time you can see that our index has made a big difference.\n\n``` java\nclockWithResult(100) {g.E().has('dist',1000).count().next()}\n\n0.046712609999999995\n24\n```\n\nThe timing difference between the two queries can be attributed to the\nindex. In the first case every edge in the graph (over 50,000 of them)\nhad to be inspected. In the second case the index was used to go\ndirectly to the edges with a *dist* of 1000 and no searching of all the\nedges was required. Note that the index only helps with exact\ncomparisons. A query such as the one below will not benefit from the\nindex.\n\n``` java\nclockWithResult(100) {g.E().has('dist',gt(1000)).count().next()}\n\n11.980037119999999\n16430\n```\n\nLater on we will take a look at using an index with JanusGraph and look\nat external indexing technologies such as Apache Solr and Elasticsearch\nthat do support more complex types of comparison predicates.",
            "children": []
          }
        ]
      },
      {
        "level": "4.20",
        "title": "4.20. OLTP vs OLAP {#olapoltp}",
        "content": "When discussing graph processing two terms regularly come up. These\nterms are Online Transaction Processing (OLTP) and Online Analytical\nProcessing (OLAP). Most of the queries we have looked at so far\ndefinitely fall into the OLTP category. Queries that only look at a\nsmall part of a graph, often starting at a single node or a small group\nof nodes and traversing out a few hops from there are considered OLTP\noperations. Typically, an OLTP query takes a few seconds or less to run.\nThey are often used in response to a user query where an almost real\ntime answer is needed. Because the air routes graph is small - we can do\neven quite complex queries using little more than a TinkerGraph and the\nGremlin Console. This is not the case if your graph contains billions of\nvertices and edges. That said, I have seen some OLTP type queries, such\nas those looking for routes to remote airports, that can take several\nminutes to run in the TinkerGraph environment.\n\n::: note\nThe TinkerPop documentation has in depth coverage of the various OLAP\ncapabilities that are supported.\n<http://tinkerpop.apache.org/docs/current/reference/#graphcomputer>\n:::\n\nWhere OLAP comes into play is when you want to do detailed analysis\nacross an entire graph. This is especially true as graphs get large and\nrequire powerful clusters of nodes to underpin them. While OLTP queries\ntypically take seconds or less, OLAP queries can often take many minutes\nor even hours to complete.\n\nApache TinkerPop provides significant support for OLAP graph processing\nout of the box and is designed to work well with distributed backend\nsystems and software such as Apache Spark and Apache Hadoop.\n\n::: note\nWhile OLAP processing is typically done using powerful clusters, you can\nrun simple experiments using nothing more than a standalone in memory\nTinkerGraph.\n:::\n\nDetailed coverage of doing OLAP processing is beyond the current scope\nof this book but I am going to give a few simple examples below to at\nleast provide a little insight into what can be done. The TinkerPop\ndocumentation includes in depth coverage of how to perform OLAP\noperations on a TinkerPop enabled graph and I recommend reading it if\nyou plan to perform OLAP style graph processing.",
        "children": [
          {
            "level": "4.20.1",
            "title": "4.20.1. Introducing the TinkerPop Graph Computer {#graphcomputer}",
            "content": "A lot of new capability was added to the TinkerPop framework as part of\nthe version 3 release. One such new capability is the concept of a\n*Graph Computer*. In concrete terms, GraphComputer is a Java interface\nthat other TinkerPop classes implement to provide the capability for\ndifferent back end environments. Along with *GraphComputer*, the concept\nof a *VertexProgram* is also introduced. Vertex Programs allow us to\nspecify the operations that we want to be performed across a graph,\npotentially in conjunction with map reduce operations. TinkerPop comes\nwith a set of pre configured Vertex Programs and vertex program steps.\nOf course you can also write your own.\n\nOne of the pre configured Vertex Programs is Page Rank. Let's take a\nlook next at one way it can be used.",
            "children": []
          },
          {
            "level": "4.20.2",
            "title": "4.20.2. Experiments with Page Rank {#pagerank}",
            "content": "Probably one of, if not the, most famous algorithms in the big data\nworld is *Page Rank*. Originally developed at Google, the Page Rank\nalgorithm was created as a way to measure the relative importance of web\npages. At a high level the algorithm looks at the number of connections\nto a web page and the quality of those connections (as in are they from\na prominent place). That algorithm ports well to a graph database\nenvironment as a graph, like the Web, is a heavily connected data\nstructure. In our graph database environment, we can use a page rank\nalgorithm to assess a graph and compute the likelihood in any given\ntraversal that a particular vertex will get visited. Although the new\nGraph Computer capabilities have been designed from the ground up with\ndistributed systems in mind, it is possible to use a stand a alone\nTinkerGraph to experiment with a few of the capabilities.\n\nThe example below only assumes that you have a TinkerGraph running\nlocally inside the Gremlin Console with the *air-routes* data loaded.\nYou will notice a few differences from the examples we have seen so far\nin this book. First of all, when we create our graph traversal source\nobject, we add a call to *withComputer* to indicate that we plan to be\ndoing some things that require the Graph Computer capabilities. Having\ncreated the traversal source we can setup our page rank. The query\ninitially filters out any vertex that is not an airport as will only\nwant to rank airport vertices. Next a call is made to the *pageRank*\nstep. The *by* modulators tell the page rank algorithm how we want the\nranking done and what label to use for the ranking results. In this case\nwe want to look at outgoing *route* edges and label all results *r*.\nBefore returning the results, we order based on descending ranking\nvalue.\n\n``` java\n// Page rank based on outgoing routes\ng3 = graph.traversal().withComputer()\n\ng3.V().hasLabel('airport').pageRank().by(outE('route')).by('r').\n      order().by('r',desc).valueMap('code','r').limit(10)\n```\n\nHere is the output from running the page rank algorithm. The results\nshow the airport code along with the page rank value that was\ncalculated.\n\n``` java\n[r:[15.527963207609702],code:[IST]]\n[r:[15.005583346944613],code:[DFW]]\n[r:[14.673184454287105],code:[ORD]]\n[r:[14.365370693500969],code:[ATL]]\n[r:[14.099719956639161],code:[PEK]]\n[r:[14.061408826784106],code:[DXB]]\n[r:[13.729782985109942],code:[DEN]]\n[r:[13.552238441619048],code:[DME]]\n[r:[13.502681833743711],code:[FRA]]\n[r:[13.189393240835944],code:[CDG]]\n```\n\nJust as a point of reference, the query below finds the top 10 airports\nwith the most incoming routes.\n\n``` java\ng.V().hasLabel('airport').\n      order().by(inE('route').count(),desc).limit(10).\n      project('a','b').by('code').by(inE('route').count())\n```\n\nAs you can see there is some correlation between the page rank results\nand the airports with the most incoming routes which is perhaps not\nsurprising. However, notice that the page rank algorithm came up with\nsome airports that a simple node degree test did not come up with.\n\n``` java\n[a:FRA,b:282]\n[a:AMS,b:275]\n[a:IST,b:271]\n[a:CDG,b:267]\n[a:MUC,b:240]\n[a:PEK,b:239]\n[a:ORD,b:237]\n[a:DXB,b:237]\n[a:ATL,b:235]\n[a:DFW,b:221]\n```\n\nThe *pageRank* step used in the prior query is a nice and convenient way\nfor us to quickly generate some rankings. However, it is important to\nunderstand how the query would be written if we were to use the Graph\nComputer more directly and submit a Vertex Program. The example below\nsets up a *PageRankVertexProgram* and runs it. Notice that the result we\nget back includes a new graph with 3624 vertices and no edges.\n\n``` java\ndcr = graph.compute().\n      program(PageRankVertexProgram.build().\n      edges(hasLabel('airport').outE('route')).\n      create()).submit().get()\n\nresult[tinkergraph[vertices:3624 edges:0],memory[size:0]]\n```\n\nIn case you are curious, we can check the precise type of the result\nobject that is returned from creating our vertex program.\n\n``` java\ndcr.getClass()\n\nclass org.apache.tinkerpop.gremlin.\n      process.computer.util.DefaultComputerResult\n```\n\nGiven the result we got back was a new graph we can create a new\ntraversal and inspect it. Notice that the Istanbul (IST) vertex in this\ngraph contains an additional property called\n*gremlin.pageRankVertexProgram.pageRank*. This property contains the\npage rank score that was returned for this vertex.\n\n``` java\ng2 = dcr.graph().traversal()\n\ng2.V().has('code','IST').valueMap(true)\n\n[id:161,country:[TR],code:[IST],longest:[9843],gremlin.pageRankVertexProgram.pageRank:[0.0047038762655771775],city:[Istanbul],lon:[28.8145999908],type:[airport],label:airport,elev:[163],icao:[LTBA],region:[TR-34],runways:[3],lat:[40.9768981934],desc:[Ataturk International Airport]]\n```\n\nJust to prove the original graph was untouched, let's check the IST\nvertex in that graph. As you can see there are no new properties\npresent.\n\n``` java\ng.V().has('code','IST').valueMap(true)\n\n[id:161,country:[TR],code:[IST],longest:[9843],city:[Istanbul],lon:[28.8145999908],type:[airport],label:airport,elev:[163],icao:[LTBA],region:[TR-34],runways:[3],lat:[40.9768981934],desc:[Ataturk International Airport]]\n```\n\nFinally let's look at the 10 airports sorted by page rank score in\ndescending order. As you will observe, the scoring system is different\nbut the selected airports are the same as the ones returned by the\nin-line *pageRank* step.\n\n``` java\ng2.V().order().by('gremlin.pageRankVertexProgram.pageRank',desc).limit(10).\n       valueMap('code','gremlin.pageRankVertexProgram.pageRank')\n\n[code:[IST],gremlin.pageRankVertexProgram.pageRank:[0.004594389373424941]]\n[code:[DFW],gremlin.pageRankVertexProgram.pageRank:[0.004440623428637068]]\n[code:[ORD],gremlin.pageRankVertexProgram.pageRank:[0.004342068075230758]]\n[code:[ATL],gremlin.pageRankVertexProgram.pageRank:[0.004251005124367605]]\n[code:[PEK],gremlin.pageRankVertexProgram.pageRank:[0.004172537469821617]]\n[code:[DXB],gremlin.pageRankVertexProgram.pageRank:[0.004161183557641767]]\n[code:[DEN],gremlin.pageRankVertexProgram.pageRank:[0.004063035588247088]]\n[code:[DME],gremlin.pageRankVertexProgram.pageRank:[0.004009614722586433]]\n[code:[FRA],gremlin.pageRankVertexProgram.pageRank:[0.003994862262812258]]\n[code:[CDG],gremlin.pageRankVertexProgram.pageRank:[0.0039023184469861244]]\n```\n\nI have barely scratched the surface in this section on these new\nTinkerPop OLAP capabilities. If this is an area that you are interested\nin I strongly recommend reading the official TinkerPop reference\ndocumentation.",
            "children": []
          }
        ]
      }
    ]
  },
  {
    "level": "5",
    "title": "5. MISCELLANEOUS QUERIES AND THEIR RESULTS {#msc}",
    "content": "In this chapter you will find more Gremlin queries that operate on the\n*air-routes* graph. All of these queries build upon the topics covered\nin the prior sections. In this section I have included lots of examples\nof the output returned by running queries. In cases where the output is\nrather lengthy I have either truncated it or laid it out in columns to\nmake it easier to read and to save space. It is my hope also that from\nreading the examples in this section that you will get a sense for how\ngood data modelled as a graph can be when used for analysis. I also\nthink that the queries in this section show that you can achieve useful\nresults from a graph using nothing more than some OLTP style queries and\na TinkerGraph. This is actually a great example of an ideal use case for\nTinkerGraph. Even if you have your main data in a massive hosted graph,\nextracting parts of it and doing analysis locally using TinkerGraph is a\ntechnique that can make you very productive.",
    "children": [
      {
        "level": "5.1",
        "title": "5.1. Counting more things {#countmore}",
        "content": "To get things started, let's look at a few more examples that basically\njust count occurrences and distributions of things but are a little more\ncomplex than the examples we looked at earlier in the book.",
        "children": [
          {
            "level": "5.1.1",
            "title": "5.1.1. Which countries have no airports? {#noairports}",
            "content": "This first query looks for any *country* vertices that have no outgoing\nedges. This indicates that there are no airports in the graph for those\ncountries.\n\n``` java\n// Are there any countries that have no airports?\ng.V().hasLabel('country').not(out()).values('desc')\n```\n\nSo it seems there are six countries for which no airports were found.\n\n``` java\nAndorra\nLiechtenstein\nMonaco\nMontserrat\nPitcairn\nSan Marino\n```\n\nThe previous query is a slightly shorter form of the two queries below\nwhich would both yield the same results. Note the use of the *\\\"\\_\\_\\\"*\nprefix in front of the *not* step in the second query. This is because\n*not* is a reserved word in Groovy and has to be prefixed in this way\nwhen not directly connected to a prior step by a dot.\n\n``` java\ng.V().hasLabel('country').where(out().count().is(0)).values('desc')\n\ng.V().hasLabel('country').where(__.not(out())).values('desc')\n```",
            "children": []
          },
          {
            "level": "5.1.2",
            "title": "5.1.2. Which airports have no routes? {#noroutes}",
            "content": "There are a few airports in the graph that currently have no commercial\nroutes. This is either because they used to have service and it was\ndiscontinued or they are new airports still awaiting service to start.\nWe can write a query to easily find these \\\"orphan\\\" airports. Note that\nthis is query based on the version 0.77 release of `air-routes.graphml`.\n\n::: tip\nYou can always find the version of the `air-routes.graphml` file used\nfor the examples in the book and also the most recent data set in the\n`sample-data` folder located at\n<https://github.com/krlawrence/graph/tree/main/sample-data> .\n:::\n\nIn more recent updates of the data set, some of these airports do now\nhave commercial airline service.\n\n``` java\ng.V().hasLabel('airport').not(bothE('route')).values('code').fold()\n```\n\nWhen we run the query, you can see we find quite a few orphan airport\nnodes that have no outgoing or incoming routes.\n\n``` java\n[ILG,TWB,TUA,BVS,KGG,RIG,INT,APA,BWU,BID,NBW,SFH,CVT,AFW,PSY,HLE]\n```",
            "children": []
          },
          {
            "level": "5.1.3",
            "title": "5.1.3. What is the distribution of runways? {#runwaydist}",
            "content": "We can easily count the distribution per airport of runways. We can\nobserve from the results of running the query that the vast majority of\nairports in the graph have either one or two runways.\n\n``` java\n// What is the distribution of runways in the graph\ng.V().hasLabel('airport').groupCount().by('runways')\n\n[1:2316,2:762,3:225,4:51,5:14,6:4,7:1,8:1]\n```",
            "children": []
          },
          {
            "level": "5.1.4",
            "title": "5.1.4. Airports with the most routes {#mostroutes}",
            "content": "This next query finds all airports that have more than 180 outgoing\nroutes and returns their IATA codes.\n\n``` java\n// Airports with more than 180 outgoing routes\ng.V().hasLabel('airport').\n      where(out('route').count().is(gt(180))).values('code').fold()\n\n[ATL,DFW,IAH,JFK,LAX,ORD,DEN,EWR,YYZ,LHR,LGW,CDG,FRA,DXB,PEK,PVG,FCO,AMS,BCN,MAD,MUC,MAN,STN,DME,IST]\n```\n\nWe could improve our query a bit to include the IATA code and the exact\nnumber of outgoing routes in the returned result. There are a few\ndifferent ways that we could do this. One way that is quite convenient\nis to use *group*.\n\n``` java\n// Same basic query but return the airport code and the route count\ng.V().hasLabel('airport').\n      where(out('route').count().is(gt(180))).\n      group().by('code').by(out().count())\n```\n\nI have laid the results out in a grid to make them easier to read.\n\n``` java\n[ORD:232,PVG:201,LAX:195,CDG:262,\n STN:186,JFK:187,DFW:221,LHR:191,\n MUC:237,DME:214,EWR:182,AMS:269,\n IST:270,DEN:188,BCN:190,DXB:229,\n IAH:192,MAD:192,FCO:189,FRA:272,\n PEK:234,ATL:232,YYZ:181,MAN:182,\n LGW:200]\n```\n\nWe can add one further refinement to the query. This time the results\nare ordered by the number or routes in descending order. Note the use of\n*local* to make sure that *order* is applied to the contents of the\ncollection that was generated by the *group* step.\n\n``` java\n// Same query with ordered results\ng.V().hasLabel('airport').\n      where(out('route').count().is(gt(180))).\n      group().by('code').by(out().count()).\n      order(local).by(values,desc)\n```\n\nI have again laid the results out in a grid.\n\n``` java\n[FRA:272,IST:270,AMS:269,CDG:262,\n MUC:237,PEK:234,ORD:232,ATL:232,\n DXB:229,DFW:221,DME:214,PVG:201,\n LGW:200,LAX:195,IAH:192,MAD:192,\n LHR:191,BCN:190,FCO:189,DEN:188,\n JFK:187,STN:186,EWR:182,MAN:182,\n YYZ:181]\n```\n\nAs I mentioned earlier in the book, the number of incoming and outgoing\nroutes for any given airport will not always be the same due to how\nairlines operate their flight routings. The query below looks for any\nairports that have more than 400 total routes (inbound and outbound).\n\n``` java\n// Airports with more than 400 total routes\ng.V().hasLabel('airport').\n      where(both('route').count().is(gt(400))).\n      values('code').fold()\n\n[ATL,DFW,ORD,CDG,FRA,DXB,PEK,PVG,AMS,MUC,DME,IST]\n```",
            "children": []
          },
          {
            "level": "5.1.5",
            "title": "5.1.5. Airports with just one route {#oneroute}",
            "content": "There are, perhaps surprisingly, a large number of airports that only\nhave one route. The query below will figure out just how many fall into\nthat category.\n\n``` java\n// How many airports have only one route?\ng.V().hasLabel('airport').\n  where(out().count().is(eq(1))).count()\n\n770\n```",
            "children": []
          },
          {
            "level": "5.1.6",
            "title": "5.1.6. Single runway airports with the most routes {#onerunway}",
            "content": "It is interesting to look at how busy some single runway airports are.\nThe query below looks for the ten airports with just one runway that\nhave the most outgoing routes. You will notice that I have included\nLondon Gatwick in the query using an *or* step. This is because while\ntechnically Gatwick is listed in the graph as an airport with two\nrunways, in practice the second runway is primarily used as a taxiway\nand reserved for emergency use only. Therefore, Gatwick is really a\nsingle runway airport. This also makes the query a bit more interesting!\n\n``` java\ng.V().or(has('airport','runways',1),has('code','LGW')).\n      order().by(out().count(),desc).limit(10).\n      project('apt','city','routes').\n      by('code').by('city').by(out().count())\n```\n\nWhen we run the query here are the results we get back. One interesting\nobservation is that three of the top five busiest single runway airports\nare in England.\n\n``` java\n[apt:LGW,city:London,routes:200]\n[apt:STN,city:London,routes:186]\n[apt:CTU,city:Chengdu,routes:124]\n[apt:LIS,city:Lisbon,routes:116]\n[apt:BHX,city:Birmingham,routes:109]\n[apt:SAW,city:Istanbul,routes:109]\n[apt:KMG,city:Kunming,routes:107]\n[apt:ALC,city:Alicante,routes:106]\n[apt:CKG,city:Chongqing,routes:106]\n[apt:XIY,city:Xianyang,routes:105]\n```",
            "children": []
          },
          {
            "level": "5.1.7",
            "title": "5.1.7. Another way of counting runways {#runwaycountproject}",
            "content": "Let's assume we wanted to count the runways in the graph and for each\nnumber of runways produce a simple map result where the runway number\nand total count of airports having that number of runways are each\nmeaningfully labeled. One way we could do that is to use a *groupCount*\nstep to calculate the distribution of runways and then use a *project*\nstep to produce the nicely labeled result. That is what the query below\ndoes. Notice that an *unfold* step is used so that the results of the\n*groupCount* which itself produces a map, can be further processed.\n\n``` java\ng.V().hasLabel('airport').\n      groupCount().by('runways').\n      unfold().\n      project('runways','count').by(keys).by(values)\n```\n\nWhen run we get a nice map back showing us the number of runways and for\neach the total count. Each value has a meaningful key name of *runways*\nand *count* respectively.\n\n``` java\n[runways:1,count:2316]\n[runways:2,count:762]\n[runways:3,count:225]\n[runways:4,count:51]\n[runways:5,count:14]\n[runways:6,count:4]\n[runways:7,count:1]\n[runways:8,count:1]\n```\n\nNotice that if the unfold step had not been used, a very different\nresult would have been generated.\n\n``` java\ng.V().hasLabel('airport').\n      groupCount().by('runways').\n      project('runways','count').by(keys).by(values)\n\n[runways:[1,2,3,4,5,6,7,8],count:[2316,762,225,51,14,4,1,1]]\n```",
            "children": []
          },
          {
            "level": "5.1.8",
            "title": "5.1.8. Airports with the most routes in Canada {#canadamost}",
            "content": "The following query finds the top 10 airports in Canada sorted by\ndescending number of outgoing routes. Just for fun, this time I used the\n*index* method to include a one based index as part of the results.\n\n``` java\ng.V().has('country','code','CA').out().\n      order().by(out().count(),desc).limit(10).\n      project('apt','city','routes').\n      by('code').by('city').by(out().count()).indexed(1)\n```\n\nHere are the results of running the query along with the index that we\nadded.\n\n``` java\n[1,[apt:YYZ,city:Toronto,routes:181]]\n[2,[apt:YUL,city:Montreal,routes:101]]\n[3,[apt:YVR,city:Vancouver,routes:94]]\n[4,[apt:YYC,city:Calgary,routes:68]]\n[5,[apt:YEG,city:Edmonton,routes:41]]\n[6,[apt:YHZ,city:Halifax,routes:40]]\n[7,[apt:YWG,city:Winnipeg,routes:32]]\n[8,[apt:YOW,city:Ottawa,routes:31]]\n[9,[apt:YZF,city:Yellowknife,routes:20]]\n[10,[apt:YQB,city:Quebec City,routes:19]]\n```",
            "children": []
          },
          {
            "level": "5.1.9",
            "title": "5.1.9. Distribution of UK airports {#ukdist}",
            "content": "How many airports are there in each of the UK regions of England,\nScotland, Wales and Northern Ireland?\n\n``` java\ng.V().has('country','code','UK').out('contains').groupCount().by('region')\n\n[GB-ENG:27,GB-WLS:3,GB-NIR:3,GB-SCT:25]\n```",
            "children": []
          },
          {
            "level": "5.1.10",
            "title": "5.1.10. Distribution of airports by country {#countrydist}",
            "content": "This query uses *groupCount* to produce a map of key value pairs where\nthe key is the two character ISO country code and the value is the\nnumber of airports that country has.\n\n``` java\n// How many airports does each country have in the graph?\ng.V().hasLabel('airport').\n      groupCount().by('country')\n```\n\nWhen run the query produces quite a lot of output. As the values are not\nsorted it is hard to find the countries with the most airports. Note\nthat the *groupCount* step does not include countries that had no\nairports. In other words if the count is zero the country was skipped.\n\n``` java\n[PR:6,PT:14,PW:1,PY:2,QA:1,AE:10,AF:4,AG:1,AI:1,AL:1,AM:2,AO:14,AR:36,AS:1,AT:6,RE:2,AU:124,AW:1,AZ:5,RO:14,BA:4,BB:1,RS:2,BD:7,BE:5,RU:120,BF:2,BG:4,RW:2,BH:1,BI:1,BJ:1,BL:1,BM:1,BN:1,BO:15,SA:26,BQ:3,SB:17,BR:115,SC:2,BS:18,SD:5,SE:39,BT:1,SG:1,BW:4,SH:2,SI:1,BY:2,BZ:13,SK:2,SL:1,SN:3,SO:5,CA:203,SR:1,SS:1,CC:1,CD:11,ST:1,SV:1,CF:1,CG:3,CH:5,SX:1,CI:1,SY:2,SZ:1,CK:6,CL:17,CM:5,CN:209,CO:50,CR:13,TC:4,TD:1,CU:12,CV:7,TG:1,TH:32,CW:1,CX:1,CY:3,TJ:4,CZ:5,TL:1,TM:1,TN:8,TO:1,TR:48,TT:2,DE:33,TV:1,TW:9,TZ:8,DJ:1,DK:8,DM:1,DO:7,UA:15,UG:4,UK:58,DZ:29,US:579,EC:15,EE:3,EG:10,EH:2,UY:2,UZ:11,ER:1,VC:1,ES:42,ET:14,VE:24,VG:2,VI:2,VN:21,VU:26,FI:20,FJ:10,FK:2,FM:4,FO:1,FR:58,WF:2,GA:2,WS:1,GD:1,GE:3,GF:1,GG:2,GH:5,GI:1,GL:14,GM:1,GN:1,GP:1,GQ:2,GR:39,GT:2,GU:1,GW:1,GY:2,HK:1,HN:6,HR:8,HT:2,YE:9,HU:2,ID:67,YT:1,IE:7,IL:5,IM:1,IN:73,ZA:20,IQ:6,IR:44,IS:5,IT:36,ZM:8,JE:1,ZW:3,JM:2,JO:2,JP:63,KE:14,KG:2,KH:3,KI:2,KM:1,KN:2,KP:1,KR:15,KS:1,KW:1,KY:3,KZ:20,LA:8,LB:1,LC:2,LK:6,LR:2,LS:1,LT:3,LU:1,LV:1,LY:10,MA:14,MD:1,ME:2,MF:1,MG:13,MH:2,MK:1,ML:1,MM:14,MN:10,MO:1,MP:2,MQ:1,MR:3,MS:1,MT:1,MU:2,MV:8,MW:2,MX:59,MY:34,MZ:10,NA:4,NC:1,NE:1,NF:1,NG:18,NI:1,NL:5,NO:49,NP:10,NR:1,NZ:25,OM:4,PA:5,PE:20,PF:30,PG:26,PH:38,PK:21,PL:13,PM:1]\n```\n\nIf we wanted to sort the list in descending order using the numeric\nvalues we could adjust the query as follows. Once again note the use of\n*local* to specify how the ordering is applied.\n\n``` java\ng.V().hasLabel('airport').\n      groupCount().by('country').\n      order(local).by(values,desc)\n```\n\nThis time it is much easier to see which countries have the most\nairports.\n\n``` java\n[US:579,CN:209,CA:203,AU:124,RU:120,BR:115,IN:73,ID:67,JP:63,MX:59,UK:58,FR:58,CO:50,NO:49,TR:48,IR:44,ES:42,SE:39,GR:39,PH:38,AR:36,IT:36,MY:34,DE:33,TH:32,PF:30,DZ:29,SA:26,VU:26,PG:26,NZ:25,VE:24,VN:21,PK:21,FI:20,ZA:20,KZ:20,PE:20,BS:18,NG:18,SB:17,CL:17,BO:15,UA:15,EC:15,KR:15,PT:14,AO:14,RO:14,ET:14,GL:14,KE:14,MA:14,MM:14,BZ:13,CR:13,MG:13,PL:13,CU:12,CD:11,UZ:11,AE:10,EG:10,FJ:10,LY:10,MN:10,MZ:10,NP:10,TW:9,YE:9,TN:8,TZ:8,DK:8,HR:8,ZM:8,LA:8,MV:8,BD:7,CV:7,DO:7,IE:7,PR:6,AT:6,CK:6,HN:6,IQ:6,LK:6,AZ:5,BE:5,SD:5,SO:5,CH:5,CM:5,CZ:5,GH:5,IL:5,IS:5,NL:5,PA:5,AF:4,BA:4,BG:4,BW:4,TC:4,TJ:4,UG:4,FM:4,NA:4,OM:4,BQ:3,SN:3,CG:3,CY:3,EE:3,GE:3,ZW:3,KH:3,KY:3,LT:3,MR:3,PY:2,AM:2,RE:2,RS:2,BF:2,RW:2,SC:2,SH:2,BY:2,SK:2,SY:2,TT:2,EH:2,UY:2,VG:2,VI:2,FK:2,WF:2,GA:2,GG:2,GQ:2,GT:2,GY:2,HT:2,HU:2,JM:2,JO:2,KG:2,KI:2,KN:2,LC:2,LR:2,ME:2,MH:2,MP:2,MU:2,MW:2,PW:1,QA:1,AG:1,AI:1,AL:1,AS:1,AW:1,BB:1,BH:1,BI:1,BJ:1,BL:1,BM:1,BN:1,BT:1,SG:1,SI:1,SL:1,SR:1,SS:1,CC:1,ST:1,SV:1,CF:1,SX:1,CI:1,SZ:1,TD:1,TG:1,CW:1,CX:1,TL:1,TM:1,TO:1,TV:1,DJ:1,DM:1,ER:1,VC:1,FO:1,WS:1,GD:1,GF:1,GI:1,GM:1,GN:1,GP:1,GU:1,GW:1,HK:1,YT:1,IM:1,JE:1,KM:1,KP:1,KS:1,KW:1,LB:1,LS:1,LU:1,LV:1,MD:1,MF:1,MK:1,ML:1,MO:1,MQ:1,MS:1,MT:1,NC:1,NE:1,NF:1,NI:1,NR:1,PM:1]\n```\n\nIf we wanted to sort by the country code, the *key* in other words, we\ncould change the query accordingly. In this case we will use\n*by(keys,asc)* to get a sort in ascending order. If we wanted to sort in\ndescending order by key we could use *by(keys,desc)* instead.\n\n``` java\ng.V().hasLabel('airport').\n      groupCount().by('country').\n      order(local).by(keys,asc)\n```\n\nThis time the results are now sorted using the country codes in\nascending alphabetical order.\n\n``` java\n[AE:10,AF:4,AG:1,AI:1,AL:1,AM:2,AO:14,AR:36,AS:1,AT:6,AU:124,AW:1,AZ:5,BA:4,BB:1,BD:7,BE:5,BF:2,BG:4,BH:1,BI:1,BJ:1,BL:1,BM:1,BN:1,BO:15,BQ:3,BR:115,BS:18,BT:1,BW:4,BY:2,BZ:13,CA:203,CC:1,CD:11,CF:1,CG:3,CH:5,CI:1,CK:6,CL:17,CM:5,CN:209,CO:50,CR:13,CU:12,CV:7,CW:1,CX:1,CY:3,CZ:5,DE:33,DJ:1,DK:8,DM:1,DO:7,DZ:29,EC:15,EE:3,EG:10,EH:2,ER:1,ES:42,ET:14,FI:20,FJ:10,FK:2,FM:4,FO:1,FR:58,GA:2,GD:1,GE:3,GF:1,GG:2,GH:5,GI:1,GL:14,GM:1,GN:1,GP:1,GQ:2,GR:39,GT:2,GU:1,GW:1,GY:2,HK:1,HN:6,HR:8,HT:2,HU:2,ID:67,IE:7,IL:5,IM:1,IN:73,IQ:6,IR:44,IS:5,IT:36,JE:1,JM:2,JO:2,JP:63,KE:14,KG:2,KH:3,KI:2,KM:1,KN:2,KP:1,KR:15,KS:1,KW:1,KY:3,KZ:20,LA:8,LB:1,LC:2,LK:6,LR:2,LS:1,LT:3,LU:1,LV:1,LY:10,MA:14,MD:1,ME:2,MF:1,MG:13,MH:2,MK:1,ML:1,MM:14,MN:10,MO:1,MP:2,MQ:1,MR:3,MS:1,MT:1,MU:2,MV:8,MW:2,MX:59,MY:34,MZ:10,NA:4,NC:1,NE:1,NF:1,NG:18,NI:1,NL:5,NO:49,NP:10,NR:1,NZ:25,OM:4,PA:5,PE:20,PF:30,PG:26,PH:38,PK:21,PL:13,PM:1,PR:6,PT:14,PW:1,PY:2,QA:1,RE:2,RO:14,RS:2,RU:120,RW:2,SA:26,SB:17,SC:2,SD:5,SE:39,SG:1,SH:2,SI:1,SK:2,SL:1,SN:3,SO:5,SR:1,SS:1,ST:1,SV:1,SX:1,SY:2,SZ:1,TC:4,TD:1,TG:1,TH:32,TJ:4,TL:1,TM:1,TN:8,TO:1,TR:48,TT:2,TV:1,TW:9,TZ:8,UA:15,UG:4,UK:58,US:579,UY:2,UZ:11,VC:1,VE:24,VG:2,VI:2,VN:21,VU:26,WF:2,WS:1,YE:9,YT:1,ZA:20,ZM:8,ZW:3]\n```\n\nNote that we can use *select* to only return one or more of the full set\nof key/value pairs returned. Here is an example of doing just that.\n\n``` java\n// Only return the values for Germany, China, Holland and the US.\ng.V().hasLabel('airport').\n      groupCount().by('country').\n      select('DE','CN','NL','US')\n\n[DE:32, CN:179, NL:5, US:566]\n```\n\nBecause the *air-routes* graph also has country specific vertices, we\ncould chose to write the previous queries a different way. We could\nstart by finding country vertices and then see how many airport vertices\neach one is connected to. In this instance, because a *group* step is\nbeing used, countries with no airports will be included.\n\n``` java\n// Another way to ask the question above, this time by counting the\n// edges (out degree) from each country\n\ng.V().hasLabel('country').\n      group().by('code').by(outE().count()).\n      order(local).by(values,desc)\n```\n\nThis time the countries with no airports **are** included in the\nresults.\n\n``` java\n[US:579,CN:209,CA:204,AU:125,RU:122,BR:115,IN:74,ID:67,JP:63,MX:59,UK:58,FR:58,CO:50,NO:49,TR:48,IR:45,ES:42,SE:39,GR:39,PH:39,AR:37,IT:36,MY:34,DE:33,TH:32,PF:30,DZ:29,SA:26,VU:26,PG:26,NZ:25,VE:24,VN:21,PK:21,FI:20,ZA:20,KZ:20,PE:20,BS:18,NG:18,SB:17,CL:17,BO:15,UA:15,EC:15,KR:15,PT:14,AO:14,RO:14,ET:14,GL:14,KE:14,MA:14,MM:14,BZ:13,CR:13,MG:13,PL:13,CU:12,CD:11,UZ:11,AE:10,EG:10,FJ:10,LY:10,MN:10,MZ:10,NP:10,TW:9,YE:9,TN:8,TZ:8,DK:8,HR:8,ZM:8,LA:8,MV:8,BD:7,CV:7,DO:7,IE:7,PR:6,AT:6,CK:6,HN:6,IQ:6,LK:6,AZ:5,BE:5,SD:5,SO:5,CH:5,CM:5,CZ:5,GH:5,IL:5,IS:5,NA:5,NL:5,PA:5,AF:4,BA:4,BG:4,BW:4,TC:4,TJ:4,UG:4,FM:4,OM:4,BQ:3,SN:3,CG:3,CY:3,EE:3,GE:3,ZW:3,KH:3,KY:3,LT:3,MR:3,PY:2,AM:2,RE:2,RS:2,BF:2,RW:2,SC:2,SH:2,SI:2,BY:2,SK:2,SY:2,TT:2,EH:2,UY:2,VG:2,VI:2,FK:2,WF:2,GA:2,GG:2,GQ:2,GT:2,GY:2,HT:2,HU:2,JM:2,JO:2,KG:2,KI:2,KN:2,LC:2,LR:2,ME:2,MH:2,MP:2,MU:2,MW:2,PW:1,QA:1,AG:1,AI:1,AL:1,AS:1,AW:1,BB:1,BH:1,BI:1,BJ:1,BL:1,BM:1,BN:1,BT:1,SG:1,SL:1,SR:1,CC:1,SS:1,ST:1,CF:1,SV:1,SX:1,CI:1,SZ:1,TD:1,TG:1,CW:1,CX:1,TL:1,TM:1,TO:1,TV:1,DJ:1,DM:1,ER:1,VC:1,FO:1,WS:1,GD:1,GF:1,GI:1,GM:1,GN:1,GP:1,GU:1,GW:1,HK:1,YT:1,IM:1,JE:1,KM:1,KP:1,KS:1,KW:1,LB:1,LS:1,LU:1,LV:1,MD:1,MF:1,MK:1,ML:1,MO:1,MQ:1,MS:1,MT:1,NC:1,NE:1,NF:1,NI:1,NR:1,PM:1,AD:0,SM:0,LI:0,MC:0,PN:0]\n```\n\nIf we only wanted to see the last few of the sorted results we could add\na *tail* step with *local* scope to the query.\n\n``` java\ng.V().hasLabel('country').\n      group().by('code').by(outE().count()).\n      order(local).by(values,desc).\n      tail(local,20)\n\n[LV:1,MD:1,MF:1,MK:1,ML:1,MO:1,MQ:1,MS:1,MT:1,NC:1,NE:1,NF:1,NI:1,NR:1,PM:1,AD:0,SM:0,LI:0,MC:0,PN:0]\n```",
            "children": []
          },
          {
            "level": "5.1.11",
            "title": "5.1.11. Distribution of airports by continent {#continentdist}",
            "content": "We can use a similar query to the one above to find out how many\nairports are located in each of the seven continents. As you can see\nfrom the output, a key/value map is again returned where the key is the\ncontinent code and the value is the number of airports in that\ncontinent. Note that currently there are no airports with regular\nscheduled service in Antarctica!\n\n``` java\n// How many airports are there in each continent?\ng.V().hasLabel('continent').group().by('code').by(out().count())\n\n[EU:583,AS:932,NA:978,OC:284,AF:294,AN:0,SA:303]\n```",
            "children": []
          },
          {
            "level": "5.1.12",
            "title": "5.1.12. Distribution of routes per airport {#_distribution_of_routes_per_airport}",
            "content": "We have already examined various ways to calculate the distribution of\nroutes in the graph. The following query will, for each airport, return\na key value pair where the key is the airport code and the value is the\nnumber of outgoing routes from that airport. Because there are over\n3,000 airports in the graph, this query will produce a large results. I\ndecided not to include those results here. The second query just picks\nthe results from the map for a few airports. Those results are shown.\n\n``` java\n// How many flights are there from each airport?\ng.V().hasLabel('airport').out().groupCount().by('code')\n\n// count the routes from all the airports and then select a few.\ng.V().hasLabel('airport').out().groupCount().by('code').\n      select('AUS','AMS','JFK','DUB','MEX')\n\n[AUS:59,AMS:272,JFK:186,DUB:165,MEX:105]\n```\n\nThis next query essentially asks the same question about how many\noutgoing routes each airport has. However, rather than return the count\nfor each airport individually, it groups the ones with the same number\nof routes together. As this query returns a lot of data I just included\na few lines from the full result below the query.\n\n``` java\n// Same query except sorted into groups by ascending count\ng.V().hasLabel('airport').\n      group().by(out().count()).by('code').\n      order(local).by(keys)\n```\n\nAs can be seen this time the count value is the key and the airport\ncodes are the values.\n\n``` java\n76:[TPA,BNE,PDX],77:[RIX,WUH],78:[IBZ,PTY],79:[ADD,AYT],80:[MNL,BOG,XMN,CSX],81:[SFB],82:[GLA,HND],83:[CAI,MDW,OTP],84:[VCE,BRS,HGH],85:[JNB,MLA,NAP,RUH],86:[BOM,SHJ],89:[BWI],90:[CMN],91:[LPA,VKO],92:[SXF],93:[DCA,GRU,LYS],94:[SLC,YVR,SYD,MRS,TFS],95:[STR,CRL],97:[NCE,AUH],98:[BUD,WAW],101:[YUL],102:[BGY],104:[LTN,JED,SZX],105:[PHX,MEX,TLV,HAM,XIY],106:[ALC,CUN,CKG],107:[HEL,EDI,KMG],108:[DEL],109:[BHX,SAW],110:[TPE],112:[NRT],113:[GVA],114:[SEA],115:[PRG],116:[CGN,LIS],118:[ATH,TXL],119:[OSL],122:[KUL],123:[MCO],124:[MXP,CTU],126:[AGP],127:[ORY],129:[PHL],130:[BOS],132:[BKK],133:[LED],136:[IAD],137:[DTW],141:[SFO],142:[FLL],143:[ARN,PMI],144:[MSP,ICN],145:[LAS,CPH],146:[SIN],151:[HKG],152:[ZRH],156:[SVO],162:[VIE],163:[DOH],164:[CAN],165:[DUB],166:[DUS],168:[CLT],171:[MIA],180:[BRU],181:[YYZ],182:[EWR,MAN],186:[STN],187:[JFK],188:[DEN],189:[FCO],190:[BCN],191:[LHR],192:[IAH,MAD],195:[LAX],200:[LGW],201:[PVG],214:[DME],221:[DFW],229:[DXB],232:[ATL,ORD],234:[PEK],237:[MUC],262:[CDG],269:[AMS],270:[IST],272:[FRA]]\n```\n\nAs the above query returns a lot of data, we can also extract specific\nvalues we are interested in as follows. Only airports with 105 outgoing\nroutes are selected.\n\n``` java\n// Which of these airports have 105 outgoing routes?\ng.V().hasLabel('airport').\n      group().by(out().count()).by('code').next().get(105L)\n```\n\n::: note\nCurrently *select* can only take a string value as the key so we have to\nuse the slightly awkward *next().get()* syntax to get a numeric key from\na result.\n:::\n\nThis time the results only include the airports with 105 outgoing\nroutes.\n\n``` java\nPHX\nMEX\nTLV\nHAM\nXIY\n```",
            "children": []
          },
          {
            "level": "5.1.13",
            "title": "5.1.13. Using groupCount with a traversal variable {#groupvar}",
            "content": "So far we have just used *groupCount* with no parameters. When used in\nthat way, *groupCount* behaves like a *map* step in that it passes the\ntransformed data on to the next step. However, if you specify the name\nof a traversal variable as a parameter, the results of the count will be\nstored in that variable and *groupCount* will act the same way as a\n*sideEffect* would, nothing is passed on from *groupCount* to the next\nstep. We can use this capability to keep track of things during a query\nwhile not actually changing the overall state of the traversal.\n\nThe example below starts at the vertex *V(3)* and goes *out* from there.\nA *groupCount* step is then used to group the vertices we visited by a\ncount of the number of runways each has. We then go *out* again and\ncount how many vertices we found and save that result in the variable\n*b*. Note that the *groupCount* when used in this way did not pass\nanything on to the following step. Finally we use *select* to return our\ntwo variables as the results of the query.\n\n``` java\ng.V(3).out().groupCount('a').by('runways').\n       out().count().as('b').select('a','b')\n\n[a:[1:2,2:9,3:17,4:22,5:4,6:3,7:1,8:1],b:5942]\n```\n\nIn the next section we will see another example of a *groupCount* step\nthat uses a traversal variable.",
            "children": []
          },
          {
            "level": "5.1.14",
            "title": "5.1.14. Combining *groupCount* and *constant* {#gcconstant}",
            "content": "You can use a *constant* value in combination with a *groupCount* step\nas one way of setting the name of the key that will be used in the\nresult. The example below shows a *groupCount* step that is provided a\ntraversal variable *\\\"a\\\"* as a parameter and a constant as part of the\n*by* modulator. The query starts by finding any airports in the US state\nof Oklahoma. A *constant* step is used to tell the *groupCount* step\nwhat to use as the key name in the result. At the end of the query a\n*cap* step is used to close and return the contents of *\\\"a\\\"*.\n\n``` java\ng.V().has('airport','region','US-OK').groupCount('a').by(constant('OK')).cap('a')\n```\n\nIf we run the query, here is what we will get back. Notice the key is\nour constant value *\\\"OK\\\"* and the value is the number of airports\nfound in Oklahoma.\n\n``` java\n[OK:4]\n```\n\nThe example above is intended purely to demonstrate the fact that you\ncan use a *constant* value with *groupCount*. However, for this specific\nexample, you would probably code a query something like the one below\ninstead.\n\n``` java\ng.V().has('airport','region','US-OK').groupCount().by('region')\n\n[US-OK:4]\n```",
            "children": []
          },
          {
            "level": "5.1.15",
            "title": "5.1.15. Combining *choose* and *groupCount* {#chainchoose}",
            "content": "Using the ideas discussed above, we can write a query that chains\nseveral *choose* steps together to build a result set made up of various\nkey:value pairs representing different things that we are interested in\ncounting. The query below looks at all vertices that represent an\nairport. For each vertex found, various properties are examined using a\n*choose* step. If the test returns *true* a count, stored in the\ntraversal variable \\\"*a\\\"* is incremented. Note how each of the choose\nsteps is *dot chained* together. When used in this way *choose* behaves\nin the same way as a *sideEffect* in that all of the airport vertices\nare passed to the next choose rather than just those that pass the *if*\ntest.\n\n``` java\ng.V().hasLabel('airport').\n      choose(has('runways',4), groupCount('a').by(constant('four'))).\n      choose(has('runways',lte(2)), groupCount('a').by(constant('low'))).\n      choose(has('runways',gte(6)), groupCount('a').by(constant('high'))).\n      choose(has('country','FR'), groupCount('a').by(constant('France'))).\n      groupCount('a').by(constant('total')).cap('a')\n```\n\nIf we run the query this is what we might get back. We counted 3375\ntotal airports, found six airports that have six or more runways, 3079\nthat have two or fewer and found 58 airports in France.\n\n``` java\n[total:3374,high:6,low:3078,four:51,France:58]\n```\n\nUsing *choose* and *groupCount* in this way provides a very nice pattern\nfor counting somewhat disparate things during a traversal.",
            "children": []
          },
          {
            "level": "5.1.16",
            "title": "5.1.16. Nesting one *group* step inside another {#nestedgroup}",
            "content": "Many examples of both the *groupCount* and *group* steps have already\nbeen presented in this book. However, something I have not touched on so\nfar, which by now may be obvious but perhaps not, is that you can nest\none *group* step inside another one. This is made possible by the fact\nthat the *by* modulators that are used to tell the *group* step\nprecisely what you want grouped can take arbitrary traversals. Take a\nlook at the example below. Hopefully the indentation makes it easier to\nread. We begin by simply finding five airports and starting a group. The\nkey for each group will be one of the codes for each of these airports.\nThis is specified by the first *by* modulator. For the value part of\neach group, specified by the second *by* modulator, we start a second\ntraversal. That traversal begins by finding five places you can fly to\nfrom each of the five airports that we initially found. Then another\n*group* step is used to group each of those airports by the number of\ntotal outgoing routes they have.\n\n``` java\ng.V().hasLabel(\"airport\").limit(5).\n      group().\n        by('code').\n        by(out(\"route\").limit(5).\n           group().\n             by('code').\n             by(out(\"route\").count()))\n```\n\nWhen the query is run here is what we get back. As expected the outer\ngroup has keys that represent the first five airports that were found.\nThe inner group has the five airport destinations as the keys and their\ntotal outgoing route counts as their values. I pretty printed the output\na bit to make it easier to read.\n\n``` java\n[BNA:[DCA:93,DFW:221,BWI:89,FLL:142,IAD:136],\n ANC:[IAH:192,LAX:195,DFW:221,PDX:76,FAI:19],\n BOS:[YVR:94,LHR:191,CDG:262,YYZ:181,LGW:200],\n ATL:[MEI:4,MLB:6,MSL:2,MCN:2,MBS:4],\n AUS:[MEX:105,FRA:272,LHR:191,PIT:54,YYZ:181]]\n```\n\nSo what we have created is a group, essentially a map, that has airport\ncodes as the key and an additional group as the values. Therefore, given\neach group is made up of key value pairs, we can use a *select* step to\nonly pick a few of the results.\n\n``` java\ng.V().hasLabel(\"airport\").limit(5).\n      group().\n        by('code').\n        by(out(\"route\").limit(5).\n           group().\n             by('code').\n             by(out(\"route\").count())).\n      select('ANC','ATL')\n```\n\nThis time only the selected results are returned\n\n``` java\n[ANC:[IAH:192,LAX:195,DFW:221,PDX:76,FAI:19],\n ATL:[MEI:4,MLB:6,MSL:2,MCN:2,MBS:4]]\n```\n\nIf you want to select results from one of the inner groups you can do\nthat as well using an additional *select* step.\n\n``` java\ng.V().hasLabel(\"airport\").limit(5).\n      group().\n        by('code').\n        by(out(\"route\").limit(5).\n           group().\n             by('code').\n             by(out(\"route\").count())).\n      select('ANC').\n      select('IAH','LAX')\n```\n\nThis will first select the result with a key of *ANC* and then from that\ngroup select the results for the keys of *IAH* and *LAX* only.\n\n``` java\n[IAH:192,LAX:195]\n```",
            "children": []
          },
          {
            "level": "5.1.17",
            "title": "5.1.17. Analysis of routes between Europe and the USA {#eu-usa}",
            "content": "The next few queries show how you can use a graph like *air-routes* to\nperform analysis on a particular industry segment. The following queries\nanalyze the distribution and availability of routes between airports\nacross Europe and airports in the United States. First of all let's just\nfind out how many total routes there are between airports anywhere in\nEurope and airports in the USA.\n\n``` java\n// How many routes from anywhere in Europe to the USA?\n\ng.V().has('continent','code','EU').\n      out().out().has('country','US').\n      count()\n\n351\n```\n\nSo we now know that there are 345 different routes. Remember though that\nthe *air-routes* graph does not track the number of airlines that\noperate any of these routes. The graph just stores the data that at\nleast one airline operates each of these unique route pairs. Let's dig a\nbit deeper into the 345 and find out how many US airports have flights\nthat arrive from Europe.\n\n``` java\n// How many different US airports have routes from Europe?\n\ng.V().has('continent','code','EU').\n      out().out().has('country','US').\n      dedup().count()\n\n38\n```\n\nSo we can now see that the 345 routes from European airports arrive at\none of 38 airports in the United States. We can dig a bit deeper and\nlook at the distribution of these routes across the 38 airports.\n\n``` java\n//What is the distribution of the routes amongst those US airports?\n\ng.V().has('continent','code','EU').\n      out().out().has('country','US').\n      groupCount().by('code').\n      order(local).by(values,asc)\n```\n\nJohn F. Kennedy airport (JFK) in New York appears to have the most\nroutes from Europe with Newark (EWR) having the second most.\n\n``` java\n[PHX:1,CVG:1,RSW:1,BDL:2,SJC:2,BWI:2,AUS:2,RDU:2,MSY:2,SAN:3,SLC:3,PDX:3,PIT:3,TPA:4,SFB:4,OAK:4,DTW:5,SWF:5,MSP:5,DEN:5,FLL:6,CLT:7,DFW:7,PVD:7,SEA:8,IAH:8,MCO:10,LAS:10,ATL:14,SFO:15,PHL:17,IAD:19,ORD:21,BOS:22,LAX:23,MIA:25,EWR:33,JFK:40]\n```\n\nNow let's repeat the process but looking at the European end of the\nroutes. First of all, we can calculate how many European airports have\nflights to the United States.\n\n``` java\n// How many European airports have service to the USA?\n\ng.V().has('continent','code','EU').\n      out().as('a').\n      out().has('country','US').\n      select('a').dedup().count()\n\n53\n```\n\nJust as we did for the airports in the US we can figure out the\ndistribution of routes for the European airports.\n\n``` java\n// What is the distribution of US routes amongst\n// the European airports?\n\ng.V().has('continent','code','EU').\n      out().as('a').\n      out().has('country','US').\n      select('a').groupCount().by('code').\n      order(local).by(values,asc)\n```\n\nIt appears that London Heathrow (LHR) offers the most US destinations\nand Frankfurt (FRA) the second most.\n\n``` java\n[RIX:1,TER:1,BRS:1,STN:1,NCE:1,KRK:1,ORK:1,KBP:1,PDL:1,DME:1,BEG:1,AGP:1,HAM:1,OPO:2,STR:2,VCE:2,BHX:2,ORY:2,ATH:2,MXP:3,BFS:3,BGO:3,GVA:3,VKO:3,HEL:3,WAW:4,SVO:4,GLA:4,EDI:5,SNN:5,CGN:5,TXL:6,VIE:6,LIS:6,BRU:7,ARN:7,OSL:8,IST:9,BCN:10,MAD:11,LGW:11,DUS:11,CPH:11,FCO:12,ZRH:13,MAN:13,DUB:15,MUC:16,AMS:18,KEF:18,CDG:22,FRA:24,LHR:27]\n```\n\nLastly, we can find out what the list of routes flown is. For this\nexample I decided to just return 10 of the 345 routes. Note how the\n*path* step returns all parts of the traversal including the continent\ncode *EU*. We could remove that part of the result by adding a *from*\nmodulator as shown earlier in the \\\"[What vertices and edges did I\nvisit? - Introducing ](#pathintro)\\\" section.\n\n``` java\n// Selected routes from Europe to the USA.\n\ng.V().has('continent','code','EU').\n      out().out().\n      has('country','US').\n      path().by('code').\n      limit(10)\n```\n\nThe first 10 results returned feature routes from Warsaw, Belgrade and\nIstanbul.\n\n``` java\n[EU,WAW,JFK]\n[EU,WAW,LAX]\n[EU,WAW,ORD]\n[EU,WAW,EWR]\n[EU,BEG,JFK]\n[EU,IST,ATL]\n[EU,IST,BOS]\n[EU,IST,IAD]\n[EU,IST,IAH]\n[EU,IST,JFK]\n```",
            "children": []
          },
          {
            "level": "5.1.18",
            "title": "5.1.18. Using *fold* to do simple Map-Reduce computations {#mapreduce}",
            "content": "Earlier in the book we saw examples of *sum* being used to count a\ncollection of values. You can also use *fold* to do something similar\nbut in a more *map-reduce* type of fashion.\n\nFirst of all, here is a query that uses *fold* in a way that we have\nalready seen. It will find all routes from Austin and uses a *fold* step\nto return a list of those names.\n\n``` java\ng.V().has('code','AUS').\n      out('route').\n      values('city').fold()\n```\n\nAs expected the results show all of the cities that you can fly to from\nAustin collected into a single list.\n\n``` java\n[Toronto,London,Frankfurt,Mexico City,Pittsburgh,Portland,Charlotte,Cancun,Memphis,Cincinnati,Indianapolis,Kansas City,Dallas,St Louis,Albuquerque,Chicago,Lubbock,Harlingen,Guadalajara,Pensacola,Valparaiso,Orlando,Branson,St Petersburg-Clearwater,Atlanta,Nashville,Boston,Baltimore,Washington D.C.,Dallas,Fort Lauderdale,Washington D.C.,Houston,New York,Los Angeles,Orlando,Miami,Minneapolis,Chicago,Phoenix,Raleigh,Seattle,San Francisco,San Jose,Tampa,San Diego,Long Beach,Santa Ana,Salt Lake City,Las Vegas,Denver,New Orleans,Newark,Houston,El Paso,Cleveland,Oakland,Philadelphia,Detroit]\n```\n\nHowever, what if we wanted to reduce our results further? Take a look at\nthe modified version of our query below. It finds all routes from Austin\nand looks at the names of the destination cities. However, rather than\nreturn all the names, this time the *fold* step is used differently and\neffectively reduces the city names to a single value. That value being\nthe total number of characters in all of those city names. We have seen\n*fold* used elsewhere in the book but this time we provide *fold* with a\nparameter and a closure. The parameter is passed to the closure as the\nfirst variable and the name of the city as the second. The closure then\nadds the zero and the length of each name effectively producing a\nrunning total.\n\n``` java\ng.V().has('code','AUS').out('route').values('city').\n      fold(0) {a,b -> a + b.length()}\n\n530\n```\n\n::: note\nWhile this query will work as-is on TinkerGraph within the Gremlin\nConsole, some graph systems are more strict about their type checking\nand sandboxing of Groovy closures. To be on the safe side you can always\nexplicitly type cast the closure as follows.\n:::\n\n``` java\ng.V().has('code','AUS').out('route').values('city').\n                       fold(0) {a,b -> (int)a + ((String)b).length()}\n```",
            "children": []
          },
          {
            "level": "5.1.19",
            "title": "5.1.19. Distribution of routes in the graph (mode and mean) {#meanmode}",
            "content": "An example of a common question we might want to answer with a network\ngraph, of which air routes are an example, is \\\"how are the routes in my\ngraph distributed between airport vertices?\\\". We can also use this same\nquery to find the statistical *mode* (most common number) for a set of\nroutes.\n\nTake a look at the next query that shows how we can do analysis on the\ndistribution of routes throughout the graph. We are only interested in\nvertices that are airports and for those vertices we want to count how\nmany outgoing routes each airport has. We want to return the results as\na set of ordered *key:value* pairs where the key is the number of\noutgoing routes and the value is the number of airports that have that\nnumber of outgoing routes.\n\n``` java\ng.V().hasLabel('airport').\n      groupCount().by(out('route').count()).\n      order(local).by(values,desc)\n```\n\nWhen we run the query we get back the results below. As the results are\nsorted in descending order by value, we can see that the *mode* (most\ncommon) number of outgoing routes is actually just one route and that\n786 airports have just one outgoing route. We can see that 654 airports\nhave just two routes and so on. We can also see at the other end of the\nscale that one airport has 237 outgoing routes.\n\n``` java\n[1:770,2:654,3:369,4:234,5:148,6:116,7:93,8:81,9:68,10:61,12:43,11:39,13:39,15:31,16:27,19:25,20:25,22:25,14:19,18:18,0:16,17:15,33:15,23:14,30:13,31:13,21:12,32:12,35:11,37:11,24:9,25:9,39:9,26:8,27:8,36:8,41:8,42:8,47:8,59:8,29:7,34:7,40:7,44:7,55:7,63:7,43:6,48:6,50:6,67:6,28:5,45:5,61:5,62:5,64:5,94:5,105:5,52:4,54:4,68:4,70:4,80:4,85:4,38:3,51:3,53:3,56:3,60:3,74:3,76:3,83:3,84:3,93:3,104:3,106:3,107:3,46:2,57:2,58:2,65:2,73:2,77:2,78:2,79:2,82:2,86:2,91:2,95:2,97:2,98:2,109:2,116:2,118:2,124:2,143:2,144:2,145:2,182:2,192:2,232:2,262:1,269:1,270:1,272:1,49:1,66:1,69:1,71:1,72:1,75:1,81:1,89:1,90:1,92:1,101:1,102:1,108:1,110:1,112:1,113:1,114:1,115:1,119:1,122:1,123:1,126:1,127:1,129:1,130:1,132:1,133:1,136:1,137:1,141:1,142:1,146:1,151:1,152:1,156:1,162:1,163:1,164:1,165:1,166:1,168:1,171:1,180:1,181:1,186:1,187:1,188:1,189:1,190:1,191:1,195:1,200:1,201:1,214:1,221:1,229:1,234:1,237:1]\n```\n\nWe could change our query above, replacing *out()* with *\\_\\_.in()* and\nwe could find out the distribution of incoming routes. Remembering that\nin an air route network there is not always a one to one equivalent\nnumber of outgoing to incoming routes due to the way airlines plan their\nroutes.\n\nAnother change we could make to our query is to change the ordering to\nuse the key field for each key:value pair and this time sort in\nascending order.\n\n``` java\ng.V().hasLabel('airport').\n      groupCount().by(out('route').count()).\n      order(local).by(keys,asc)\n```\n\nWhen we run our query again we get the results below. Looking at the\ndata sorted this way helps some new interesting facts stand out. The\nmost interesting thing we can immediately spot is that there are 16\nairports that currently have no outgoing routes at all!\n\n``` java\n[0:16,1:770,2:654,3:369,4:234,5:148,6:116,7:93,8:81,9:68,10:61,11:39,12:43,13:39,14:19,15:31,16:27,17:15,18:18,19:25,20:25,21:12,22:25,23:14,24:9,25:9,26:8,27:8,28:5,29:7,30:13,31:13,32:12,33:15,34:7,35:11,36:8,37:11,38:3,39:9,40:7,41:8,42:8,43:6,44:7,45:5,46:2,47:8,48:6,49:1,50:6,51:3,52:4,53:3,54:4,55:7,56:3,57:2,58:2,59:8,60:3,61:5,62:5,63:7,64:5,65:2,66:1,67:6,68:4,69:1,70:4,71:1,72:1,73:2,74:3,75:1,76:3,77:2,78:2,79:2,80:4,81:1,82:2,83:3,84:3,85:4,86:2,89:1,90:1,91:2,92:1,93:3,94:5,95:2,97:2,98:2,101:1,102:1,104:3,105:5,106:3,107:3,108:1,109:2,110:1,112:1,113:1,114:1,115:1,116:2,118:2,119:1,122:1,123:1,124:2,126:1,127:1,129:1,130:1,132:1,133:1,136:1,137:1,141:1,142:1,143:2,144:2,145:2,146:1,151:1,152:1,156:1,162:1,163:1,164:1,165:1,166:1,168:1,171:1,180:1,181:1,182:2,186:1,187:1,188:1,189:1,190:1,191:1,192:2,195:1,200:1,201:1,214:1,221:1,229:1,232:2,234:1,237:1,262:1,269:1,270:1,272:1]\n```\n\nIf we wanted to find the statistical mean number of routes in the graph\nwe could easily write a query like the one below to tell us how many\nairports and outgoing routes in total there are in the graph.\n\n``` java\ng.V().hasLabel('airport').union(count(),out('route').count()).fold()\n\n[3374,43400]\n```\n\nWe could then use the Gremlin Console do the division for us to\ncalculate the mean.\n\n``` java\ngremlin> 43400/3374\n\n==>12.8630705394\n```\n\nHowever, Gremlin also has a *mean* step that we can take advantage of if\nwe can figure out a way to use it in this case that will do the work for\nus. Take a look at the next query. The key thing to note here is the way\n*local* has been used. This will cause Gremlin to essentially do what we\ndid a bit more manually above. If we did not include *local* the answer\nwould just be the total number of outgoing routes as Gremlin would\nessentially calculate 43400/1. By using local we force Gremlin to in\nessence create an array containing the number of routes for each\nairport, add those values up and divide by the number of elements in the\narray (the number of airports). I hope that makes sense. If it is\nconfusing try the query yourself on the gremlin console with and without\nlocal and try it without the *mean* step. You will see all of the\ninterim values instead!\n\n``` java\ng.V().hasLabel('airport').local(out('route').count()).mean()\n\n12.863070539419088\n```\n\nSo it seems there is an average of just over 12 outgoing routes per\nairport in the graph whichever way we decide to calculate it!\n\nNow that we have a query figured out for calculating the average number\nof outgoing routes per airport, we can easily tweak it to do the same\nfor incoming routes and combined, incoming and outgoing, routes.\n\n``` java\n// Average number of incoming routes\ng.V().has('type','airport').local(__.in('route').count()).mean()\n\n12.863070539419088\n\n// Average number of outgoing and incoming routes\ng.V().has('type','airport').local(both('route').count()).mean()\n\n25.726141078838175\n```",
            "children": []
          },
          {
            "level": "5.1.20",
            "title": "5.1.20. How many routes are there from airports in London (UK)? {#_how_many_routes_are_there_from_airports_in_london_uk}",
            "content": "This next query can be used to figure out how many outgoing routes each\nof the airports classified as being in (or near) London, England has.\nNote that we first find all airports in England using\n*has(\\'region*,*GB-ENG*)\\'. If we did not do this we would pick up\nairports in other countries as well such as London, Ontario, in Canada.\n\n``` java\ng.V().has('region','GB-ENG').has('city','London').\n      group().by('code').by(out().count())\n\n[LCY:42,LHR:191,LTN:104,STN:186,LGW:200]\n```\n\nHere is a twist on the above theme. How many places can I get to from\nLondon in two hops but not including flights that end up back in London?\nIt turns out there are over 2,000 places! Notice how *aggregate* is used\nto store the set of London airports as a collection that can be\nreferenced later on in the query to help with ruling out any flights\nthat would end up back in London.\n\n``` java\n// Leave from London, fly with one stop, not ending back in London, how many places?\ng.V().has('region','GB-ENG').has('city','London').aggregate('lon').\n      out().out().dedup().where(without('lon')).count()\n\n2236\n```\n\nWe could have written the previous query like this and avoided using\n*aggregate* but to me, this feels more clumsy and somewhat repetitive.\n\n``` java\ng.V().has('region','GB-ENG').has('city','London').out().out().dedup().\n      not(and(has('city','London'),has('region','GB-ENG'))).count()\n\n2236\n```",
            "children": []
          },
          {
            "level": "5.1.21",
            "title": "5.1.21. How many routes are there between airports in England? {#englandroutes}",
            "content": "We can use an *aggregate* step to quite elegantly find the routes that\nexist between airports located in England. The following query finds all\nairports in England and orders them by airport code. It then collects\nthose airports using an *aggregate* step. Finally the aggregated\ncollection is used to find routes to airports also within the UK. Note\nthat as written, this query finds routes in both directions if they\nexist.\n\n``` java\n// Flights within England\ng.V().has('region','GB-ENG').order().by('code').aggregate('a').\n      out().where(within('a')).path().by('code')\n```\n\nHere are the routes found when the query is run. I arranged the results\ninto columns to save space.\n\n``` java\n[BHX,NCL]   [LBA,SOU]   [MAN,NQY]   [NQY,ISC]\n[BRS,NCL]   [LBA,NQY]   [MAN,NWI]   [NQY,LGW]\n[EMA,SOU]   [LCY,MAN]   [MAN,EXT]   [NQY,MAN]\n[EXT,MAN]   [LEQ,ISC]   [MAN,LHR]   [NQY,LPL]\n[EXT,NQY]   [LGW,NQY]   [MAN,LCY]   [NQY,LBA]\n[EXT,ISC]   [LGW,NCL]   [NCL,SOU]   [NWI,MAN]\n[HUY,NWI]   [LHR,MAN]   [NCL,BRS]   [NWI,HUY]\n[ISC,NQY]   [LHR,LBA]   [NCL,BHX]   [SOU,MAN]\n[ISC,EXT]   [LHR,NCL]   [NCL,LHR]   [SOU,EMA]\n[ISC,LEQ]   [LPL,NQY]   [NCL,LGW]   [SOU,LBA]\n[LBA,LHR]   [MAN,SOU]   [NQY,EXT]   [SOU,NCL]\n```\n\nHere is a different way the query can be written. This time a *where*\nstep is used to filter out the previously seen airport pairs so we only\nget routes in one direction.\n\n``` java\ng.V().has('region','GB-ENG').order().by('code').as('a').\n      out().has('region','GB-ENG').as('b').\n      where('a',lt('b')).by('code').\n      path().by('code')\n```\n\nAs you can see this time we only get each airport pair back once\nregardless of route direction.\n\n``` java\n[BHX,NCL]   [LBA,NQY]\n[BRS,NCL]   [LCY,MAN]\n[EMA,SOU]   [LGW,NQY]\n[EXT,MAN]   [LGW,NCL]\n[EXT,NQY]   [LHR,MAN]\n[EXT,ISC]   [LHR,NCL]\n[HUY,NWI]   [LPL,NQY]\n[ISC,NQY]   [MAN,SOU]\n[ISC,LEQ]   [MAN,NQY]\n[LBA,LHR]   [MAN,NWI]\n[LBA,SOU]   [NCL,SOU]\n```",
            "children": []
          },
          {
            "level": "5.1.22",
            "title": "5.1.22. What are the top ten airports by route count? {#topten}",
            "content": "Earlier we calculated which airports have the most routes. These next\nthree queries are of a similar nature but produce a tables of the top\nten airports in terms of incoming, outgoing and overall routes. As\nmentioned before, because of the way some airlines route flights, the\nnumber of outgoing and incoming routes to an airport will not always be\nthe same. For example, several KLM Airlines flights from Amsterdam to\nairports in Africa continue on to other African airports before\nreturning to Amsterdam. As a result there are more inbound routes from\nthan out bound routes to these airports. In each example below the\n*project* step is used to generate the results in a easily readable\nform.\n\nFirst of all, this query will find the ten airports with the most\nincoming routes, sorted in descending order.\n\n``` java\n// Find the top ten overall in terms of incoming routes\ng.V().hasLabel('airport').\n      order().by(__.in('route').count(),desc).limit(10).\n      project('ap','routes').by('code').by(__.in('route').count())\n```\n\nSo it seems that Frankfurt and Amsterdam are tied for the most incoming\nroutes. It is worth remembering that the version of the graph used for\nthe examples in the book represents a moment in time. If these queries\nare re run at a later date on a newer version of the graph the results\nwill quite likely be different. This is because airlines regularly add,\nand in some cases drop, routes.\n\n``` java\n[ap:FRA,routes:272]\n[ap:AMS,routes:272]\n[ap:IST,routes:270]\n[ap:CDG,routes:262]\n[ap:MUC,routes:237]\n[ap:PEK,routes:235]\n[ap:ATL,routes:232]\n[ap:ORD,routes:232]\n[ap:DXB,routes:229]\n[ap:DFW,routes:221]\n```\n\nNow let's do the same thing but for outgoing routes.\n\n``` java\n// Find the top ten overall in terms of outgoing routes\ng.V().hasLabel('airport').\n      order().by(out('route').count(),desc).limit(10).\n      project('ap','routes').by('code').by(out('route').count())\n```\n\nThis time Frankfurt has the most routes. This reinforces a point that I\nmade earlier. The number of incoming and outgoing routes for a given\nairport will not always be the same. This is because of the way airlines\nroute flights. Some flights continue to other destinations before\nreturning so there will not always be direct flights between airport\npairs in both directions. I know as a passenger this is something that I\nfind frustrating!\n\n``` java\n[ap:FRA,routes:272]\n[ap:IST,routes:270]\n[ap:AMS,routes:269]\n[ap:CDG,routes:262]\n[ap:MUC,routes:237]\n[ap:PEK,routes:234]\n[ap:ATL,routes:232]\n[ap:ORD,routes:232]\n[ap:DXB,routes:229]\n[ap:DFW,routes:221]\n```\n\nLastly, let's find the top ten airports ordered by the total number of\nincoming and outgoing routes that they have.\n\n``` java\n// Find the top ten overall in terms of total routes\ng.V().hasLabel('airport').\n      order().by(both('route').count(),desc).limit(10).\n      project('ap','routes').by('code').by(both('route').count())\n```\n\nAs expected, Frankfurt is the airport with the most overall routes. One\nsmall side note while on the topic of airline routes. The graph does not\ntrack the frequency at which any given route is operated. What this\nmeans is that the airport with the most routes is not necessarily also\nthe busiest. This is because many routes are operated multiple times a\nday. I did not try to include this data in the graph as it changes too\noften for me to keep up with.\n\n``` java\n[ap:FRA,routes:544]\n[ap:AMS,routes:541]\n[ap:IST,routes:540]\n[ap:CDG,routes:524]\n[ap:MUC,routes:474]\n[ap:PEK,routes:469]\n[ap:ATL,routes:464]\n[ap:ORD,routes:464]\n[ap:DXB,routes:458]\n[ap:DFW,routes:442]\n```",
            "children": []
          },
          {
            "level": "5.1.23",
            "title": "5.1.23. Using *local* while counting things {#localfold}",
            "content": "In some of the earlier sections we saw examples of *local* scope being\nused. Here is another example of how *local* scope can be used while\ncounting things to achieve a desired result.\n\nTake a look at the query below. It finds any airports that have six or\nmore runways and then returns the airport's IATA code along with the\nnumber of runways it has.\n\n``` java\ng.V().has('airport','runways',gte(6)).values('code','runways').fold()\n```\n\nHere is the output from running the query. As you can see what is\nreturned is a list of airport codes with each followed by its runway\ncount.\n\n``` java\n[BOS,6,DFW,7,ORD,8,DEN,6,DTW,6,AMS,6]\n```\n\nWhile the output returned by the previous query is not bad, it might be\nnice to have what is returned be a set of code and runway pairs each in\nits own list. We can achieve this result by having the *fold* step\napplied to the interim or *local* results of the query.\n\nTake a look at the modified form of the query below. Part of the query\nis now wrapped inside of a *local* step.\n\n``` java\ng.V().has('airport','runways',gte(6)).local(values('code','runways').fold())\n```\n\nHere is the output from running our modified form of the query. Each\nairport code and runway value pair is now in its own individual list.\n\n``` java\n[BOS,6]\n[DFW,7]\n[ORD,8]\n[DEN,6]\n[DTW,6]\n[AMS,6]\n```",
            "children": []
          },
          {
            "level": "5.1.24",
            "title": "5.1.24. How many vertices have no edges? {#noedges}",
            "content": "In the air routes graph there are some vertices that have no outgoing\nedges, some that have no incoming edges and a few, such as the vertex\nfor the continent of Antarctica, that have neither. We can use some\nsimple queries to count how many of each type exist.\n\n``` java\n// Vertices with no outgoing edges.\ng.V().not(outE()).count()\n\n23\n\n// Vertices with no incoming edges.\ng.V().not(inE()).count()\n\n245\n\n// Vertices with no edges.\ng.V().not(bothE()).count()\n\n7\n```\n\nThe queries above provide a nice shorthand way of writing queries that\nwe could also write using *where* steps. As shown below.\n\n``` java\ng.V().where(outE().count().is(0)).count()\n\n23\n```",
            "children": []
          }
        ]
      },
      {
        "level": "5.2",
        "title": "5.2. Where can I fly to from here? {#wherefly}",
        "content": "In this section you will find some more examples of queries that explore\ndifferent questions along the lines of \\\"Where can I fly to from\nhere?\\\".",
        "children": [
          {
            "level": "5.2.1",
            "title": "5.2.1. Does any route exist between two airports? {#doesanyrouteexist}",
            "content": "We have already looked at different ways to discover shortest routes (by\nhops) between two airports using queries such as the one below. This\nquery looks for a single route between Austin (AUS) and the Canadian\ncity of Peawanuck in Ontario. It just so happens that Peawanuck is one\nof the hardest places to get to from Austin in the whole air-routes\ngraph. In fact, to get there, requires six stops along the way! With\nthat in mind, the query below can easily run out of memory or time out\ntrying to find even a single route as there is so much work to do to\nanalyze all of the possible routes.\n\n``` java\ng.V().has('code','AUS').\n      repeat(out().simplePath()).\n        until(has('code','YPO')).\n      limit(1).\n      path().by('code')\n```\n\nIn cases such as this we can take a slightly different approach that\nwill let us know if any route exists and in fact will execute very\nefficiently. Note that this query cannot find multiple routes but is\nvery useful when trying to answer the question \\\"does any route\nexist?\\\".\n\n``` java\ng.V().has('code','AUS').\n      repeat(out().dedup()).\n        until(has('code','YPO')).\n      path().by('code')\n\n[AUS,YYZ,YTS,YMO,YFA,ZKE,YAT,YPO]\n```\n\nThe difference between the two queries is the addition of a *dedup*\nstep. This ensures we only ever visit any airport along the route once\nno matter how we got there. This is different from the *simplePath* step\nwhich makes sure we do not loop back on ourselves during a traversal but\nallows us to visit the same airport multiple times so long as we got\nthere using a different path. Even if we were to make the task of\nfinding a route harder by explicitly avoiding a specific stop the\nexecution remains very efficient due to the *dedup* step being used.\n\n``` java\ng.V().has('code','AUS').\n      repeat(out().has('code',without('YYZ')).dedup()).\n        until(has('code','YPO')).\n      path().by('code')\n\n[AUS,BOS,YTZ,YTS,YMO,YFA,ZKE,YAT,YPO]\n```\n\nKeep in mind that this trick is only useful when trying to figure out if\nany route (or path) exists in a group between a pair of vertices. It\ncannot be used to find multiple routes but is still a very useful\npattern to be aware of. You will see a variation of this technique used\nagain in the \\\"[Looking for the journey requiring the most\nstops](#longestroutes)\\\" section.",
            "children": []
          },
          {
            "level": "5.2.2",
            "title": "5.2.2. Where in the USA or Canada can I fly to from any airport in India? {#uscatoindia}",
            "content": "This first query looks for routes to the USA or Canada from any airport\nin India.\n\n``` java\n// Where in the USA or Canada can I fly to from any airport in India?\ng.V().has('country','code','IN').out().out().\n      has('country',within('US','CA')).path().by('code')\n```\n\nHere are the results of running the query. Note that because we used the\n*path* step the country code for India \\\"IN\\\" is included in the output.\n\n``` java\n[IN,DEL,IAD]\n[IN,DEL,JFK]\n[IN,DEL,ORD]\n[IN,DEL,SFO]\n[IN,DEL,EWR]\n[IN,DEL,YYZ]\n[IN,DEL,YVR]\n[IN,BOM,EWR]\n[IN,BOM,YYZ]\n```",
            "children": []
          },
          {
            "level": "5.2.3",
            "title": "5.2.3. Which cities in Europe can I fly to from Ft. Lauderdale in Florida? {#flleurope}",
            "content": "This query looks for routes from Fort Lauderdale in Florida to cities in\nEurope.\n\n``` java\n// Where can I fly to in Europe from Ft. Lauderdale?\ng.V().has('code','FLL').out().as('a').in('contains').\n      has('code','EU').select('a').values('city')\n```\n\nHere are the results of running the query.\n\n``` java\nLondon\nParis\nOslo\nStockholm\nCopenhagen\n```",
            "children": []
          },
          {
            "level": "5.2.4",
            "title": "5.2.4. Where can I fly to from Charlotte, to cities in Europe or South America? {#clteusa}",
            "content": "This query looks for routes from Charlotte, North Carolina to cities in\nEurope or South America.\n\n``` java\n// Flights from Charlotte to airports in Europe or South America\ng.V().has('code','CLT').out().as('a').in('contains').\n      has('code',within('EU','SA')).select('a').by('code')\n```\n\nHere are the results of running the query.\n\n``` java\nLHR     FCO\nCDG     MAD\nFRA     MUC\nGIG     DUB\nGRU\n```",
            "children": []
          },
          {
            "level": "5.2.5",
            "title": "5.2.5. Where in the United States can I fly from to airports in London? {#usalon}",
            "content": "This query looks for routes from any one of the five airports in the\nLondon area in the UK that end up in the United States.\n\n``` java\n// Where in the United States can I fly to non-stop from any of the\n// airports in and around London in the UK?\ng.V().has('airport','code',within('LHR','LCY','LGW','LTN','STN')).\n      out().has('country','US').path().by('code')\n```\n\nHere are the results of running the query.\n\n``` java\n[LHR,AUS]      [LHR,SEA]      [LHR,EWR]\n[LHR,ATL]      [LHR,RDU]      [LHR,DEN]\n[LHR,BWI]      [LHR,SJC]      [LHR,DTW]\n[LHR,BOS]      [LHR,SFO]      [LHR,PHL]\n[LHR,IAD]      [LHR,LAX]      [LGW,SFO]\n[LHR,DFW]      [LHR,JFK]      [LGW,LAS]\n[LHR,MSP]      [LHR,IAH]      [LGW,TPA]\n[LHR,MIA]      [LHR,LAS]      [LGW,FLL]\n[LHR,PHX]      [LHR,CLT]      [LGW,MCO]\n[LHR,ORD]      [LHR,SAN]      [LGW,JFK]\n```",
            "children": []
          },
          {
            "level": "5.2.6",
            "title": "5.2.6. Where in New York state can I fly to from any of the airports in Texas? {#txny}",
            "content": "This query looks for all the routes from any airport in Texas that end\nup in any of the New York state airports.\n\n``` java\n// Where in New York state can I fly to from any airport in Texas?\ng.V().has('airport','region','US-TX').out().has('region','US-NY').path().by('code')\n```\n\nHere are the results of running the query.\n\n``` java\n[AUS,JFK]      [IAH,EWR]\n[AUS,EWR]      [SAT,EWR]\n[DFW,EWR]      [SAT,JFK]\n[DFW,JFK]      [HOU,JFK]\n[DFW,LGA]      [HOU,LGA]\n[IAH,JFK]      [HOU,EWR]\n[IAH,LGA]\n```",
            "children": []
          },
          {
            "level": "5.2.7",
            "title": "5.2.7. Which cities in Mexico can I fly to from Denver? {#denmex}",
            "content": "This query looks for routes from Denver to anywhere in Mexico.\n\n``` java\n// Where in Mexico can I fly to from Denver?\ng.V().has('code','DEN').out().has('country','MX').values('city')\n```\n\nHere are the results of running the query.\n\n``` java\nPuerto Vallarta\nSan Josa del Cabo\nCozumel\nMexico City\nCancun\n```",
            "children": []
          },
          {
            "level": "5.2.8",
            "title": "5.2.8. Which cities in Europe can I fly to from Delhi in India? {#deleu}",
            "content": "This query looks for routes from Delhi that go to any airport in Europe.\n\n``` java\n// Where in Europe can I fly to from Delhi?\ng.V().has('code','DEL').out().as('a').in(\"contains\").\n      has('code','EU').select('a').by('city')\n```\n\nHere are the results of running the query.\n\n``` java\nLondon\nParis\nFrankfurt\nHelsinki\nRome\nAmsterdam\nMadrid\nVienna\nZurich\nBrussels\nMunich\nStockholm\nMoscow\nMilan\nIstanbul\nCopenhagen\nBirmingham\n```",
            "children": []
          },
          {
            "level": "5.2.9",
            "title": "5.2.9. Finding all routes between London, Munich and Paris {#aggrroutes}",
            "content": "In the following example we find all the routes between airports in\nLondon, Munich and Paris. Notice how by using *aggregate* to collect the\nresults of the first *within* test that we don't have to repeat the\nnames in the second *within*, we can just refer to the aggregated\ncollection.\n\n``` java\ng.V().has('city',within('London','Munich','Paris')).aggregate('a').out().\n      where(within('a')).path().by('code')\n```\n\nHere is what we might get back from the query. I have laid the results\nout in columns to save space.\n\n``` java\n[LHR,MUC]   [CDG,LHR]   [MUC,STN]   [STN,MUC]\n[LHR,ORY]   [CDG,LGW]   [MUC,LHR]   [ORY,LCY]\n[LHR,CDG]   [CDG,MUC]   [MUC,LGW]   [ORY,MUC]\n[LGW,MUC]   [CDG,LCY]   [MUC,CDG]   [ORY,LHR]\n[LGW,CDG]   [MUC,LTN]   [LCY,CDG]   [LTN,CDG]\n[CDG,LTN]   [MUC,ORY]   [LCY,ORY]   [LTN,MUC]\n```",
            "children": []
          }
        ]
      },
      {
        "level": "5.3",
        "title": "5.3. More analysis of distances between airports {#moredist}",
        "content": "In this section you will find some more queries that examine distances\nbetween airports. The query below returns a nice list of all the routes\nfrom Austin (AUS) along with their distances. The results are sorted in\nascending order by distance.\n\n``` java\n// Distances of all routes from AUS along with destination IATA CODE\ng.V().has('code','AUS').outE().order().by('dist',asc).\n      inV().path().by('code').by('dist')\n```\n\nHere are the results of running the query. For ease of reading I again\nbroke the results into four columns.\n\n``` java\n[AUS,142,IAH]      [AUS,755,GDL]       [AUS,1080,LAS]       [AUS,1430,PHL]\n[AUS,152,HOU]      [AUS,755,BNA]       [AUS,1080,SLC]       [AUS,1476,SJC]\n[AUS,183,DFW]      [AUS,768,DEN]       [AUS,1110,FLL]       [AUS,1493,OAK]\n[AUS,189,DAL]      [AUS,809,ATL]       [AUS,1140,DTW]       [AUS,1500,SFO]\n[AUS,274,HRL]      [AUS,866,PHX]       [AUS,1160,SAN]       [AUS,1500,EWR]\n[AUS,341,LBB]      [AUS,922,CUN]       [AUS,1173,CLE]       [AUS,1520,JFK]\n[AUS,444,MSY]      [AUS,925,TPA]       [AUS,1220,LGB]       [AUS,1690,BOS]\n[AUS,527,ELP]      [AUS,972,MDW]       [AUS,1230,LAX]       [AUS,1712,PDX]\n[AUS,558,MEM]      [AUS,973,ORD]       [AUS,1294,IAD]       [AUS,1768,SEA]\n[AUS,618,ABQ]      [AUS,994,MCO]       [AUS,1313,DCA]       [AUS,4901,LHR]\n[AUS,722,STL]      [AUS,1030,CLT]      [AUS,1339,BWI]       [AUS,5294,FRA]\n[AUS,748,MEX]      [AUS,1040,MSP]      [AUS,1357,YYZ]\n```\n\nThis query finds all routes from DFW that are longer than 4,000 miles\nand returns the airport codes and the distances. Notice the use of two\n*by* modulators in this query to decide which values are returned from\nthe source vertex, the edge and the destination vertex respectively.\nAlso note that only two were specified but three values are returned.\nThis works because *by* is processed in a round robin fashion if there\nare more values than *by* modulators.\n\n``` java\n// Where can I fly to from DFW that is more than 4,000 miles away?\ng.V().has('code','DFW').outE('route').has('dist',gt(4000)).inV().\n                        path().by('code').by('dist')\n```\n\nHere are the results of running the query.\n\n``` java\n[DFW,8105,HKG]   [DFW,8022,DXB]\n[DFW,6951,PEK]   [DFW,6822,ICN]\n[DFW,7332,PVG]   [DFW,5228,GIG]\n[DFW,4905,AMS]   [DFW,5119,GRU]\n[DFW,4950,MAD]   [DFW,5299,EZE]\n[DFW,4736,LHR]   [DFW,4884,SCL]\n[DFW,4933,CDG]   [DFW,7914,DOH]\n[DFW,5127,FRA]   [DFW,8053,AUH]\n[DFW,6410,NRT]   [DFW,5015,DUS]\n[DFW,8574,SYD]   [DFW,5597,FCO]\n```\n\nThe previous results are not sorted in any way. We could modify the\nquery to include an *order* step so that the results are sorted in\ndescending order by distance.\n\n``` java\ng.V().has('code','DFW').outE('route').has('dist',gt(4000)).\n      order().by('dist',desc).inV().\n      path().by('code').by('dist')\n```\n\nHere are the, now sorted, results.\n\n``` java\n[DFW,8574,SYD]    [DFW,5299,EZE]\n[DFW,8105,HKG]    [DFW,5228,GIG]\n[DFW,8053,AUH]    [DFW,5127,FRA]\n[DFW,8022,DXB]    [DFW,5119,GRU]\n[DFW,7914,DOH]    [DFW,5015,DUS]\n[DFW,7332,PVG]    [DFW,4950,MAD]\n[DFW,6951,PEK]    [DFW,4933,CDG]\n[DFW,6822,ICN]    [DFW,4905,AMS]\n[DFW,6410,NRT]    [DFW,4884,SCL]\n[DFW,5597,FCO]    [DFW,4736,LHR]\n```\n\nThis next query also finds all routes longer than 4,000 miles but this\ntime originating in London Gatwick. Note also the use of *where* to\nquery the edge distance. The *has* form is simpler but I show *where*\nbeing used just to demonstrate an alternative way we could do it. Note\nthat this query uses three *by* modulators as each of the values\nreturned is from a different property of the respective vertices and\nedges.\n\n``` java\n// Routes longer than 4,000 miles starting at LGW\ng.V().has('code','LGW').outE().where(values('dist').is(gt(4000L))).\n      inV().path().by('code').by('dist').by('city')\n```\n\nHere are the results from running the query.\n\n``` java\n[LGW, 5287, MalT]              [LGW, 4380, Calgary]\n[LGW, 4618, Varadero]          [LGW, 5987, Cape Town]\n[LGW, 5147, Tianjin]           [LGW, 4680, Kingston]\n[LGW, 5303, Chongqing]         [LGW, 4953, Cancun]\n[LGW, 4410, Ft. Lauderdale]    [LGW, 5399, Colombo]\n[LGW, 5463, Los Angeles]       [LGW, 4197, Bridgetown]\n[LGW, 4341, Orlando]           [LGW, 4076, St. George]\n[LGW, 5374, San Francisco]     [LGW, 4408, Port of Spain]\n[LGW, 4416, Tampa]             [LGW, 4699, Montego Bay]\n[LGW, 5236, Las Vegas]         [LGW, 4283, Punta Cana]\n[LGW, 5364, Oakland]           [LGW, 5419, San Jose]\n[LGW, 4731, Vancouver]         [LGW, 4662, Havana]\n[LGW, 5982, Hong Kong]         [LGW, 6053, Port Louis]\n[LGW, 5070, Beijing]           [LGW, 4222, Vieux Fort]\n```\n\nThis next query is similar to the previous ones. We look for any routes\nfrom DFW that are longer than 4,500 miles. However, there are a few\ndifferences in this query worthy of note. First of all it uses the\npreferred *has* technique again to test the distance whereas in the\nprevious query we used *where*. Also this time we just list the distance\nand the destination airport's code and we sort the end result using a\n*sort*. We also use *select* and *as* rather than the perhaps more\nsuccinct *path* and *by* to show a different way of achieving\neffectively the same results. The *path* and *by* combination were\nintroduced more recently into TinkerPop and I find that to be a more\nconvenient syntax to use most of the time but both ways work and both\nhave their benefits. We should also note that I show *sort* being used\nhere just to show a different way of ordering results, but in most cases\nwe can re-write our query to use *order*. This use of *sort* requires a\nGroovy closure to be provided. This may not work when working with\ncommercial graph databases that disallow closures. You will find several\nexamples of *order* being used throughout this book. The *order* step is\nintroduced in the \\\"[Sorting things - introducing ](#sort)\\\" section. As\nmuch as possible staying with the pure Gremlin syntax and avoiding\nclosures is recommended.\n\n``` java\n// Routes from DFW that are over 4,500 miles in length.\n// Sorted into ascending order\n\ng.V().hasLabel('airport').has('code','DFW').outE().has('dist',gt(4500)).as('e').\n      inV().as('c').select('e','c').by('dist').by('code').sort(){it.e}\n```\n\nIn general, I find using *path* rather than *select* and *as* to be\ncleaner. However, as discussed in the \\\"[A warning that path finding can\nbe memory and CPU intensive](#pathwarn)\\\" section, there are issues with\n*path* consuming memory that you will likely run into with more complex\nqueries so it is always good to have some options as to how you write\nyour Gremlin queries. Here is the output produced by this query.\n\n``` java\n[e:4736, c:LHR]     [e:5597, c:FCO]\n[e:4884, c:SCL]     [e:6410, c:NRT]\n[e:4905, c:AMS]     [e:6822, c:ICN]\n[e:4933, c:CDG]     [e:6951, c:PEK]\n[e:4950, c:MAD]     [e:7332, c:PVG]\n[e:5015, c:DUS]     [e:7914, c:DOH]\n[e:5119, c:GRU]     [e:8022, c:DXB]\n[e:5127, c:FRA]     [e:8053, c:AUH]\n[e:5228, c:GIG]     [e:8105, c:HKG]\n[e:5299, c:EZE]     [e:8574, c:SYD]\n```\n\nFor the sake of completeness, here is the query re-written to use an\n*order* step rather than a call to *sort* as a post processing step at\nthe end of the query. In general this is the recommended way of\nachieving sorted results.\n\n``` java\ng.V().hasLabel('airport').has('code','DFW').outE().has('dist',gt(4500)).\n      order().by('dist').as('e').inV().as('c').\n      select('e','c').by('dist').by('code')\n```\n\nNote that the results are ordered before being collected using the\n*select* step. Here is the output from running the modified query\n\n``` java\n[e:4736,c:LHR]     [e:5597,c:FCO]\n[e:4884,c:SCL]     [e:6410,c:NRT]\n[e:4905,c:AMS]     [e:6822,c:ICN]\n[e:4933,c:CDG]     [e:6951,c:PEK]\n[e:4950,c:MAD]     [e:7332,c:PVG]\n[e:5015,c:DUS]     [e:7914,c:DOH]\n[e:5119,c:GRU]     [e:8022,c:DXB]\n[e:5127,c:FRA]     [e:8053,c:AUH]\n[e:5228,c:GIG]     [e:8105,c:HKG]\n[e:5299,c:EZE]     [e:8574,c:SYD]\n```\n\nThe query can also be written with the *order* step coming after the\n*select* step. As follows:\n\n``` java\ng.V().hasLabel('airport').has('code','DFW').outE().has('dist',gt(4500)).as('e').\ninV().as('c').select('e','c').by('dist').by('code').order().by(select('e')\n```",
        "children": [
          {
            "level": "5.3.1",
            "title": "5.3.1. Finding routes longer than 8,000 miles {#gt8k}",
            "content": "This next set of queries show various ways of finding and presenting all\nroutes longer than 8,000 miles. Each query improves upon the one before\nby adding some additional feature or using a step that simplifies the\nquery. First of all let's just find all routes longer than 8,000 miles.\nThis will includes routes in both directions between airport pairs.\n\n``` java\n// All routes longer than 8,000 miles\ng.V().as('src').outE('route').\n      has('dist',gt(8000)).inV().as('dest').\n      select('src','dest').by('code')\n```\n\nHere is what our query produces. As before I have arranged the output in\ncolumns to aid readability.\n\n``` java\n[src:ATL,dest:JNB]    [src:DXB,dest:IAH]\n[src:DFW,dest:SYD]    [src:DXB,dest:LAX]\n[src:DFW,dest:DXB]    [src:DXB,dest:SFO]\n[src:DFW,dest:HKG]    [src:DXB,dest:AKL]\n[src:DFW,dest:AUH]    [src:HKG,dest:DFW]\n[src:IAH,dest:DXB]    [src:HKG,dest:JFK]\n[src:IAH,dest:DOH]    [src:HKG,dest:EWR]\n[src:JFK,dest:HKG]    [src:AKL,dest:DXB]\n[src:LAX,dest:DOH]    [src:AKL,dest:DOH]\n[src:LAX,dest:AUH]    [src:DOH,dest:IAH]\n[src:LAX,dest:JED]    [src:DOH,dest:LAX]\n[src:LAX,dest:RUH]    [src:DOH,dest:AKL]\n[src:LAX,dest:DXB]    [src:JNB,dest:ATL]\n[src:SFO,dest:SIN]    [src:MEX,dest:CAN]\n[src:SFO,dest:DXB]    [src:AUH,dest:DFW]\n[src:SFO,dest:AUH]    [src:AUH,dest:LAX]\n[src:EWR,dest:HKG]    [src:AUH,dest:SFO]\n[src:SYD,dest:DFW]    [src:JED,dest:LAX]\n[src:SIN,dest:SFO]    [src:RUH,dest:LAX]\n[src:DXB,dest:DFW]    [src:CAN,dest:MEX]\n```\n\nNow let's improve the query by including the distance of each route in\nthe query results.\n\n``` java\n// Find routes longer than 8,000 miles.\n// Include the distance in returned values.\ng.V().as('src').\n      outE().has('dist',gt(8000)).as('e').\n      inV().as('dest').\n      select('src','e','dest').by('code').by('dist')\n```\n\nHere is the modified output showing the distance between the airports.\n\n``` java\n[src:ATL,e:8434,dest:JNB]     [src:DXB,e:8150,dest:IAH]\n[src:DFW,e:8574,dest:SYD]     [src:DXB,e:8321,dest:LAX]\n[src:DFW,e:8022,dest:DXB]     [src:DXB,e:8085,dest:SFO]\n[src:DFW,e:8105,dest:HKG]     [src:DXB,e:8818,dest:AKL]\n[src:DFW,e:8053,dest:AUH]     [src:HKG,e:8105,dest:DFW]\n[src:IAH,e:8150,dest:DXB]     [src:HKG,e:8054,dest:JFK]\n[src:IAH,e:8030,dest:DOH]     [src:HKG,e:8047,dest:EWR]\n[src:JFK,e:8054,dest:HKG]     [src:AKL,e:8818,dest:DXB]\n[src:LAX,e:8287,dest:DOH]     [src:AKL,e:9025,dest:DOH]\n[src:LAX,e:8372,dest:AUH]     [src:DOH,e:8030,dest:IAH]\n[src:LAX,e:8314,dest:JED]     [src:DOH,e:8287,dest:LAX]\n[src:LAX,e:8246,dest:RUH]     [src:DOH,e:9025,dest:AKL]\n[src:LAX,e:8321,dest:DXB]     [src:JNB,e:8434,dest:ATL]\n[src:SFO,e:8433,dest:SIN]     [src:MEX,e:8754,dest:CAN]\n[src:SFO,e:8085,dest:DXB]     [src:AUH,e:8053,dest:DFW]\n[src:SFO,e:8139,dest:AUH]     [src:AUH,e:8372,dest:LAX]\n[src:EWR,e:8047,dest:HKG]     [src:AUH,e:8139,dest:SFO]\n[src:SYD,e:8574,dest:DFW]     [src:JED,e:8314,dest:LAX]\n[src:SIN,e:8433,dest:SFO]     [src:RUH,e:8246,dest:LAX]\n[src:DXB,e:8022,dest:DFW]     [src:CAN,e:8754,dest:MEX]\n```\n\nNext let's simplify things a bit. While using *as* and *select* gets the\njob done, using *path* and *by* shortens the query and makes it more\nreadable. As before remember the warning that in some cases using *path*\ncan consume large amounts of memory. That should not be an issue for us\nhere as we are writing a fairly simple query still.\n\n``` java\n// Note that this also changes the way the result is returned\ng.V().outE().has('dist',gt(8000)).\n       inV().path().by('code').by('dist')\n```\n\nThe output indeed now looks more readable.\n\n``` java\n[ATL,8434,JNB]   [LAX,8314,JED]   [DXB,8150,IAH]   [DOH,8287,LAX]\n[DFW,8574,SYD]   [LAX,8246,RUH]   [DXB,8321,LAX]   [DOH,9025,AKL]\n[DFW,8022,DXB]   [LAX,8321,DXB]   [DXB,8085,SFO]   [JNB,8434,ATL]\n[DFW,8105,HKG]   [SFO,8433,SIN]   [DXB,8818,AKL]   [MEX,8754,CAN]\n[DFW,8053,AUH]   [SFO,8085,DXB]   [HKG,8105,DFW]   [AUH,8053,DFW]\n[IAH,8150,DXB]   [SFO,8139,AUH]   [HKG,8054,JFK]   [AUH,8372,LAX]\n[IAH,8030,DOH]   [EWR,8047,HKG]   [HKG,8047,EWR]   [AUH,8139,SFO]\n[JFK,8054,HKG]   [SYD,8574,DFW]   [AKL,8818,DXB]   [JED,8314,LAX]\n[LAX,8287,DOH]   [SIN,8433,SFO]   [AKL,9025,DOH]   [RUH,8246,LAX]\n[LAX,8372,AUH]   [DXB,8022,DFW]   [DOH,8030,IAH]   [CAN,8754,MEX]\n```\n\nOur query is looking pretty good but it would be nice to not report the\nsame route pair twice. In other words the distance between two airports\nin just one direction is all we really want. This adds a little\ncomplexity to things as we have to find a way to *filter* out the routes\nthat we want to ignore. One way to do this is to filter by making sure\nthe code for the source airport is less than the code for the\ndestination airport. This may seem a bit odd but it is a way of saying\nwe only want route pairs we have not already seen. Consider the case of\nthe route between ATL and JNB. The less than (*lt*) test works as we\nwill allow the route between ATL and JNB through (as ATL is\nalphabetically less than JNB) but the route between JNB and ATL will be\nfiltered out. This is a useful technique that can be very helpful in\nmany situations where you are filtering out unwanted results. So let's\nmodify the query as shown below to apply this filter.\n\n``` java\n// We could avoid returning both directions of\n// travel by refining our query as follows.\ng.V().as('a').outE().has('dist',gt(8000)).\n      inV().as('b').\n      filter(select('a','b').by('code').where('a', lt('b'))).\n      path().by('code').by('dist')\n```\n\nHere is the output from running the modified query. As you can see the\nroute from ATL to JNB is still shown but the reverse route from JNB to\nATL is now gone. The same is true for all the other *return journey*\nroutes.\n\n``` java\n[ATL,8434,JNB]     [HKG,8054,JFK]\n[DFW,8574,SYD]     [AKL,8818,DXB]\n[DFW,8022,DXB]     [AKL,9025,DOH]\n[DFW,8105,HKG]     [DOH,8030,IAH]\n[LAX,8246,RUH]     [DOH,8287,LAX]\n[SFO,8433,SIN]     [AUH,8053,DFW]\n[EWR,8047,HKG]     [AUH,8372,LAX]\n[DXB,8150,IAH]     [AUH,8139,SFO]\n[DXB,8321,LAX]     [JED,8314,LAX]\n[DXB,8085,SFO]     [CAN,8754,MEX]\n```\n\nLastly, now that we have the routes we want, let's tweak the query so\nthat the routes are sorted by descending order of distance. We can do\nthis by adding an *order* step after finding the routes we are\ninterested in.\n\n``` java\n// As above but sorted by route lengths.\ng.V().as('a').outE().has('dist',gt(8000)).\n      order().by('dist',desc).\n      inV().as('b').\n      filter(select('a','b').by('code').where('a', lt('b'))).\n      path().by('code').by('dist')\n```\n\nHere are the results again, this time sorted by route distance in\ndescending order.\n\n``` java\n[AKL,9025,DOH]     [LAX,8246,RUH]\n[AKL,8818,DXB]     [DXB,8150,IAH]\n[CAN,8754,MEX]     [AUH,8139,SFO]\n[DFW,8574,SYD]     [DFW,8105,HKG]\n[ATL,8434,JNB]     [DXB,8085,SFO]\n[SFO,8433,SIN]     [HKG,8054,JFK]\n[AUH,8372,LAX]     [AUH,8053,DFW]\n[DXB,8321,LAX]     [EWR,8047,HKG]\n[JED,8314,LAX]     [DOH,8030,IAH]\n[DOH,8287,LAX]     [DFW,8022,DXB]\n```\n\nAs part of the TinkerPop 3.2.3 release an additional capability was\nadded to the *where* step that allows it to be followed by a *by*\nmodulator. This allows us, should we so desire, to simplify our query a\nbit more as follows.\n\n``` java\n//Query changed to take advantage of the where().by() construct\ng.V().as('s').\n      outE().has('dist',gt(8000)).\n      order().by('dist',desc).inV().as('f').\n      where('f',lt('s')).by('code').\n      path().by('code').by('dist')\n```\n\nAs you can see, we got the same results from our modified query. Well,\nalmost the same results! Notice that we actually got the *return routes*\nreturned. So for example, we got the route from DXB to AKL and not the\nroute from AKL to DXB that we got in the prior case. This is because we\ncompared the values in the opposite order!\n\n``` java\n[DOH,9025,AKL]     [RUH,8246,LAX]\n[DXB,8818,AKL]     [IAH,8150,DXB]\n[MEX,8754,CAN]     [SFO,8139,AUH]\n[SYD,8574,DFW]     [HKG,8105,DFW]\n[JNB,8434,ATL]     [SFO,8085,DXB]\n[SIN,8433,SFO]     [JFK,8054,HKG]\n[LAX,8372,AUH]     [DFW,8053,AUH]\n[LAX,8321,DXB]     [HKG,8047,EWR]\n[LAX,8314,JED]     [IAH,8030,DOH]\n[LAX,8287,DOH]     [DXB,8022,DFW]\n```\n\nAs an interesting side note, and this would be true for the queries\nabove as well, if we replace the *lt* with a *gt* we will get the routes\nreturned in the reverse order.\n\n``` java\ng.V().as('s').\n      outE().has('dist',gt(8000)).\n      order().by('dist',desc).inV().as('f').\n      where('f',gt('s')).by('code').\n      path().by('code').by('dist')\n```\n\nUsing the prior query the first result was *\\[DOH,9025,AKL\\]*. As you\nwill see below, our first result is now *\\[AKL,9025,DOH\\]*.\n\n``` java\n[AKL,9025,DOH]     [LAX,8246,RUH]\n[AKL,8818,DXB]     [DXB,8150,IAH]\n[CAN,8754,MEX]     [AUH,8139,SFO]\n[DFW,8574,SYD]     [DFW,8105,HKG]\n[ATL,8434,JNB]     [DXB,8085,SFO]\n[SFO,8433,SIN]     [HKG,8054,JFK]\n[AUH,8372,LAX]     [AUH,8053,DFW]\n[DXB,8321,LAX]     [EWR,8047,HKG]\n[JED,8314,LAX]     [DOH,8030,IAH]\n[DOH,8287,LAX]     [DFW,8022,DXB]\n```",
            "children": []
          },
          {
            "level": "5.3.2",
            "title": "5.3.2. Finding the 20 longest routes in the graph {#_finding_the_20_longest_routes_in_the_graph}",
            "content": "We could write the query from the previous section a different way\nlooking at edges first and using the *project* step instead of using the\n*as* and *select* steps. While in general it is not recommended to start\na query with *g.E()* as there are typically a lot more edges than\nvertices in a graph this does illustrate a useful pattern. Also, just to\nchange things a bit, this time we just look for the 20 longest routes\nrather than looking for routes longer than 8,000 miles. We again filter\nthe results to only show the route in one direction. Note that the limit\nstep is passed a parameter of 40 rather than 20 as we know we will be\nfiltering out the same route in the return direction so we will actually\nonly get 20 routes back.\n\n``` java\ng.E().hasLabel('route').\n      order().by('dist',desc).limit(40).\n      project('a','b','c').\n        by(inV().values('code')).\n        by('dist').\n        by(outV().values('code')).\n      filter(select('a','c')).where('a',lt('c'))\n```\n\nHere are the results from running the query.\n\n``` java\n[a:AKL,b:9025,c:DOH]    [a:LAX,b:8246,c:RUH]\n[a:AKL,b:8818,c:DXB]    [a:DXB,b:8150,c:IAH]\n[a:CAN,b:8754,c:MEX]    [a:AUH,b:8139,c:SFO]\n[a:DFW,b:8574,c:SYD]    [a:DFW,b:8105,c:HKG]\n[a:ATL,b:8434,c:JNB]    [a:DXB,b:8085,c:SFO]\n[a:SFO,b:8433,c:SIN]    [a:HKG,b:8054,c:JFK]\n[a:AUH,b:8372,c:LAX]    [a:AUH,b:8053,c:DFW]\n[a:DXB,b:8321,c:LAX]    [a:EWR,b:8047,c:HKG]\n[a:JED,b:8314,c:LAX]    [a:DOH,b:8030,c:IAH]\n[a:DOH,b:8287,c:LAX]    [a:DFW,b:8022,c:DXB]\n```\n\nFor completeness, here is the query rewritten slightly to again start\nwith airport vertices rather than with all *route* edges but using *as*\nand *select* steps rather than using a *path* step as used in the\nprevious section. A *where* step followed by a *by* modulator is still\nused in this case. So once again, it is clear there are often many ways\nto get the results that you are looking for. The key is to think about\nwhich form of a query will be the most effective for the data that you\nare working with.\n\n``` java\ng.V().hasLabel('airport').as('a').\n      outE().as('b').\n      order().by('dist',desc).limit(40).\n      inV().as('c').\n      where('a',lt('c')).by('code').\n      select('a','b','c').by('code').by('dist')\n```\n\nWhen the query is run the results look like the ones from the prior\nquery.\n\n``` java\n[a:AKL,b:9025,c:DOH]    [a:LAX,b:8246,c:RUH]\n[a:AKL,b:8818,c:DXB]    [a:DXB,b:8150,c:IAH]\n[a:CAN,b:8754,c:MEX]    [a:AUH,b:8139,c:SFO]\n[a:DFW,b:8574,c:SYD]    [a:DFW,b:8105,c:HKG]\n[a:ATL,b:8434,c:JNB]    [a:DXB,b:8085,c:SFO]\n[a:SFO,b:8433,c:SIN]    [a:HKG,b:8054,c:JFK]\n[a:AUH,b:8372,c:LAX]    [a:AUH,b:8053,c:DFW]\n[a:DXB,b:8321,c:LAX]    [a:EWR,b:8047,c:HKG]\n[a:JED,b:8314,c:LAX]    [a:DOH,b:8030,c:IAH]\n[a:DOH,b:8287,c:LAX]    [a:DFW,b:8022,c:DXB]\n```",
            "children": []
          },
          {
            "level": "5.3.3",
            "title": "5.3.3. Finding the longest route from each airport {#longesteach}",
            "content": "The following query can be used to find the longest route from each\nairport in the graph. I included a *limit* step so that just a few\nresults are returned but if you were to remove it then every airport in\nthe graph would be represented in the query results. A local step is\nused so that for each airport all of its outgoing routes are analyzed.\nThose routes are ordered in descending order and only the first one is\nselected in each case.\n\n``` java\ng.V().hasLabel('airport').limit(10).\n      local(outE().\n            order().by('dist',desc).\n            inV().\n            path().\n              by('code').\n              by('dist').\n              limit(1))\n```\n\nWhen run the query produces the following results.\n\n``` java\n[ATL,8434,JNB]\n[ANC,3260,IAH]\n[AUS,5294,FRA]\n[BNA,1972,SEA]\n[BOS,7952,HKG]\n[BWI,3622,LHR]\n[DCA,2434,SFO]\n[DFW,8574,SYD]\n[FLL,7808,DXB]\n[IAD,7487,DEL]\n```",
            "children": []
          },
          {
            "level": "5.3.4",
            "title": "5.3.4. Combining *aggregate*, *union* and *filter* to compute distances {#aggrunion}",
            "content": "This next query is similar to the one we looked at in the [Finding all\nroutes between London, Munich and Paris](#aggrroutes) section. It uses\n*aggregate*, *union*, *filter* and *where* to factor certain airports in\nand out of a query. We find all airports in London, Munich and Paris and\nthen count the total distance of all routes from those airports as the\nfirst half of a *union*. The second half of the *union* only counts the\ndistances of routes that end up in one of our three selected cities.\n\n``` java\ng.V().has('city',within('London','Munich','Paris')).\n      aggregate('a').\n      outE().\n      union(values('dist').sum(),\n            filter(inV().where((within('a')))).\n              values('dist').sum())\n```\n\nHere are the results from running the query. As expected the first\nnumber is a lot bigger than the second one as it is the total distance\nof all routes from the selected airports whereas the second number only\nreflects the total distance of all routes between those airports.\n\n``` java\n2276209\n8906\n```",
            "children": []
          },
          {
            "level": "5.3.5",
            "title": "5.3.5. More queries that analyze distances {#_more_queries_that_analyze_distances}",
            "content": "Calculating the distance between two directly connected airports is very\neasy. All we have to do is look at the *dist* property of the edge that\nconnects them. We can do this using the *select* and *as* steps or in\nmore recent versions of TinkerPop we can use *path* and *by*. I prefer\nthe latter technique. Both ways are shown in the examples below that\nfind the distance between Austin and Mexico City\n\n``` java\n// Distance between the AUS and MEX airports\ng.V().has('code','AUS').outE().as('e').\n      inV().has('code','MEX').\n      select('e').values('dist')\n\n748\n```\n\nAs above but using *path* and *by*.\n\n``` java\n// Distance between the AUS and MEX airports\ng.V().has('code','AUS').outE().\n      inV().has('code','MEX').\n      path().by('code').by('dist')\n\n[AUS, 748, MEX]\n```\n\nHere are some more queries that are based on the distance between\nairports. The first query calculates how many routes there are between\n100 and 200 miles. As an exercise, If you remove the call to *count* the\nquery will list the routes. As you can see there are a lot of them!\n\n``` java\n// Routes Between 100 and 200 miles in length\ng.V().outE().has('dist',within(100..200)).\n      inV().\n      path().by('code').by('dist').\n      count()\n\n3029\n```\n\nThe next query is similar to the previous one but only counts routes\nthat are between airports located in the United States. As before, if\nyou remove the call to *count* the routes will be returned.\n\n``` java\n// Routes Between 100 and 200 miles in length, but only within the US.\ng.V().has('airport','country','US').\n      outE().has('dist',within(100..200)).\n      inV().has('country','US').\n      path().by('code').by('dist').\n      count()\n\n583\n```\n\nLastly, this query returns a list of all the routes from San Antonio\nalong with their distances. Some of the results are shown.\n\n``` java\n// Return a list of routes and their distances,\n// starting from San Antonio (SAT)\n\ng.V().has('code','SAT').\n  outE('route').inV().\n  path().by('code').by('dist')\n```\n\nHere are just a few of the results that this query returned.\n\n``` java\n[SAT,872,ATL]      [SAT,1140,MIA]\n[SAT,820,BNA]      [SAT,698,MEX]\n[SAT,1410,BWI]     [SAT,1097,MSP]\n[SAT,248,DFW]      [SAT,1093,CLT]\n[SAT,1360,IAD]     [SAT,1040,ORD]\n[SAT,190,IAH]      [SAT,931,CUN]\n[SAT,1580,JFK]     [SAT,841,PHX]\n[SAT,1210,LAX]     [SAT,624,MEM]\n[SAT,1038,MCO]     [SAT,1772,SEA]\n[SAT,1423,YYZ]     [SAT,707,MCI]\n```",
            "children": []
          },
          {
            "level": "5.3.6",
            "title": "5.3.6. How far is it from AUS to LHR with one stop? {#AUSLHR-OS}",
            "content": "The next query begins to address the question \\\"How far is it from AUS\nto LHR with one stop?\\\". We can quite easily come up with a query given\nwhat we now know about Gremlin that will show us all possible options\nwith one stop between AUS and LHR along with the respective route\ndistances.\n\n``` java\n// Return all ways of getting from AUS to LHR with one stop.\n// Include the distances between each of the airports in the\n// query result.\n\ng.V().has('airport','code','AUS').\n      outE().inV().outE().inV().\n      has('code','LHR').\n      path().by('code').by('dist')\n```\n\nThe output from running the query produces a nice set of data showing\nthe starting, intermediate and destination airports with the distances\nin miles between each. It would be nice though if we could find a way to\nshow the total distance that I will have to travel in each case. That is\nthe topic of the next section!\n\n``` java\n[AUS,1476,SJC,5352,LHR]       [AUS,183,DFW,4736,LHR]\n[AUS,1500,SFO,5350,LHR]       [AUS,1339,BWI,3622,LHR]\n[AUS,1768,SEA,4783,LHR]       [AUS,1500,EWR,3453,LHR]\n[AUS,866,PHX,5255,LHR]        [AUS,1690,BOS,3254,LHR]\n[AUS,973,ORD,3939,LHR]        [AUS,768,DEN,4655,LHR]\n[AUS,1040,MSP,4001,LHR]       [AUS,1080,LAS,5213,LHR]\n[AUS,1230,LAX,5439,LHR]       [AUS,809,ATL,4198,LHR]\n[AUS,1520,JFK,3440,LHR]       [AUS,1160,SAN,5469,LHR]\n[AUS,1140,DTW,3753,LHR]       [AUS,1357,YYZ,3544,LHR]\n[AUS,142,IAH,4820,LHR]        [AUS,5294,FRA,406,LHR]\n[AUS,1430,PHL,3533,LHR]       [AUS,748,MEX,5529,LHR]\n[AUS,1294,IAD,3665,LHR]       [AUS,1030,CLT,3980,LHR]\n```",
            "children": []
          },
          {
            "level": "5.3.7",
            "title": "5.3.7. Using *sack* to calculate the shortest AUS-LHR route with one stop {#sackauslhr}",
            "content": "Consider a typical use case for air travel. We want to calculate the\nshortest distance we will have to travel to go from one airport to\nanother with only one stop. Let's take a real example. What are the ten\nshortest distances from AUS to LHR with one stop on the way? Given what\nwe know of Gremlin so far we can pretty easily come up with a query that\nwill give us routes from AUS to LHR with just one stop like we did in\nthe previous section. However, what is not so obvious, and this is an\narea where the TinkerPop documentation is a little weak, is working out\nhow to keep a running total of values as we traverse a graph. This is\nwhere the *sack* step comes in. As you will hopefully recall from some\nof the earlier sections, a *sack* allows us to define a place where we\ncan put things as the graph traversal proceeds. We can give the sack an\nin initial value and can add to it during the traversal and then use it\nas part of the information that our query will return. Take a look at\nthe rather lengthy query below. I have laid it out in a way that I hope\nmakes it easy to read.\n\n``` java\n// Shortest distances from AUS to LHR with one stop\ng.withSack(0).\n  V().has('code','AUS').\n      outE().\n      sack(sum).by('dist').\n      inV().\n      outE().\n      sack(sum).by('dist').\n      inV().has('code','LHR').\n      sack().\n      order().by(asc).limit(10).\n      path().\n        by('code').\n        by('dist').\n        by('code').\n        by('dist').\n        by('code').\n        by()\n```\n\nOn the first line of the query, we initialize our sack with the value\nzero. During the query, each time we take an outgoing edge, we add the\ndistance value for that edge to the sack. We filter out routes in the\nnormal way by only keeping destinations that are *LHR*. After finding\nthe routes we care about we take the values that are stored in our sack\nand use them to sort our results in ascending order. Finally on we\nprocess the paths that we have taken. Note that the sack value is\nincluded as part of the path output and referenced using a *by*\nmodulator that has no parameter. Running the query will produce the\nfollowing results:\n\n``` java\n[AUS, 1140, DTW, 3753, LHR, 4893]\n[AUS, 1357, YYZ, 3544, LHR, 4901]\n[AUS, 973,  ORD, 3939, LHR, 4912]\n[AUS, 183,  DFW, 4736, LHR, 4919]\n[AUS, 1690, BOS, 3254, LHR, 4944]\n[AUS, 1500, EWR, 3453, LHR, 4953]\n[AUS, 1294, IAD, 3665, LHR, 4959]\n[AUS, 1520, JFK, 3440, LHR, 4960]\n[AUS, 1339, BWI, 3622, LHR, 4961]\n[AUS, 142,  IAH, 4820, LHR, 4962]\n```\n\n::: note\nIn Tinkerpop 3.3 the syntax of *sack* was changed. Where previously you\nwould write something like *sack(sum,*\\'runways\\'*)* you are now\nrequired to write *sack(sum).by(*\\'runways\\'*)*. The prior format was\nalready deprecated in Tinkerpop 3.2.5 but is now fully removed starting\nwith Tinkerpop 3.3.\n:::\n\nWe could add a little post processing to our query to only output the\nairport codes and the total mileage. Given this is post processing of a\nsmall data set, using a bit of in-line code does not feel too ugly here.\n\n``` java\ng.withSack(0).V().\n  has('code','AUS').\n  outE().\n  sack(sum).by('dist').\n  inV().\n  outE().\n  sack(sum).by('dist').\n  inV().has('code','LHR').\n  sack().\n  order().by(asc).limit(10).\n  path().\n    by('code').\n    by('dist').\n    by('code').\n    by('dist').\n    by('code').\n    by().\n  toList().\n  each(){println \"${it[0]} --> ${it[2]} --> ${it[4]} ${it[5]} miles\"}[];\n```\n\nHere is what our modified query, with the Groovy post processing added,\nproduces.\n\n``` java\nAUS --> DTW --> LHR 4893 miles\nAUS --> YYZ --> LHR 4901 miles\nAUS --> ORD --> LHR 4912 miles\nAUS --> DFW --> LHR 4919 miles\nAUS --> BOS --> LHR 4944 miles\nAUS --> EWR --> LHR 4953 miles\nAUS --> IAD --> LHR 4959 miles\nAUS --> JFK --> LHR 4960 miles\nAUS --> BWI --> LHR 4961 miles\nAUS --> IAH --> LHR 4962 miles\n```",
            "children": []
          },
          {
            "level": "5.3.8",
            "title": "5.3.8. Another example of how *sack* can be used {#anothersack}",
            "content": "The query below finds all airports with more than 200 routes and returns\nthem as a map of airport code and route count pairs.\n\n``` java\n// Print a table of airports with more than 200 routes and the number of routes\ng.V().hasLabel('airport').\n      where(out().count().is(gt(200))).\n      group().\n        by('code').\n        by(outE().count())\n```\n\nHere are the results that the query generates.\n\n``` java\n[ORD:226, DFW:216, FRA:254, CDG:253, PEK:232, AMS:257, ATL:232, MUC:219, IST:259, DME:206, DXB:225]\n```\n\nThe prevous query is a perfectly good way to achieve the desired result.\nJust for fun let's produce the same results using a *sack*. This is\nintended just as an example of how *sack* works and is not the way you\nwould actually want to perform this specific query. That said, it is\nuseful to have an example where the contents of the sack is more complex\nthan a simple integer value. At the start of the query we initialize our\nsack with an empty map *\\[:\\]*. Later in the query, for each airport\nthat has more than 200 outgoing routes, we update the map by adding the\nairport code and the route count to the map. Note that the value part of\neach map entry is produced using a traversal. So while this query is\nmost definitely overkill for the task (as demonstrated by the much\nsimpler query above) it does provide us with another example of how you\ncan use sacks in powerful ways to store data as your query iterates.\n\n``` java\n// The same query but done using the new sack() step in TinkerPop 3\n// shown as an example only. The prior query works just fine for this.\n\ng.withSack([:]).\n  V().hasLabel('airport').\n  where(out().count().is(gt(200))).\n  sack{m,v -> m[v.value('code')]=g.V(v).out().count().next()}.\n  fold().sack()\n```\n\nHere are the results that the new query generates. Other than the fact\nthat the results came back in a different order they are the same.\n\n``` java\n[ATL:232, DFW:216, ORD:226, CDG:253, FRA:254, DXB:225, PEK:232, AMS:257, MUC:219, DME:206, IST:259]\n```\n\nThe *fold* step is needed in the query above to make sure that the\nresult we get back is returned as a map. If we left the *fold* off we\nwould just get the values stored in the sack returned as a list of\nintegers. Note that while the list of airports is the same as the\nprevious query, the order is different. This is a result of the way the\n*group* step did its work in the previous query. Order should never be\nrelied upon. If you need a specific order for the results of a query it\nis always recommended to perform an explicit *order* step as\nappropriate.\n\nFor completeness, a way of sorting the results of our original query by\nascending route count (values) is shown below.\n\n``` java\ng.V().hasLabel('airport').\n      where(out().count().is(gt(200))).\n      group().by('code').by(outE().count()).\n      order(local).by(values)\n\n[DME:213,DFW:221,DXB:229,ORD:232,PEK:232,ATL:232,MUC:237,CDG:260,FRA:266,AMS:269,IST:270]\n```\n\nIf you wanted to sort using the airport codes you could do it as\nfollows. This time we will sort the results of the *sack* based query.\n\n``` java\ng.withSack([:]).\n  V().hasLabel('airport').where(out().count().is(gt(200))).\n  sack{m,v -> m[v.value('code')]=g.V(v).out().count().next()}.\n  fold().\n  sack().\n  order(local).by(keys)\n\n[AMS:269,ATL:232,CDG:260,DFW:221,DME:213,DXB:229,FRA:266,IST:270,MUC:237,ORD:232,PEK:232]\n```\n\nAs well as using *withSack* to initialize a *sack* you can also use the\n*assign* operator to do it. The query below uses a constant value of 0\nto initialize the sack and then uses the sack to count the number or\nrunways that the airports you can fly to from Austin have. At the end of\nthe query we perform a *sum* step against the sack which will contain a\nlist holding number of runways for each individual airport so we need to\nadd all of those to get a single grand total.\n\n``` java\ng.V().has('code','AUS').\n      sack(assign).by(constant(0)).\n      out().\n      sack(sum).by('runways').\n      sack().sum()\n\n212\n```",
            "children": []
          }
        ]
      },
      {
        "level": "5.4",
        "title": "5.4. Using latitude, longitude and geographical region in queries {#latlonmanual}",
        "content": "The *air-routes* graph stores the geographic coordinates (latitude and\nlongitude) of each airport as floating point numbers. Some graph systems\nsuch as JanusGraph have geographic coordinate and shape (geospatial)\nfunctions built in, but TinkerGraph does not. Moreover, GraphML does not\noffer any specific geospatial support. To keep things simple and\nflexible, the air routes data set does not assume any specific back end\ncapabilities. Having coordinates provided as basic floating point\nnumbers still allows us to write some interesting geospatial queries.\n\nSo far, we have not taken advantage of these latitude and longitude\ncoordinates in queries. In this section I have included some queries\nthat perform interesting geospatial calculations using just the standard\nGremlin steps.\n\nHere is a simple query that finds any airports located North of 77\ndegrees latitude. Note that a *where* step could be used instead of\n*filter* as they are synonymous in this case.\n\n``` java\ng.V().filter(values('lat').is(gt(77))).valueMap('city','lat')\n```\n\nAs discussed earlier in the book, you can often just use *has* steps\ninstead of *where* or *filter* steps. We could have written the previous\nquery as follows.\n\n``` java\ng.V().has('lat',gt(77)).valueMap('city','lat')\n```\n\nIt turns out that just two airports in the graph are located that far\nNorth as shown below in the results from running either form of the\nquery.\n\n``` java\n[city:[Longyearbyen],lat:[78.2461013793945]]\n[city:[Qaanaaq],lat:[77.4886016846]]\n```\n\nWe could modify our query to look for airports with a latitude value\noutside of a provided upper and lower bound thus finding the most\nNortherly and Southerly airports with a single query. Here is a simple\nexample of such a query.\n\n``` java\ng.V().has('lat',outside(-50,77)).order().by('lat',asc).valueMap('city','lat')\n```\n\nHere are the airports found by running the query.\n\n``` java\n[city:[Ushuahia],lat:[-54.8433]]\n[city:[Rio Grande],lat:[-53.7777]]\n[city:[Punta Arenas],lat:[-53.0026016235352]]\n[city:[Mount Pleasant],lat:[-51.8227996826172]]\n[city:[Stanley],lat:[-51.6856994628906]]\n[city:[Puerto Natales],lat:[-51.671501159668]]\n[city:[Rio Gallegos],lat:[-51.6089]]\n[city:[El Calafate],lat:[-50.2803001404]]\n[city:[Qaanaaq],lat:[77.4886016846]]\n[city:[Longyearbyen],lat:[78.2461013793945]]\n```\n\nNote that while writing the above query it might have seemed appropriate\nto use a *without* step with a range such as *-50..77* but that will not\nwork as without looks for exact matches against the values in the range\nand the range generated is of the form *-50,-49,-48* and so on, so the\nonly airports that would get filtered out would be the ones having a\nlatitude value that exactly matches one of the values generated by the\nrange. This is why the *outside* step is so useful in cases like this.\n\nThis next query just returns the coordinates for London Heathrow.\n\n``` java\n// Query latitude and longitude for LHR\ng.V().has('airport','code','LHR').valueMap('lat','lon')\n\n[lon:[-0.461941003799], lat:[51.4706001282]]\n```\n\nThis next query returns the code, latitude and longitude for all\nairports in London, England. Note that because there are other cities in\nthe world also called London, such as London, Ontario in Canada, we have\nto take advantage of the region code *GB-ENG* to only return airports in\nLondon, England.\n\n``` java\ng.V().has('airport','city','London').has('region','GB-ENG').valueMap('code','lat','lon')\n[code:[LHR], lon:[-0.461941003799], lat:[51.4706001282]]\n[code:[LGW], lon:[-0.190277993679047], lat:[51.1481018066406]]\n[code:[LCY], lon:[0.055278], lat:[51.505278]]\n[code:[STN], lon:[0.234999999404], lat:[51.8849983215]]\n[code:[LTN], lon:[-0.368333011865616], lat:[51.874698638916]]\n```\n\nNow that we know how to query the geographic coordinates, we can write a\nquery to find out which airports in the graph are very close to the\nGreenwich Meridian. In this case we will look for any airports that have\na longitude between -0.1 and 0.1\n\n``` java\n// Which airports are very close to the Greenwich Meridian ?\ng.V().hasLabel('airport').has('lon',between(-0.1,0.1)).valueMap('code','lon')\n\n[code:[LCY], lon:[0.055278]]\n[code:[LDE], lon:[-0.006438999902457]]\n[code:[LEH], lon:[0.0880559980869293]]\n[code:[CDT], lon:[0.0261109992862]]\n```\n\nThis next query can be used to find out which airports are closest to\nthe equator.\n\n``` java\n// Which airports are closest to the Equator ?\ng.V().hasLabel('airport').has('lat',between(-0.1,0.1)).valueMap('code','lat')\n\n[code:[EBB], lat:[0.0423859991133213]]\n[code:[MDK], lat:[0.0226000007242]]\n[code:[KIS], lat:[-0.0861390009522438]]\n[code:[MCP], lat:[0.0506640002131]]\n[code:[LGQ], lat:[0.0930560007691]]\n```\n\nThe code below will find all the airports in the geographic area defined\nby a one degree box around London Heathrow. This type of thing can be\ndone using the Geo shape classes provided by JanusGraph but given we are\nnot at that part of the book yet this is the next best way!\n\n``` java\nlat = g.V().has('code','LHR').values('lat').next()\nlon = g.V().has('code','LHR').values('lon').next()\n\ng.V().hasLabel('airport').where(and(\n                          values('lon').is(between(lon-1,lon+1)),\n                          values('lat').is(between(lat-1,lat+1)))).\n                          valueMap('code','lat','lon')\n```\n\nAs we have discussed earlier in this book, it is often possible to avoid\nuse of *and* step by chaining *has* steps together. The code below is\nequivalent to the code above but avoids the use of *where* and *and*.\n\n``` java\nlat = g.V().has('code','LHR').values('lat').next()\nlon = g.V().has('code','LHR').values('lon').next()\n\ng.V().hasLabel('airport').has('lon',between(lon-1,lon+1)).\n                          has('lat',between(lat-1,lat+1)).\n                          valueMap('code','lat','lon')\n```\n\nHere is the output produced by running either of the snippets of code\nabove inside the Gremlin Console.\n\n``` java\n[code:[LHR],lon:[-0.461941003799],lat:[51.4706001282]]\n[code:[LGW],lon:[-0.190277993679047],lat:[51.1481018066406]]\n[code:[LCY],lon:[0.055278],lat:[51.505278]]\n[code:[STN],lon:[0.234999999404],lat:[51.8849983215]]\n[code:[LTN],lon:[-0.368333011865616],lat:[51.874698638916]]\n[code:[SOU],lon:[-1.35679996013641],lat:[50.9502983093262]]\n```\n\nIn the \\\"[Testing values and ranges of values](#tranges)\\\" section we\ncame up with a query (shown below) to find routes with one stop between\nAustin and Las Vegas, using only airports in the United States or Canada\nand avoiding PHX and LAX for plane changes.\n\n``` java\ng.V().has('airport','code','AUS').out().\n      has('country',within('US','CA')).\n      has('code',without('PHX','LAX')).out().\n      has('code','LAS').path().by('code')\n```\n\nNow that we know how to use the longitude and latitude coordinates\nstored in the air routes graph, we could for fun, write this query a\ndifferent way. If you take a look at the query below you will see we\nhave added a *where* step. We still check that we are only looking at\nairports in the United States or Canada but then, in the *where* step,\nwe further limit the airports we want to consider further by saying we\nare only interested if their longitude value is less than that of\nAustin. In other words, we only want to change planes at an airport that\nis to the West of Austin. This is actually an improvement on the\nprevious query that would have returned routes that included plane\nchanges in New York and Nashville among other places. With our new\nquery, no airport that is East of Austin will be considered as a place\nto change planes.\n\n``` java\n// AUS to LAS with one stop but the stop has to be in the US or Canada\n// and West of Austin while avoiding PHX and LAX.\n\ng.V().has('airport','code','AUS').as('aus').out().\n      has('country',within('US','CA')).\n      where(lt('aus')).by('lon').\n      has('code',without('PHX','LAX')).out().\n      has('code','LAS').path().by('code')\n```\n\nBelow you will find the output from running the query. If you know your\nairport codes you will see that all of these airports are indeed to the\nWest of Austin. We might want to improve the query even more however, to\nfactor in sensible nearby airports that are not to the West of Austin.\nFor example, Dallas Fort Worth (DFW) is not included in the results as\nit is situated North of Austin but also a little to the East. We will\nleave it as an exercise to come up with a refinement to the query so\nthat Dallas is also included!.\n\n``` java\n[AUS,PDX,LAS]\n[AUS,ABQ,LAS]\n[AUS,LBB,LAS]\n[AUS,SEA,LAS]\n[AUS,SFO,LAS]\n[AUS,SJC,LAS]\n[AUS,SAN,LAS]\n[AUS,LGB,LAS]\n[AUS,SNA,LAS]\n[AUS,SLC,LAS]\n[AUS,DEN,LAS]\n[AUS,ELP,LAS]\n[AUS,OAK,LAS]\n```\n\nHere is one more example that is similar to the previous one. First of\nall we store the longitude of the Dallas (DFW) airport in the variable\n*dfw*. Then we use that variable to find routes to Las Vegas (LAS) from\nAustin (AUS) that have one stop but avoid Phoenix (PHX) and Los Angeles\n(LAX) and only have a plane change either in Dallas or to the West of\nDallas. Note that we use *lte* and not *lt* when testing the longitude\nvalue. It we used *lt* instead that would also rule out Dallas as an\noption. This query, as in the prior one, has the effect of ruling out\nplane changes at airports further to the East of Austin than Dallas.\n\n``` java\ndfw = g.V().has('code','DFW').values('lon').next()\n\ng.V().has('airport','code','AUS').as('aus').out().\n      has('country',within('US','CA')).\n      has('lon',lte(dfw)).\n      has('code',without('PHX','LAX')).out().\n      has('code','LAS').path().by('code')\n```\n\nHere is what we get back when we run the query. Still lots of choices\neven if we avoid LAX and PHX it seems.\n\n``` java\n[AUS,PDX,LAS]\n[AUS,ONT,LAS]\n[AUS,ABQ,LAS]\n[AUS,LBB,LAS]\n[AUS,DFW,LAS]\n[AUS,SEA,LAS]\n[AUS,SFO,LAS]\n[AUS,SJC,LAS]\n[AUS,SAN,LAS]\n[AUS,LGB,LAS]\n[AUS,SNA,LAS]\n[AUS,SLC,LAS]\n[AUS,DEN,LAS]\n[AUS,ELP,LAS]\n[AUS,OAK,LAS]\n```\n\nLet's look at one last query that uses the *region* property, present on\nall airport vertices in the graph.\n\nThe query below starts at the DFW airport then looks for all routes to\nairports also within the United States. Next those airports are grouped\nby their region code and airport code. Finally a few states are\nselected. The query ends with an *unfold* step to make the results a bit\nmore readable.\n\n``` java\ng.V().has('airport','code','DFW').out().has('country','US').\n      group().by('region').by('code').\n      select('US-CA','US-TX','US-FL','US-CO','US-IL').unfold()\n```\n\nBelow you can see the query results. Each of the selected states is\nlisted along with a list of airports reachable from DFW.\n\n``` java\nUS-CA=[LAX, SFO, SJC, SAN, SNA, OAK, ONT, PSP, SMF, FAT, SBA]\nUS-TX=[AUS, IAH, SAT, HOU, ELP, LBB, MAF, CRP, ABI, ACT, CLL,\n       BPT, AMA, BRO, GGG, GRK, LRD, MFE, SJT, SPS, TYR]\nUS-FL=[FLL, MCO, MIA, PBI, TPA, RSW, TLH, JAX, PNS, VPS]\nUS-CO=[DEN, COS, DRO, GJT, EGE, HDN, ASE, GUC, MTJ]\nUS-IL=[ORD, PIA, BMI, CMI, MLI, SPI]\n```\n\nIn the next section we will look at a more complicated query that builds\nupon the examples above and performs distance calculations using the\nlatitude and longitude coordinates present on the airport vertices.",
        "children": [
          {
            "level": "5.4.1",
            "title": "5.4.1. Using the *math* step to calculate Great Circle distances {#GreatCircle}",
            "content": "If the latitude and longitude of two places on the Earth are known, the\napproximate distance between them can be calculated using the Haversine\nGreat Circle Distance formula. The formula includes some trigonometrical\ncalculations that can be done in Gremlin using the *math* step.\n\n::: note\nIf you are interested in better understanding the mathematics used by\nthe Haversine formula, details can be found\n[here](https://en.wikipedia.org/wiki/Haversine_formula).\n:::\n\nIn this section I have included two queries. The first calculates the\ndistance between Austin and Dallas Fort Worth using a somewhat\ninflexible approach. This reflects my first attempt to create a query\nthat computes Great Circle distances all in Gremlin. The airport codes\nare embedded in the query. Having got that working I realized a more\ngeneric query would be better. The second example allows an arbitrary\nsource and destination to be specified.\n\nLet's take a look at the queries. At first, the number of steps used may\nlook a bit daunting, but if you work your way through it section by\nsection it's actually fairly straightforward. The Haversine formula\nneeds a couple of constant values. These are injected into the query\nusing *withSideEffect* steps. The first constant, *rdeg* represents one\ndegree in radians. This is the result from dividing PI by 180. The\nsecond constant *gcmiles* represents the average radius of the Earth in\nmiles. This allows for the imperfect spherical shape of the Earth where\nthe radius varies closer to the poles.\n\nIn my first attempt at producing a query, I used a *has* step to find\nthe AUS and DFW airports and then produced a group with the airport\ncodes being the keys and a projection of their latitude and longitude\nbeing the values. If we take just that part of the query and run it this\nis what we get back.\n\n``` java\ng.withSideEffect(\"rdeg\", 0.017453293).\n  withSideEffect(\"gcmiles\",3956).\n  V().\n  has('code',within('AUS','DFW')).\n  group().\n    by('code').\n    by(project('lat','lon').\n      by('lat').\n      by('lon'))\n\n[DFW:[lat:32.896800994873,lon:-97.0380020141602],\n AUS:[lat:30.1944999694824,lon:-97.6698989868164]]\n```\n\nThe Haversine formula requires us to calculate the differences between\nthe latitude and longitude of the two coordinates. The next part of the\nquery does that. A project step\n*project(\\'ladiff*,*lgdiff*,*lat1*,*lon1*,*lat2*,*lon2*)\\' is used to\ncollect all the values we need.\n\n``` java\ng.withSideEffect(\"rdeg\", 0.017453293).\n  withSideEffect(\"gcmiles\",3956).\n  V().\n  has('code',within('AUS','DFW')).\n  group().\n    by('code').\n    by(project('lat','lon').\n      by('lat').\n      by('lon')).\n  as('grp').\n  project('ladiff','lgdiff','lat1','lon1','lat2','lon2').\n    by(project('la1','la2').\n         by(select('AUS').select('lat')).\n         by(select('DFW').select('lat')).\n       math('(la2 - la1) * rdeg')).\n    by(project('lg1','lg2').\n         by(select('AUS').select('lon')).\n         by(select('DFW').select('lon')).\n       math('(lg2 - lg1) * rdeg')).\n    by(select('grp').select('AUS').select('lat')).\n    by(select('grp').select('AUS').select('lon')).\n    by(select('grp').select('DFW').select('lat')).\n    by(select('grp').select('DFW').select('lon'))\n```\n\nHere are the results. A map has been generated containing the\ndifferences as well as the original coordinates.\n\n``` java\n[ladiff:0.04716405157034253,\n lgdiff:0.011028683009581777,\n lat1:30.1944999694824,\n lon1:-97.6698989868164,\n lat2:32.896800994873,\n lon2:-97.0380020141602]\n```\n\nThe purpose of collecting the values like this is so they can be fed\ninto the *math* step to complete the calculation. One key takeaway from\nthis example is the way that a *math* step can be fed values from a\nprior *project* step. The final calculations perform the necessary\ntrigonometry as required by the Haversine formula. Here is the complete\nversion of my first attempt at solving this problem in Gremlin.\n\n``` java\ng.withSideEffect(\"rdeg\", 0.017453293).\n  withSideEffect(\"gcmiles\",3956).\n  V().\n  has('code',within('AUS','DFW')).\n  group().\n    by('code').\n    by(project('lat','lon').\n      by('lat').\n      by('lon')).\n  as('grp').\n  project('ladiff','lgdiff','lat1','lon1','lat2','lon2').\n    by(project('la1','la2').\n         by(select('AUS').select('lat')).\n         by(select('DFW').select('lat')).\n       math('(la2 - la1) * rdeg')).\n    by(project('lg1','lg2').\n         by(select('AUS').select('lon')).\n         by(select('DFW').select('lon')).\n       math('(lg2 - lg1) * rdeg')).\n    by(select('grp').select('AUS').select('lat')).\n    by(select('grp').select('AUS').select('lon')).\n    by(select('grp').select('DFW').select('lat')).\n    by(select('grp').select('DFW').select('lon')).\n  math('(sin(ladiff/2))^2 + cos(lat1*rdeg) * cos(lat2*rdeg) * (sin(lgdiff/2))^2').\n  math('gcmiles * (2 * asin(sqrt(_)))')\n```\n\nWe can see that the distance from Austin to Dallas Fort Worth is\napproximately 190 miles.\n\n``` java\n190.2483140396514\n```\n\nA few adjustments are needed to make the query more flexible. I wanted\nto have a query where you just provide any two airport codes at the\nstart. This makes it easy to parameterize the query when working with\ncode. The main difference from my first attempt is that the source and\ntarget airports are located at the start and individually labelled. The\n`group` step is replaced by a `select` step and given a label of\n\\\"grp\\\". The remainder of the query refers to \\\"grp\\\" as needed.\n\n``` java\ng.withSideEffect(\"rdeg\", 0.017453293).\n  withSideEffect(\"gcmiles\",3956).\n  V().has('code','AUS').as('src').\n  V().has('code','DFW').as('dst').\n  select('src','dst').\n    by(project('lat','lon').\n         by('lat').\n         by('lon')).\n  as('grp').\n  project('ladiff','lgdiff','lat1','lon1','lat2','lon2').\n    by(project('la1','la2').\n         by(select('grp').select('src').select('lat')).\n         by(select('grp').select('dst').select('lat')).\n       math('(la2 - la1) * rdeg')).\n    by(project('lg1','lg2').\n         by(select('grp').select('src').select('lon')).\n         by(select('grp').select('dst').select('lon')).\n       math('(lg2 - lg1) * rdeg')).\n    by(select('grp').select('src').select('lat')).\n    by(select('grp').select('src').select('lon')).\n    by(select('grp').select('dst').select('lat')).\n    by(select('grp').select('dst').select('lon')).\n  math('(sin(ladiff/2))^2 + cos(lat1*rdeg) * cos(lat2*rdeg) * (sin(lgdiff/2))^2').\n  math('gcmiles * (2 * asin(sqrt(_)))')\n```\n\nThe result from the more general purpose version of the query is the\nsame as before.\n\n``` java\n190.2483140396514\n```\n\n::: note\nThe code for this query is available in the sample-code folder at\n<https://github.com/krlawrence/graph/blob/main/sample-code/great-circle.groovy>\n:::\n\nWe can go one step further and parameterize the query. Everything shown\nbelow can be done using the Gremlin Console but it also represents the\nway you might use this query within an application. This time San\nFrancisco and Tokyo Narita are used as the origin and destination.\n\n``` java\nstart = 'SFO'\nstop = 'NRT'\n\ng.withSideEffect(\"rdeg\", 0.017453293).\n  withSideEffect(\"gcmiles\",3956).\n  V().has('code',start).as('src').\n  V().has('code',stop).as('dst').\n  select('src','dst').\n    by(project('lat','lon').\n         by('lat').\n         by('lon')).\n  as('grp').\n  project('ladiff','lgdiff','lat1','lon1','lat2','lon2').\n    by(project('la1','la2').\n         by(select('grp').select('src').select('lat')).\n         by(select('grp').select('dst').select('lat')).\n       math('(la2 - la1) * rdeg')).\n    by(project('lg1','lg2').\n         by(select('grp').select('src').select('lon')).\n         by(select('grp').select('dst').select('lon')).\n       math('(lg2 - lg1) * rdeg')).\n    by(select('grp').select('src').select('lat')).\n    by(select('grp').select('src').select('lon')).\n    by(select('grp').select('dst').select('lat')).\n    by(select('grp').select('dst').select('lon')).\n  math('(sin(ladiff/2))^2 + cos(lat1*rdeg) * cos(lat2*rdeg) * (sin(lgdiff/2))^2').\n  math('gcmiles * (2 * asin(sqrt(_)))')\n\n5108.80166113392\n```\n\nWe will revisit the topic of performing geospatial queries in the \\\"[The\nJanusGraph GeoSpatial API](#janusgeo)\\\" section where some additional\ncapabilities that JanusGraph offers are discussed.",
            "children": []
          }
        ]
      },
      {
        "level": "5.5",
        "title": "5.5. Finding routes that go via a specific airport {#via}",
        "content": "We have seen a number of examples that use a *has* step to filter\nroutes. The example below looks for five routes that start in Austin\n(AUS) and go via Dallas (DFW).\n\n``` java\ng.V().has('code','AUS').\n      out().has('code','DFW').\n      out().\n      limit(5).\n      path().by('code')\n```\n\nWhen run the query, as expected finds us five routes that start in AUS\nand stop at DFW on the way.\n\n``` java\n[AUS,DFW,ATL]\n[AUS,DFW,ANC]\n[AUS,DFW,AUS]\n[AUS,DFW,BNA]\n[AUS,DFW,BOS]\n```\n\nThis technique works well if we know which stop we want to be in DFW.\nHowever, we might want to write a query that can only return results\nthat include a visit to a specific airport anywhere in the journey.\nLet's build an example in two stages. First of all look at the query\nbelow. It looks for ten routes that start in Austin and end up in\nEdinburgh only stopping along the way in US or the UK airports.\n\n``` java\ng.V().\n  has('code','AUS').\n  repeat(out().simplePath().has('country',within('US','UK'))).\n    until(has('code','EDI')).\n  path().by('code').\n  limit(10)\n```\n\nWhen run we get the following results.\n\n``` java\n[AUS,LHR,EDI]\n[AUS,JFK,EDI]\n[AUS,EWR,EDI]\n[AUS,LHR,MAN,EDI]\n[AUS,LHR,BHD,EDI]\n[AUS,LHR,INV,EDI]\n[AUS,LHR,JFK,EDI]\n[AUS,LHR,EWR,EDI]\n[AUS,PIT,JFK,EDI]\n[AUS,PIT,EWR,EDI]\n```\n\nHowever, for the sake of making the example more interesting, let's\nassume that we only want to get back routes that go via Manchester\n(MAN). We can do this by adjusting the prior query to look for \\\"MAN\\\"\nas it traverses the graph and keep track, using a sack, of paths that\nencounter Manchester along the way. Once we arrive at EDI we use a\n*where* step to filter out routes where the value of the sack is\nanything but \\\"1\\\". A value of \\\"1\\\" means we encountered Manchester\nalong the way.\n\n``` java\ng.withSack(0).V().\n  has('code','AUS').\n  repeat(out().simplePath().has('country',within('US','UK')).\n         choose(has('code','MAN'),sack(sum).by(constant(1)))).\n    until(has('code','EDI')).\n  where(sack().is(1)).\n  path().by('code').\n  limit(10)\n```\n\nWhen the modified query is run, each result includes MAN in the path.\n\n``` java\n[AUS,LHR,MAN,EDI]\n[AUS,ATL,MAN,EDI]\n[AUS,BOS,MAN,EDI]\n[AUS,IAD,MAN,EDI]\n[AUS,IAH,MAN,EDI]\n[AUS,JFK,MAN,EDI]\n[AUS,LAX,MAN,EDI]\n[AUS,MCO,MAN,EDI]\n[AUS,MIA,MAN,EDI]\n[AUS,ORD,MAN,EDI]\n```\n\nIf we you increase the limit step to use a value such as 30, then you\nwill start to see that MAN can appear in any position in the path.\n\n``` java\n[AUS,LHR,GLA,MAN,EDI]\n[AUS,LHR,ABZ,MAN,EDI]\n[AUS,LHR,BHD,MAN,EDI]\n[AUS,LHR,INV,MAN,EDI]\n```",
        "children": []
      },
      {
        "level": "5.6",
        "title": "5.6. Using *store* and a *sideEffect* to make a set of unique values {#storesideeffect}",
        "content": "Take a look at the query below. All it does is return the city names for\nthe airports that have IDs between 1 and 200 (inclusive). The list is\nsorted by ascending aplhabetic order.\n\n``` java\ng.V().hasId(between(1,201)).values('city').order().fold()\n```\n\nAnd here are the names that get returned. If you look closely at the\nlist you will see that city names like *Dallas* and *London* appear more\nthan once.\n\n``` java\n[Abu Dhabi, Addis Ababa, Albuquerque, Alicante, Alice Springs, Amsterdam, Anchorage, Athens, Atlanta, Auckland, Austin, Ayers Rock, Baltimore, Bankok, Barcelona, Beijing, Belgrade, Bengaluru, Berlin, Bilbao, Bologna, Boston, Brisbane, Brussels, Budapest, Buenos Aires, Cairns, Cairo, Calgary, Calicut, Canberra, Cancun, Cape Town, Cedar Rapids, Charlotte, Chennai, Chicago, Chicago, Christchurch, Cincinnati, Cleveland, Cologne, Copenhagen, Dallas, Dallas, Denver, Detroit, Doha, Dubai, Dublin, Durban, Dusseldorf, Edinburgh, Edmonton, El Paso, Fairbanks, Fort Lauderdale, Fort Myers, Frankfurt, Geneva, Genoa, Glasgow, Gold Coast, Gothenburg, Hagta, Halifax, Hamburg, Harrison, Helsinki, Ho Chi Minh City, Hong Kong, Honolulu, Houston, Houston, Hyderabad, Ibiza, Indianapolis, Istanbul, Johannesburg, Kahului, Kansas City, Kingston, Kolkata, Kuala Lumpur, Kuwait, Larnaca, Las Vegas, Lima, Liverpool, London, London, London, London, Long Beach, Los Angeles, Luqa, Luxembourg, Madrid, Manama, Manchester, Manila, Maroochydore, Melbourne, Memphis, Menorca, Mexico City, Miami, Milan, Milwaukee, Minneapolis, Mombasa, Montevideo, Montreal, Moscow, Moscow, Mumbai, Munich, Nairobi, Nantes, Naples, Nashville, New Delhi, New Orleans, New York, New York, Newark, Nice, Nottingham, Oaklahoma City, Oakland, Omaha, Ontario, Orlando, Osaka, Oslo, Ottawa, Palm Springs, Paris, Paris, Perth, Philadelphia, Phnom Penh, Phoenix, Pisa, Pittsburgh, Portland, Portland, Prague, Puerto Vallarta, Raleigh, Rio de Janeiro, Rochester, Rochester, Rome, Salina, Salt Lake City, San Antonio, San Diego, San Francisco, San Jose, San Juan, Santa Ana, Santa Fe, Santiago, Sao Paulo, Seattle, Seoul, Shanghai, Shannon, Singapore, Sofia, St Louis, St. Johns, Stockholm, Stuttgart, Sydney, Tallahassee, Tampa, Tel Aviv, Tenerife, Tokyo, Tokyo, Toronto, Tucson, Tulsa, Turin, Vancouver, Venice, Venice, Verona, Vienna, Warsaw, Washington D.C., Washington D.C., Wellington, West Palm Beach, White Plains, Winnipeg, Zagreb, Zurich]\n```\n\nJust to be sure, we can count how many city names we got back.\n\n``` java\ng.V().hasId(between(1,201)).values('city').order().count()\n\n200\n```\n\nWhat would be nice is if the duplicate names only appeared once. There\nare other ways we could write this query such as using *dedup* but let's\nrewrite it using *store* and a *Set* as I think doing that demonstrates\na capability quite well that is useful in more complex scenarios than\nthis one. By starting a query using *withSideEffect* we can setup a\nnamed place we can *store* things into later in our query and we can\nalso give the store a type. In this case I chose to use a *Set*. What\nthis query does is store the City names of the first 200 vertices in the\ngraph into a Set and then displays them. As we know from our first\nattempt, city names, like Dallas, appear more than once. However if we\nlook at the Set that we get back from our modified query (because by\ndefault Sets do not store duplicates) we will only see the names Dallas\nand London appearing once.\n\n``` java\ng.withSideEffect(\"x\", [] as Set).V().hasId(between(1,201)).\n  values('city').store('x').cap('x').unfold().order().fold()\n```\n\nHere are the city names that we get back after running our modified\nquery. You will notice that all of the duplicate names are now gone.\n\n``` java\n[Abu Dhabi, Addis Ababa, Albuquerque, Alicante, Alice Springs, Amsterdam, Anchorage, Athens, Atlanta, Auckland, Austin, Ayers Rock, Baltimore, Bankok, Barcelona, Beijing, Belgrade, Bengaluru, Berlin, Bilbao, Bologna, Boston, Brisbane, Brussels, Budapest, Buenos Aires, Cairns, Cairo, Calgary, Calicut, Canberra, Cancun, Cape Town, Cedar Rapids, Charlotte, Chennai, Chicago, Christchurch, Cincinnati, Cleveland, Cologne, Copenhagen, Dallas, Denver, Detroit, Doha, Dubai, Dublin, Durban, Dusseldorf, Edinburgh, Edmonton, El Paso, Fairbanks, Fort Lauderdale, Fort Myers, Frankfurt, Geneva, Genoa, Glasgow, Gold Coast, Gothenburg, Hagta, Halifax, Hamburg, Harrison, Helsinki, Ho Chi Minh City, Hong Kong, Honolulu, Houston, Hyderabad, Ibiza, Indianapolis, Istanbul, Johannesburg, Kahului, Kansas City, Kingston, Kolkata, Kuala Lumpur, Kuwait, Larnaca, Las Vegas, Lima, Liverpool, London, Long Beach, Los Angeles, Luqa, Luxembourg, Madrid, Manama, Manchester, Manila, Maroochydore, Melbourne, Memphis, Menorca, Mexico City, Miami, Milan, Milwaukee, Minneapolis, Mombasa, Montevideo, Montreal, Moscow, Mumbai, Munich, Nairobi, Nantes, Naples, Nashville, New Delhi, New Orleans, New York, Newark, Nice, Nottingham, Oaklahoma City, Oakland, Omaha, Ontario, Orlando, Osaka, Oslo, Ottawa, Palm Springs, Paris, Perth, Philadelphia, Phnom Penh, Phoenix, Pisa, Pittsburgh, Portland, Prague, Puerto Vallarta, Raleigh, Rio de Janeiro, Rochester, Rome, Salina, Salt Lake City, San Antonio, San Diego, San Francisco, San Jose, San Juan, Santa Ana, Santa Fe, Santiago, Sao Paulo, Seattle, Seoul, Shanghai, Shannon, Singapore, Sofia, St Louis, St. Johns, Stockholm, Stuttgart, Sydney, Tallahassee, Tampa, Tel Aviv, Tenerife, Tokyo, Toronto, Tucson, Tulsa, Turin, Vancouver, Venice, Verona, Vienna, Warsaw, Washington D.C., Wellington, West Palm Beach, White Plains, Winnipeg, Zagreb, Zurich]\n```\n\nAnd just to make sure we got fewer names back this time let's count them\nagain.\n\n``` java\ng.withSideEffect(\"x\", [] as Set).V().hasId(between(1,201)).\n  values('city').store('x').cap('x').unfold().count()\n\n186\n```\n\nAs I mentioned at the start of this section, you could achieve this\nresult other ways. For example, here is a version of the query that uses\n*dedup* instead of *store*.\n\n``` java\ng.V().hasId(between(1,201)).values('city').dedup().count()\n\n186\n```\n\nThis is clearly a simpler query in this case but you will find cases\nwhere the example that uses *withSideEffect* and *store* will come in\nvery handy, especially in cases where you want to store things into a\nSet or List from multiple parts of a traversal such as the one below\nthat finds and counts all the unique city names across multiple hops\nfrom a starting airport.\n\n``` java\ng.withSideEffect(\"x\", [] as Set).V().hasId(3).as('a').values('city').store('x').\n   select('a').out().as('b').values('city').store('x').\n   select('b').out().values('city').store('x').cap('x').unfold().count()\n\n804\n```\n\nLastly on this topic, let's look at one more interesting use case. It is\nquite common to want to get back from a query a collection of vertices\nand edges. This is often because we want to examine properties on both\nthe vertices and the edges. Imagine a small graph that has the following\nrelationships.\n\n(A→B), (A→C), (A→D), (C→D), (C→E), (D→F)\n\nThe code below can be used to create this graph using the Gremlin\nconsole and TinkerGraph.\n\n``` java\ngraph=TinkerGraph.open()\ng=graph.traversal()\n\ng.addV(\"A\").as(\"a\").\n  addV(\"B\").as(\"b\").\n  addV(\"C\").as(\"c\").\n  addV(\"D\").as(\"d\").\n  addV(\"E\").as(\"e\").\n  addV(\"F\").as(\"f\").\n  addE(\"knows\").from(\"a\").to(\"b\").\n  addE(\"knows\").from(\"a\").to(\"c\").\n  addE(\"knows\").from(\"a\").to(\"d\").\n  addE(\"knows\").from(\"c\").to(\"d\").\n  addE(\"knows\").from(\"c\").to(\"e\").\n  addE(\"knows\").from(\"d\").to(\"f\")\n```\n\nWe can see the IDs that were allocated for each vertex by looking at the\n*valueMap*.\n\n``` java\ng.V().valueMap(true)\n\n[id:0,label:A]\n[id:1,label:B]\n[id:2,label:C]\n[id:3,label:D]\n[id:4,label:E]\n[id:5,label:F]\n```\n\nLikewise we can look at the edges to see what IDs each edge was given.\n\n``` java\ng.E()\n\ne[6][0-knows->1]\ne[7][0-knows->2]\ne[8][0-knows->3]\ne[9][2-knows->3]\ne[10][2-knows->4]\ne[11][3-knows->5]\n```\n\nNow that we have our test graph created let's take a look at the query\nwe will need to develop. The problem we want to solve is to start from\nvertex A, find all of the edges that go out from vertex A and also all\nof the vertices at the other ends of those edges. Lastly we also want to\nfind any edges between the vertices that are also connected to A but\nignore edges that connect to vertices that are not also connected to A.\nIn simple terms we want a query that will return all of the\nrelationships except (C→E) and (D-F) as A is not connected to E or F.\n\nUsing the *withSideEffect* pattern that we used earlier in this section\nwe can again develop a query that will collect for us the vertices and\nedges that we are interested in. I added line numbers to make it easier\nto discuss what is going on but please, note that these are not part of\nthe query itself.\n\n``` java\n1: g.withSideEffect('x', [] as Set).\n2:     V(0L).store('x').\n3:     bothE().store('x').\n4:     otherV().store('x').\n5:     aggregate('tgtlist').\n6:     bothE().as('ref').otherV().where(within('tgtlist')).\n7:     select('ref').store('x').cap('x').unfold()\n```\n\nLet's look at the query above line by line.\n\n    1: Start the query and define 'x' as our, initially empty, Set.\n    2: Start at vertex 0 and 'store' it into our set 'x'.\n    3: Store all of the edges connected to 'V(0)' into our set.\n    4: Store the vertices connected to 'V(0)' into our set.\n    5: Aggregate all of these target vertices into 'tgtlist'.\n    6: Find more edges but only remember them if they connect to vertices also connected\n    to 'V(0)'.\n    7: Store the edges we found in 'x' and finally return the set as the overall result of the\n    query. The 'unfold' just makes the output a little easier to read.\n\nHere is the output we get from running the query. As you can see, the\nvertices and edges that we were not interested in have been correctly\nleft out of the result set.\n\n``` java\nv[0]\ne[5][0-knows->1]\nv[1]\ne[6][0-knows->2]\nv[2]\ne[7][0-knows->3]\nv[3]\ne[8][2-knows->3]\n```\n\nAs you start to work with graphs and start to do more complex querying,\nthis pattern of query based around *withSideEffect* is extremely useful\nto keep in mind.",
        "children": []
      },
      {
        "level": "5.7",
        "title": "5.7. Making a copy of the DFW vertex {#dfwcopy}",
        "content": "It is sometimes useful to be able to create a new vertex using the label\nand properties from one or more existing vertices. In this section I am\ngoing to present a small case study that shows how I investigated the\ncreation of a query that could create a copy of the Dallas Fort Worth\n(DFW) airport vertex.\n\nCreating a vertex using the label from another vertex is quite\nstraightforward. The two queries shown below use the label from the DFW\nAirport vertex as the label for a new vertex.\n\nMy first thought was to do this as follows.\n\n``` java\ng.addV().property(label,V().has('code','DFW').label())\n```\n\nThe query above does work but it felt a bit cumbersome and I also\nrealized I was going to need a way to refer to the DFW vertex more than\nonce so I changed the query as follows and ran it.\n\n``` java\ng.V().has('code','DFW').as('dfw').\n      addV().property(label, select('dfw').label())\n\nv[57525]\n```\n\nIf we examine the new vertex we can see that it does indeed have the\ncorrect label.\n\n``` java\ng.V(57525).valueMap(true)\n\n[label:airport,id:57525]\n```\n\nNow we need to expand the query to also copy the property key names and\ntheir values from the DFW vertex into our new vertex. Earlier in the\nbook we looked at ways that a *select* step combined with the *keys* and\n*values* keywords can be used to select values from a map. We can use\nthat same technique here.\n\nFirst of all let's remind ourselves about the properties of the DFW\nairport.\n\n``` java\ng.V().has('code','DFW').properties()\n\nvp[country->US]\nvp[code->DFW]\nvp[longest->13401]\nvp[city->Dallas]\nvp[elev->607]\nvp[icao->KDFW]\nvp[lon->-97.0380020141602]\nvp[type->airport]\nvp[region->US-TX]\nvp[runways->7]\nvp[lat->32.896800994873]\nvp[desc->Dallas/Fort Worth...]\n```\n\nLet's also count how many properties there are listed above.\n\n``` java\ng.V().has('code','DFW').properties().count()\n\n12\n```\n\nSo we need to add some steps to our query that will copy the twelve keys\nand values from these twelve properties belonging to the DFW vertex into\nour new one.\n\nBelow is the first query I tried when thinking about how to do this. The\ngoal of the query is to first capture the properties from the DFW\nairport and then to add them to the new vertex being created.\n\n``` java\ng.V().has('code','DFW').as('dfw').\n      addV().property(label, select('dfw').label()).as('new').\n             property(select('dfw').properties().key(),\n                      select('dfw').properties().value())\n```\n\nWhen I ran it I got this result which looked encouraging as a new vertex\nhad clearly been created.\n\n``` java\nv[53767]\n```\n\nHowever, when I inspected my new vertex I saw I had only managed to copy\none of the twelve properties over. So it was time to delete that vertex\nand have a bit of a rethink.\n\n``` java\ng.V(53767).valueMap(true).unfold()\n\ncountry=[US]\nlabel=airport\nid=53767\n\ng.V(53767).drop()\n```\n\nWhat I realized was that my first attempt at copying the properties was\nonly ever going to copy one property as that was essentially what I had\nasked it to do. If it's not quite clear why this is the case, hopefully\nit will become clearer once you look at the results from the profile\nstep that are shown later in this section. I realized that what I needed\nto do was to first get all of the DFW properties and then add them to\nthe new vertex. So I changed the query as shown below.\n\n``` java\ng.V().has('code','DFW').as('dfw').\n      addV().property(label, select('dfw').label()).as('new').\n      select('dfw').properties().as('dfwprops').\n      select('new').property(select('dfwprops').key(),\n                             select('dfwprops').value())\n```\n\nWhen run, this is what I saw in the Gremlin console. This is more output\nthan I wanted to get from the query but it has clearly done more work\nthis time. If you count the number of rows below you will find it also\nadds up to twelve. So this time I got one result per property it would\nappear.\n\n``` java\n[53768]\n[53768]\n[53768]\n[53768]\n[53768]\n[53768]\n[53768]\n[53768]\n[53768]\n[53768]\n[53768]\n[53768]\n```\n\nIn a moment I will explore a way to get rid of the unwanted output but\nfirst let's examine the contents of the new vertex.\n\n``` java\ng.V(53768).valueMap(true).unfold()\n\ncountry=[US]\ncode=[DFW]\nlongest=[13401]\ncity=[Dallas]\nlon=[-97.0380020141602]\ntype=[airport]\nelev=[607]\nlabel=airport\nicao=[KDFW]\nid=53768\nregion=[US-TX]\nrunways=[7]\nlat=[32.896800994873]\ndesc=[Dallas/Fort Worth International Airport]\n```\n\nSo a large part of my original goal has now been achieved. A vertex has\nbeen created that is a copy in all but ID value of the original DFW\nvertex. So, what can be done about the unwanted list of vertices that\ncame back as the results from the query?\n\nFirst of all, let's take a look at what the *profile* step can tell us\nabout this query. Note that I deleted the new vertex using a *drop* step\nbefore running this query so it did not pick up both the old and new DFW\nvertices.\n\n``` java\ng.V(53768).drop()\n\ng.V().has('code','DFW').as('dfw').\n      addV().property(label, select('dfw').label()).as('new').\n      select('dfw').properties().as('dfwprops').\n      select('new').property(select('dfwprops').key(),\n                             select('dfwprops').value()).profile()\n```\n\nIf you look at the results below you can see that for each property\nkey/value pair, a traverser was spawned. This explains why we got twelve\nresults back. This also explains why my first attempt at writing this\nquery failed. If you were to profile that query you would find that it\nonly spawns one traverser rather than the twelve that we need to be\nsuccessful.\n\n``` console\nTraversal Metrics      Step                      Count Traver-  Time   %Dur\n                                                       sers      (ms)\n===================================================================================\nTinkerGraphStep(vertex,[code.eq(DFW)])@[dfw]        1     1    1.416    28.85\nAddVertexStep({label=[[SelectOneStep(last,dfw),...  1     1    1.840    37.47\n  SelectOneStep(last,dfw)                           1     1    0.171\n  NoOpBarrierStep(2500)                             1     1    0.092\n  LabelStep                                         1     1    0.059\nSelectOneStep(last,dfw)                             1     1    0.132     2.70\nNoOpBarrierStep(2500)                               1     1    0.032     0.66\nPropertiesStep(property)@[dfwprops]                12    12    0.094     1.92\nSelectOneStep(last,new)                            12    12    0.127     2.60\nNoOpBarrierStep(2500)                              12    12    0.065     1.34\nAddPropertyStep({value=[[SelectOneStep(last,dfw... 12    12    1.200    24.45\n  SelectOneStep(last,dfwprops)                     12    12    0.168\n  NoOpBarrierStep(2500)                            12    12    0.064\n  PropertyKeyStep                                  12    12    0.066\n  SelectOneStep(last,dfwprops)                     12    12    0.134\n  NoOpBarrierStep(2500)                            12    12    0.070\n  PropertyValueStep                                12    12    0.043\n                                            >TOTAL  -     -    4.911\n```\n\nAs you will hopefully recall from our discussion of the *addV* and\n*property* steps earlier in Chapter 4, a *property* step returns the\nvertex that the property was added to and not the new property itself.\nThis allows multiple *addV* and *property* steps to be chained together.\n\nSo we need a way to still create our new properties but not have the\ntwelve traversers return any results to us. Hopefully your reaction to\nthis is something like \\\"This feels like a good place to introduce a\n*sideEffect* step into the query\\\". If that was your reaction you are\nright!\n\nBefore running the new query we need to clean up the work done by the\nprior one.\n\n``` java\ng.V().has('code','DFW')\n\n[8]\n[53767]\n\ng.V(53767).drop()\n```\n\nSo now let's wrap the creation of the properties into a *sideEffect*\nstep that should stop the unwanted results from being returned.The\nmodified version of the query is shown below.\n\n``` java\ng.V().has('code','DFW').as('dfw').\n      addV().property(label, select('dfw').label()).as('new').\n      sideEffect(select('dfw').properties().as('dfwprops').\n                 select('new').property(select('dfwprops').key(),\n                                        select('dfwprops').value()))\n```\n\nWhen we run the modified version of the query this is what we get back.\n\n``` java\n[53780]\n```\n\nThis is a lot better as we now just got back the new vertex one time as\nthe result. Let's double check that the query has worked as intended.\n\n``` java\ng.V(53780).valueMap(true).unfold()\n\ncountry=[US]\ncode=[DFW]\nlongest=[13401]\ncity=[Dallas]\nlon=[-97.0380020141602]\ntype=[airport]\nelev=[607]\nlabel=airport\nicao=[KDFW]\nid=53780\nregion=[US-TX]\nrunways=[7]\nlat=[32.896800994873]\ndesc=[Dallas/Fort Worth International Airport]\n```\n\nIn this small case study I have tried to show how I was able to evolve a\nquery in stages and also to adapt to unexpected outcomes along the way.\nYou could use essentially the same technique shown in this section to\nalso copy one or more edges if you needed to.",
        "children": []
      },
      {
        "level": "5.8",
        "title": "5.8. Modelling an ordered binary tree as a graph {#btree}",
        "content": "You can of course model a tree structure as a graph. The following code\nwill create a new graph containing an ordered binary tree. A graph like\nthis is sometimes referred to as a *connected acyclic* graph as there\nare no cycles in the graph. This means that once you leave a node there\nis no other path you could take that will allow you to get there again.\nBy contrast the air routes graph is an example of a *cyclic* graph as\nthere are clearly many ways to revisit vertices.\n\n``` java\n// Builds a small ordered Binary (BST) Tree\ngraph=TinkerGraph.open()\ng=graph.traversal()\ng.addV('root').property('data',9).as('root').\n  addV('node').property('data',5).as('b').\n  addV('node').property('data',2).as('c').\n  addV('node').property('data',11).as('d').\n  addV('node').property('data',15).as('e').\n  addV('node').property('data',10).as('f').\n  addV('node').property('data',1).as('g').\n  addV('node').property('data',8).as('h').\n  addV('node').property('data',22).as('i').\n  addV('node').property('data',16).as('j').\n  addE('left').from('root').to('b').\n  addE('left').from('b').to('c').\n  addE('right').from('root').to('d').\n  addE('right').from('d').to('e').\n  addE('right').from('e').to('i').\n  addE('left').from('i').to('j').\n  addE('left').from('d').to('f').\n  addE('right').from('b').to('h').\n  addE('left').from('c').to('g')\n```\n\nWe could of course use the *max* and the *min* steps to find the largest\nand smallest values in the graph. However, the queries below show how we\ncan do it using the semantics of an ordered binary tree.\n\n``` java\n// Find the largest value in the graph\ng.V().hasLabel('root').repeat(out('right')).\n                       until(out('right').count().is(0)).values('data')\n\n22\n\n// Find the smallest value in the graph\ng.V().hasLabel('root').repeat(out('left')).\n                       until(out('left').count().is(0)).values('data')\n\n1\n```\n\nAs a side note, here is a different way we could have written the query\nusing *not* instead of *count*. As *not* is a reserved word in Groovy,\nas we discussed in the \\\"[A warning about reserved word conflicts and\ncollisions](#rword)\\\" section, we have to prefix it with the *\\_\\_.*\nnotation.\n\n``` java\ng.V().hasLabel('root').repeat(out('left')).\n                       until(__.not(out('left'))).values('data')\n```\n\nIf we wanted to see the values that the *repeat* is encountering as it\ntraverses the tree we could add an *emit* step and get the values of\neach node the *repeat* visits. Note that this does not include the value\nfrom the root node.\n\n``` java\ng.V().hasLabel('root').repeat(out('left')).emit().values('data')\n\n5\n2\n1\n```\n\nPerhaps a nicer way to look at all the values we encountered as we\ntraversed the tree would be to use *path* as follows. Note that this\ndoes include the root node's value.\n\n``` java\ng.V().hasLabel('root').repeat(out('left')).\n                       until(__.not(out('left'))).path().by('data')\n\n[9,5,2,1]\n```\n\nWe can see all of the possible paths through the tree by running the\nfollowing query.\n\n``` java\ng.V().hasLabel('root').repeat(out()).times(4).emit().path().by('data')\n\n[9,5]\n[9,11]\n[9,5,2]\n[9,5,8]\n[9,11,10]\n[9,11,15]\n[9,5,2,1]\n[9,11,15,22]\n[9,11,15,22,16]\n```\n\nWe briefly explored the TinkerPop Tree API in the \\\"[Turning graphs into\ntrees](#tre)\\\" section. We could use what we discussed there to create a\nTree object from our Binary Tree graph as follows.\n\n``` java\nt=g.V().hasLabel('root').repeat(out()).emit().tree().by('data').next()\n```\n\nJust to be sure we can query what kind of object we just created.\n\n``` java\nt.getClass()\n\nclass org.apache.tinkerpop.gremlin.process.traversal.step.util.Tree\n```\n\nIf we print the tree we can see how it has been created from our\noriginal graph. If you study the nesting closely you will see that it\ndoes indeed represent the original binary tree data that we used to\ncreate the graph.\n\n``` java\nprintln t\n\n[9:[5:[2:[1:[:]], 8:[:]], 11:[10:[:], 15:[22:[16:[:]]]]]]\n```\n\nWe can use the *getObjectsAtDepth* method to further investigate the\ntree structure.\n\n``` java\nt.getObjectsAtDepth(1)\n\n9\n\nt.getObjectsAtDepth(2)\n\n5\n11\n\nt.getObjectsAtDepth(3)\n\n2\n8\n10\n15\n\nt.getObjectsAtDepth(4)\n\n1\n22\n\nt.getObjectsAtDepth(5)\n\n16\n```",
        "children": []
      },
      {
        "level": "5.9",
        "title": "5.9. Using *map* to produce a concatenated result string {#mapstr}",
        "content": "In the example below we use *map* to build a string containing the\nairport code concatenated with the city the airport is in for airports\nin England.\n\n``` java\ng.V().has('airport','region','GB-ENG').limit(10).\n  map{it.get().value('code')+\" \"+it.get().value('city')}\n```\n\nHere are the results of running the query.\n\n``` java\nLHR London\nLGW London\nMAN Manchester\nLCY London\nSTN London\nEMA Nottingham\nLPL Liverpool\nLTN London\nSOU Southampton\nLBA Leeds\n```",
        "children": []
      },
      {
        "level": "5.10",
        "title": "5.10. Randomly walking a graph {#randwalk}",
        "content": "When doing analysis of a graph sometimes you just want to randomly\ntraverse or *walk* parts of the graph. The example below shows a query\nthat starts at the Austin (AUS) vertex and then randomly goes to five\nconnected vertices from there. The *random walk* is achieved by picking\na sample of one of the possible edges connected to the vertex we are\ncurrently at by sampling using the distance property of the edge and\nthen moving to the vertex at the other end of that edge.\n\n``` java\n// Random walk with five hops\ng.V().has('code','AUS').\n      repeat(bothE('route').\n         sample(1).by('dist').otherV()).\n      times(5).\n      path().by('code').by('dist')\n```\n\nBelow are the results of running the query five times. You can see each\ngraph walk starts at AUS and then goes to five places from there. The\npath shown displays the names of the other airports and the distances\nbetween them.\n\n``` java\n[AUS,992,SFB,828,MDT,592,ORD,234,DTW,500,LGA]\n\n[AUS,957,CVG,374,ATL,1890,SAN,2276,DCA,204,PIT]\n\n[AUS,1209,PIT,1399,CUN,941,BJX,729,IAH,1384,BZN]\n\n[AUS,748,MEX,1252,PHX,5255,LHR,2487,LXR,492,JED]\n\n[AUS,722,STL,717,DCA,893,RSW,1103,HPN,563,CLT]\n```\n\nIn the previous example, every random walk began at the same place.\nHowever, if we wanted a more random walk that starts from a different\nairport each time we could instead use a *sample* step to at the start\nof the query to pick a random airport to start from out of the set of\nall vertices with an *airport* label.\n\n``` java\n// Random walk with five hops\ng.V().hasLabel('airport').sample(1).\n      repeat(bothE('route').\n        sample(1).by('dist').otherV()).\n      times(5).\n      path().by('code').by('dist')\n```\n\nWhen run five times , as shown below, each walk begins at a different\nairport.\n\n``` java\n[OMA,1144,LGA,584,CVG,750,BOS,6682,NRT,5951,VCE]\n\n[CLE,244,ROC,263,JFK,8054,HKG,7952,BOS,7288,PVG]\n\n[EMA,1126,AGP,969,PMO,708,VIE,5684,NRT,5152,DOH]\n\n[SNN,387,LGW,1349,KBP,264,KHE,434,IST,2831,DEL]\n\n[ARN,1814,LEI,1232,PRG,433,BRU,1384,SVO,3598,PEK]\n```\n\nAnother way to write the query involves the introduction of a *local*\nstep. In this case the *repeat* step is applied against the current\nlocal state of the traversal. In this way we can achieve multiple random\nwalks. The *limit(5)* at the end of the query limits the number of\nrandom walks returned to just five. Note that if the *local* step was\nremoved only one walk would occur.\n\n``` java\n// Five random walks each of five hops\ng.V().hasLabel('airport').\n      repeat(local(bothE('route').\n        sample(1).by('dist').otherV())).\n      times(5).\n      path().by('code').by('dist').limit(5)\n```\n\nWhen run, five results such as those shown below are returned.\n\n``` java\n[ATL,1301,ASE,845,SFO,2580,MIA,596,ATL,546,PBI]\n[ANC,2547,PHX,1999,BWI,368,BOS,3576,CGN,4745,MIA]\n[AUS,922,CUN,931,SAT,248,DAL,1378,LGA,736,MKE]\n[BNA,630,DFW,1430,SJC,2110,ATL,2180,SEA,4868,AMS]\n[BOS,3838,MUC,4024,JFK,8054,HKG,858,YNZ,901,HRB]\n```",
        "children": []
      },
      {
        "level": "5.11",
        "title": "5.11. Seven degrees of separation! {#sevendegrees}",
        "content": "No, the word seven in the heading above is not a mistake, read on! Most\npeople I am sure have heard of the famous \\\"Six degrees of separation\\\"\ntheory. The theory essentially states that for any living person, using\n\\\"friend of a friend\\\" style connections, none of us is farther removed\nthan six friendship relationships from anyone else.\n\n::: note\nYou can read more about the Six degrees of separation theory on\nWikipedia at this location\n<https://en.wikipedia.org/wiki/Six_degrees_of_separation>.\n:::\n\nI decided it would be fun to run an experiment using the `air-routes`\ndata set to see how far any airport, that is not a known orphan vertex,\nis from a major hub airport. For this experiment I decided to use London\nHeathrow (LHR) airport as my target.\n\nI came up with the queries below in order to do this. The first thing I\nwanted to do was establish how many connections I would be looking for.\n\nFirst of all I double checked how many airports are in the graph.\n\n``` java\ng.V().hasLabel('airport').count()\n\n3374\n```\n\nNext I remembered there are some orphan airports that have no routes so\nwe have to rule those out. We can do this using a technique similar to\nthe one that was discussed in the \\\"[Which airports have no\nroutes?](#noroutes) section.\n\n``` java\ng.V().hasLabel('airport').not(outE('route')).count()\n\n16\n```\n\nSo we know that there are 16 airports we need to ignore for this\nexperiment. Leaving us with 3358 airports we care about but one of those\nwill be LHR so we also need to discount that one as we are not looking\nfor cyclic paths. So, we need a query that proves there is a route\nbetween all of these 3357 remaining airports and London Heathrow but\nignores the orphan airports and Heathrow itself as starting points.\n\nThe core part of the query is shown below. I started out using just one\nhop for testing purposes. The query starts by ignoring LHR and the\norphan nodes. It next uses a *union* step within *local* scope to try\nand find a single path in one hop between the starting airport and LHR.\nThe result, for each starting airport will either be a path containing\nthe codes of all the airports from the starting airport to LHR or if LHR\nwas not reached the path will just contain the starting airport. Just to\ntest this part of the query I used a hop count of 1 and limited the\nresults to just 10.\n\n``` java\ng.V().has('airport','code',neq('LHR')).\n       filter(out('route').count().is(neq(0))).\n       local(union(\n              identity().values('code'),\n              local(repeat(out().simplePath()).\n                      emit().times(1).\n                      has('code','LHR').\n                      limit(1)).\n              path().by('code')).\n              fold()).\n        limit(10)\n```\n\nAs you can see, the query we have so far seems to be working. We either\nget back a starting airport and a path or just a starting airport if no\nroute was found. This is why I used the *union* step to guarantee that\nat a minimum the starting airport is returned. The *local* scope is used\nas I wanted the results for each starting airport to be in a separate\nlist.\n\n``` java\n[ATL,[ATL,LHR]]\n[ANC]\n[AUS,[AUS,LHR]]\n[BNA]\n[BOS,[BOS,LHR]]\n[BWI,[BWI,LHR]]\n[DCA]\n[DFW,[DFW,LHR]]\n[FLL]\n[IAD,[IAD,LHR]]\n```\n\nThe final piece missing from the query is a way to decide if we reached\nLHR and count the number of times we succeeded in doing so. This is done\nby checking to see that the length of the result returned has more than\none item in it. In other words, did we get back more than just the\nstarting airport code. To do this, the *where* step filters out the\npaths that did not reach LHR in the specified number of steps. Finally,\nrather than displaying the paths as I did in my testing, we now count\nhow many of the starting airports were able to get to LHR. For my first\nround of tests I decided to see how many of the airports can reach LHR\nin five hops.\n\n``` java\ng.V().has('airport','code',neq('LHR')).\n      filter(out('route').count().is(neq(0))).\n      local(union(\n             identity().values('code'),\n             local(repeat(out().simplePath()).\n                     emit().times(5).\n                     has('code','LHR').\n                     limit(1)).\n             path().by('code')).\n             fold().\n             where(count(local).is(gt(1)))).\n      count()\n\n3345\n```\n\nAs you can see, with five hops were were able to reach LHR from 3345 of\nthe 3357 airports we are testing. Next I ran the query again but using\nsix hops.\n\n``` java\ng.V().has('airport','code',neq('LHR')).\n      filter(out('route').count().is(neq(0))).\n      local(union(\n             identity().values('code'),\n             local(repeat(out().simplePath()).\n                     emit().times(6).\n                     has('code','LHR').\n                     limit(1)).\n             path().by('code')).\n             fold().\n             where(count(local).is(gt(1)))).\n      count()\n\n3354\n```\n\nSo with six hops 3354 of our 3357 airports were able to get to LHR. I\nthen tried seven hops and found that all but two of the airports were\nable to reach LHR\n\n``` java\ng.V().has('airport','code',neq('LHR')).\n      filter(out('route').count().is(neq(0))).\n      local(union(\n             identity().values('code'),\n             local(repeat(out().simplePath()).\n                     emit().times(7).\n                     has('code','LHR').\n                     limit(1)).\n             path().by('code')).\n             fold().\n             where(count(local).is(gt(1)))).\n      count()\n\n3355\n```\n\nThis made me curious. I was fairly convinced that there are no airports\nin the graph that would not be able to reach LHR in seven hops unless of\ncourse they were orphans but we have already ruled those out as part of\nour query. So, I decided to go with 30 hops just to make sure. However I\nstill got the answer 3355.\n\n``` java\ng.V().has('airport','code',neq('LHR')).\n      filter(out('route').count().is(neq(0))).\n      local(union(\n             identity().values('code'),\n             local(repeat(out().simplePath()).\n                     emit().times(30).\n                     has('code','LHR').\n                     limit(1)).\n             path().by('code')).\n             fold().\n             where(count(local).is(gt(1)))).\n      count()\n\n3355\n```\n\nThis left me with an interesting conclusion. There must be two airports\nin the graph that are not orphans, in other words they have some routes,\nbut they are isolated from the main network. So I needed a query to find\nthem which is the subject of the next section. What the queries in this\nsection did prove is that from any airport in the graph, with the\nexception of the two cases we need to investigate further, London LHR\ncan be reached in seven hops or less. Hence the title of this section\nbeing \\\"Seven degrees of separation\\\" rather than \\\"Six\\\" !",
        "children": [
          {
            "level": "5.11.1",
            "title": "5.11.1. Finding isolated sub-networks {#mininetworks}",
            "content": "As discussed above, while I was working on the queries for the previous\nsection I realized that there are two airports in the graph that are not\ntrue orphans, as they do have routes between each other but that they\nare part of a small network that is not itself connected to the main\nroute network. In other words, the network is an isolated mini network\nwithin the main graph and you can never get to London from either one of\nthem. After more analysis I realized that this was actually due to an\nerror in my data set which I have fixed in subsequent updates but if you\nare using the version 0.77 level of `air-routes` then the following\nquery will yield the results shown.\n\nTo solve the puzzle of the missing airports, I only had to slightly\nmodify the seven degrees of separation query. Note that if you use the\nmost recent version of the `air-routes` data set, this particular error\nis fixed, but you will find other isolated networks within the main\ngraph exist. However, these are not due to errors but rather because\nthere truly are a set of airports in Portugal connected to each other\nvia commuter airlines but with no way to get from any one of them to the\nmain, worldwide route network.\n\nSo, here is the modified form of the query.\n\n``` java\ng.V().has('airport','code',neq('LHR')).\n      filter(out('route').count().is(neq(0))).\n      local(union(\n             identity().values('code'),\n             local(repeat(out().simplePath()).\n                     emit().times(7).\n                     has('code','LHR').\n                     limit(1)).\n             path().by('code')).\n             fold().\n             where(count(local).is(1))).\n       unfold()\n```\n\nThe only change made to this query from the one used in the prior\nsection is that the *where* step has been changed to\n*where(count(local).is(1)))* so that it now looks for paths of length\none. These represent the airports for which no route to LHR was found.\nThen rather than *count* the paths an *unfold* is used to return the\ncodes for the airports that had no route.\n\nWhen the query is run, the codes for the airports with no route to\nLondon are revealed. These airports are truly connected to each other\nbut isolated from the main route network.\n\n``` java\nHPB\nVAK\n```\n\nJust to verify my findings I ran a couple of queries to double check on\nthe routes from each of these airports. As you can see they were just\nconnected to each other.\n\n``` java\ng.V().has('code','HPB').out().path().by('code')\n[HPB,VAK]\n\ng.V().has('code','VAK').out().path().by('code')\n[VAK,HPB]\n```\n\nThis proved both an interesting and useful exercise and uncovered some\nerrors in the graph that had slipped through my error checking!",
            "children": []
          }
        ]
      },
      {
        "level": "5.12",
        "title": "5.12. Looking for the journey requiring the most stops {#longestroutes}",
        "content": "Sometimes it is interesting to ponder questions such as \\\"Starting from\na given airport what are the most difficult places to get to?\\\". For the\nsake of this example let's define \\\"difficult to get to\\\" as meaning\n\\\"requires the most hops\\\". By modifying the query from the previous\nsection we can come up with a way to detect some longest routes. At the\nend of the section I have also included examples that show alternative\nways to generate the same result.\n\nThe query shown below finds every airport that has out going routes and\nis not Austin (AUS). For each airport found an attempt is made to get to\nAustin in ten or fewer hops. For each airport the attempt is only made\nonce. I decided to use a value of 10 as I was already fairly confident\nthat there would be no airports further away in terms of stops than\nthat. However, it really does not matter what value is used so long as\nit is big enough. A value of 100 does not adversely affect the query\ngiven that the *emit* step will return a result as soon as AUS is\nreached. The query will find a single path between each starting airport\nand AUS. The *where* step on the last line of the query only keeps any\npaths that have a length of eight or more. So essentially that says find\nme only routes that take at least seven hops to get to Austin as AUS.\n\n``` java\ng.V().has('airport','code',neq('AUS')).\n      filter(out('route').count().is(neq(0))).\n      local(repeat(out().simplePath()).\n              emit(has('code','AUS')).\n              times(10).limit(1)).\n      path().by('code').\n      where(count(local).is(gte(8)))\n```\n\nWhen run, the query may take a few seconds to complete, but should not\ntake more than that on a typical laptop or desktop. Here are the results\nof running the query.\n\n``` java\n[YPO,YAT,ZKE,YFA,YMO,YTS,YYZ,AUS]\n[YZG,YIK,AKV,YPX,YGL,YUL,ATL,AUS]\n[THU,NAQ,JUV,JAV,GOH,KEF,PIT,AUS]\n```\n\nThe query could also be written using *repeat* and *until* steps as\nshown below.\n\n``` java\ng.V().has('airport','code',neq('AUS')).\n      filter(out('route').count().is(neq(0))).\n      local(repeat(out().simplePath()).\n        until(has('code','AUS').or().loops().is(8)).\n        has('code','AUS').limit(1)).\n      path().by('code').\n      where(count(local).is(gte(8)))\n```\n\nAs before, the same three paths are found.\n\n``` java\n[YPO,YAT,ZKE,YFA,YMO,YTS,YYZ,AUS]\n[YZG,YIK,AKV,YPX,YGL,YUL,ATL,AUS]\n[THU,NAQ,JUV,JAV,GOH,KEF,PIT,AUS]\n```",
        "children": [
          {
            "level": "5.12.1",
            "title": "5.12.1. Quickly finding the hardest to get to airports {#quicklyfindhardest}",
            "content": "There are other ways we could write a query that looks for \\\"hard to get\nto\\\" airports. The technique shown below essentially relies on using a\nde-duplication strategy to make sure you only visit an airport exactly\nonce. Note this is different from the way the *sideEffect* step works.\nThat step allows a query to fan out and visit the same vertex from many\nplaces, a many to one type of pattern, but will not allow a traversal to\nloop back on itself. By using a de-duplication approach we only visit a\nvertex exactly once and remove all other instances of it as the query\nprogresses. This gives the query processor a lot less work to do and as\na result the query executes more efficiently. The queries below do a bit\nless filtering than the ones above but work well if all you are looking\nfor are destinations that, from a given starting point, require at least\na specified number of hops to reach.\n\nThis time I decided to start with Austin (AUS) and look for any airports\nthat are only reachable in seven hops. The fact that we are removing\nduplicates along the way guarantees that there is not a shorter path to\nthe destinations found. If you are good at reading backwards, you will\nsee that the results match those found above but in the reverse order.\n\nThe first example keeps track of where it has been using a *store* step\nand only continues on to places it has not seen before until seven hops\nhave completed.\n\n``` java\ng.V().has('code','AUS').\n      repeat(out().where(without('a')).store('a')).\n        times(7).\n      path().\n        by('code')\n```\n\nAs you can see the results look familiar.\n\n``` java\n[AUS,YYZ,YUL,YGL,YPX,AKV,YIK,YZG]\n[AUS,YYZ,CPH,SFJ,JAV,JUV,NAQ,THU]\n[AUS,YYZ,YTS,YMO,YFA,ZKE,YAT,YPO]\n```\n\nThis alternate version of the query uses a *dedup* step to achieve the\nsame goal. On most Gremlin query engines this is an efficient way to\nlook for targets only reachable in at least the given number of hops.\nThis query is similar to the one used in the \\\"[Does any route exist\nbetween two airports?](#doesanyrouteexist)\\\" section.\n\n``` java\ng.V().has('code','AUS').\n      repeat(out().dedup()).\n        times(7).\n      path().\n        by('code')\n```\n\nOnce again the same results are generated.\n\n``` java\n[AUS,YYZ,YUL,YGL,YPX,AKV,YIK,YZG]\n[AUS,YYZ,CPH,SFJ,JAV,JUV,NAQ,THU]\n[AUS,YYZ,YTS,YMO,YFA,ZKE,YAT,YPO]\n```\n\nWhen looking for longest routes in a graph, especially in a highly\nconnected one, you need to be careful. Notice how I chose a very\nspecific target or a specific number of hops for my searches.\n\n::: note\nLooking for longest paths must be done carefully as it can result in\nvery long running queries.\n:::\n\nIf you were to try and write a query that arbitrarily looked for the\nlongest route between any two airports you run the risk of writing a\nquery that runs for an extremely long time. In many ways the concept of\n\\\"longest path\\\" can be viewed as an anti pattern. This is especially\ntrue in highly connected graphs of which `air-routes` is an example.",
            "children": []
          }
        ]
      },
      {
        "level": "5.13",
        "title": "5.13. Finding unwanted parallel edges {#unwantededges}",
        "content": "In general terms there are many reasons in a graph that there could be\nmore than one edge between the same two vertices in the same direction.\nMost property graph systems allow this and many data models take\nadvantage of this capability. We call these parallel edges. However, in\nthe *air-routes* graph we only model the existence of a route using a\nsingle edge from airport A to airport B. It is considered an error for\nthere to be more than one edge between the same two airports in the same\ndirection. Note this does not include an edge going the other way (from\nB to A).\n\nDuring development of the *air-routes* graph, when I was still cleaning\nup the data, I frequently ran into problems with parallel edges getting\nincluded in the graph by mistake. I realized I could use Gremlin to help\nme detect these error cases.\n\nInitially I tried something very basic, that still required quite a bit\nof manual reading of the output. I used the following query to tell me\nif for a given airport there was more than one outgoing edge to any\nother airport. This required me to have a hunch ahead of time which\nairport vertices might have an issue. Far from ideal when there are over\n3,300 airport vertices in the graph.\n\n``` java\ng.V().has('code','LHR').out().groupCount().by('code').\n  order(local).by(values,desc).next().values().max()\n```\n\nIf the answer came back greater than one I then ran the following query\nand manually looked at each result to see where the duplicate edge was.\n\n``` java\ng.V().has('code','LHR').out().groupCount().by('code').order(local).by(values,desc)\n```\n\nAs I said this was a very manual and time consuming process. I clearly\nneeded a better query. Given what we know about *groupCount* I realized\nI could write an arbitrary query to tell me how many times every single\nroute in the graph exists. However, given there are over 43,000 routes I\nwas not going to be able to check that manually. So as is often the best\nway with Gremlin I built up my query in stages. First of all I wrote the\nquery to count the occurrence of all routes. I have not shown all the\noutput from this query as it would take tens of pages but as you can see\nfrom what we have shown, this result would still need a person studying\nall of the results. Far from ideal!\n\n``` java\ng.V().as(\"a\").out().as(\"b\").groupCount().by(select(\"a\",\"b\"))\n\n[[a:v[1],b:v[3]]:1,[a:v[1],b:v[6]]:1,[a:v[1],b:v[7]]:1 ...\n```\n\nI then added a filter to only select any routes that occurred more than\nonce. Note that I had to use *unfold* before I applied the *filter* to\nturn the map back into a stream of values that could be filtered.\n\n``` java\ng.V().as(\"a\").out().as(\"b\").groupCount().by(select(\"a\",\"b\")).unfold().\n                            filter(select(values).is(gt(1)))\n```\n\nNext I added one more step to tell me which routes contained the error.\n\n``` java\ng.V().as(\"a\").out().as(\"b\").groupCount().by(select(\"a\",\"b\")).unfold().\n                            filter(select(values).is(gt(1))).select(keys)\n```\n\nOne of the errors I ran into was that I had erroneously added the LHR to\nJFK route twice into the graph. LHR has the ID of 49 and JFK has the ID\nof 12. When I ran the above query I got the following output which told\nme exactly which route I needed to correct. This is clearly a much more\nuseful query than the prior ones. I could happily have stopped at this\npoint but I wanted to see if I could improve the query some more.\n\n``` java\n[a:v[49],b:v[12]]\n```\n\nI was still not totally happy with my query as I really wanted it to\ngive me back the airport codes. So I added a few more tweaks to do the\n*groupCount* using the airport codes. I have also left the\n*select(keys)* off the end of this query as I think it aids\nunderstanding to see what is returned before that step is performed.\n\n``` java\ng.V().as(\"a\").out().as(\"b\").select('a','b').by('code').groupCount().unfold()\n                           .filter(select(values).is(gt(1)))\n```\n\nSo what we get back when we run that query is the airport codes as well\nof the number of times they have appeared connected to each other by a\nparallel edge. This is actually a key/value pair where the contents of\nthe *{}* are the keys and the *=2* part is the value. You could\nreasonably argue that this is sufficient for me to go and fix the\nmistake in the graph. However I want to add just a couple of additional\nsteps to demonstrate other possible refinements that you may find useful\nin other circumstances.\n\n``` java\n{a=LHR, b=JFK}=2\n```\n\nIf we don't want the *=2* part returned we can just select the keys\npart.\n\n``` java\ng.V().as(\"a\").out().as(\"b\").select('a','b').by('code').groupCount().unfold()\n                           .filter(select(values).is(gt(1))).select(keys)\n```\n\nThis is what was now returned. Note that the keys themselves are\nreturned in a map using the *a* and *b* terms from our *as* step.\n\n``` java\n[a:LHR,b:JFK]\n```\n\nThis is almost exactly what I wanted but we can add one more tiny step\nto clean up the output by just selecting the values from the map\nreturned.\n\n``` java\ng.V().as(\"a\").out().as(\"b\").select('a','b').by('code').groupCount().unfold()\n                           .filter(select(values).is(gt(1))).select(keys).select(values)\n```\n\nSo here is the final output, just the codes for the airports with\nparallel edges that needed fixing.\n\n``` java\n[LHR,JFK]\n```\n\n::: tip\nNote how I built up my Gremlin query in stages to solve this problem. I\nrecommend this as a sensible way to approach all but the most basic of\nqueries that you may need to write. Doing it this way has the advantage\nthat you can also check that each part of the query is working the way\nyou intend it to before you add more parts to it.\n:::",
        "children": [
          {
            "level": "5.13.1",
            "title": "5.13.1. Using *groupCount* with *path* to find duplicate edges {#groupcountpath}",
            "content": "The prior example found duplicate edges by working with a map created\nusing *select* and *groupCount* steps. It is also possible to use a\n*path* step inside a *groupCount* step to achieve a similar result.\n\nFirst of all let's create a duplicate edge between Austin (AUS) and\nCancun (CUN).\n\n``` java\ng.V().has('code','AUS').addE('route').to(V().has('code','CUN'))\n\ne[53791][3-route->180]\n```\n\nWe can now use a *groupCount* step containing a *path* step to look for\nduplicate edges originating in Austin. I used a *limit* step just to\nreduce the amount of output a bit.\n\n``` java\ng.V().has('code','AUS').out().\n      groupCount().by(path().by('code')).limit(local,5)\n```\n\nAs you can see from the results below the route between AUS and CUN has\na count of 2 associated with it.\n\n``` java\n[[AUS,CUN]:2,[AUS,MDW]:1,[AUS,MIA]:1,[AUS,DFW]:1,[AUS,BWI]:1]\n```\n\nNote that this technique does not replace the full query shown in the\nprior section. It is more intended to show that you can place a *path*\nstep inside of a *groupCount* step and achieve some useful results.",
            "children": []
          }
        ]
      },
      {
        "level": "5.14",
        "title": "5.14. Finding the longest flight route between two adjacent airports in the graph {#flr}",
        "content": "This section is in a way a case study in the good and the bad of the\nGremlin query language. I have documented here the learning steps I went\nthrough to get what I thought was a very simple question expressed as a\nsingle Gremlin query. This documents well the Good,the bad and the\nsometimes ugly aspects of working with Gremlin. On the good side it is\npowerful and some things that should be easy are easy. On the bad side,\nsome things that appear easy are in fact very hard to get right\nespecially if you want to build a single query to do a job rather than\nbreak it up into a set of smaller programmatic steps. Let's look at an\nexample of this with a real-world query.\n\nThe query we want to build is to find the route(s) in the graph that are\nof the maximum length between any two airports. It turns out that this\nsimple looking query takes a lot of work to get right if you want to\nhandle the case where there could be more than one route that is of the\nmaximum length (return flights between the same two airports don't count\nas different routes for this example).\n\nWhile using a *max* step, as shown below, might seem like the obvious\nand easy to do what we need, because of the way that *max* is\nimplemented it will not work. Currently the *max* and *min* steps cause\nthe prior paths that have been taken in a traversal to be lost. There is\nan issue open against TinkerPop for this but until that issue gets\nresolved, we need to explore other ways of achieving our desired result.\n\n``` java\ng.E().hasLabel('route').as('e').values('dist').max().select('e')\n```\n\nFirst of all we could do this (below) The down side of this approach is\nthat both queries have to look at a lot of edges which is likely to use\nadditional memory and CPU to process.\n\n``` java\nr=g.E().hasLabel('route').values('dist').max().next()\ng.E().has('dist',r).bothV().values('code')\n```\n\nThis next query is more efficient as using an ID means the edges are\nonly searched once, but this approach would miss the case where more\nthan one route was of the same (max) length so it does not meet our\nrequired success criteria.\n\n``` java\nr=g.E().hasLabel('route').as('e').order().by('dist', desc).limit(1).select('e').id().next()\ng.E(r).dist\ng.E(r).bothV().values('code')\n```\n\nThis query is what Daniel Kuppitz from the TinkerPop team recommended\nafter we discussed this on the mailing list and it does indeed work but\nfrom where we started our experiments to build up this query from there\nis a non trivial journey!\n\n``` java\ng.E().hasLabel(\"route\").order().by(\"dist\", desc).store(\"d\").by(\"dist\").\n  filter(values(\"dist\").as(\"cd\").select(\"d\").by(limit(local, 1)).as(\"md\").where(\"cd\",eq(\"md\"))).\n  project(\"from\",\"to\",\"dist\").by(outV()).by(inV()).by(\"dist\")\n```\n\nFinally, to output airport codes rather than just vertices, we can tweak\nthe query one more time as follows.\n\n``` java\ng.E().hasLabel(\"route\").order().by(\"dist\",desc).store(\"d\").by(\"dist\").\\\n  filter(values(\"dist\").as(\"cd\").select(\"d\").by(limit(local, 1)).as(\"md\").where(\"cd\",eq(\"md\"))).\\\n  project(\"from\",\"to\",\"dist\").by(outV().values('code')).by(inV().values('code')).by(\"dist\")\n```\n\nNow we are ready to run our query. This is the output from it. Notice\nhow both routes are between the same city pairs. We could have further\nrefined our query to only show such combinations once but I will leave\nthat as an exercise for the reader!\n\n``` java\n[from:DXB,to:AKL,dist:8818]\n[from:AKL,to:DXB,dist:8818]\n```",
        "children": []
      },
      {
        "level": "5.15",
        "title": "5.15. Miscellaneous other queries {#miscq}",
        "content": "The examples in this section demonstrate a few miscellaneous features\nand queries that we have not yet had a chance to examine. Over time,\nthese queries should probably be moved to other sections of the book.",
        "children": [
          {
            "level": "5.15.1",
            "title": "5.15.1. Using a calculation inside of an *is* step {#_using_a_calculation_inside_of_an_is_step}",
            "content": "It is possible to use a mathematical expression inside of an *is* step.\nAt times this comes in quite handy. The example below simply divides 500\nby 2 as part of a test. Clearly you would normally just enter 250 but\nthis shows the capability.\n\n``` java\ng.V().hasLabel('airport').where(out().count().is(gt(500/2))).values('code')\n\nCDG\nFRA\nAMS\nIST\n```\n\nThe capability becomes more interesting when used in conjunction with a\nvariable.\n\n``` java\na = 500\n\ng.V().hasLabel('airport').where(out().count().is(gt(a/2))).values('code')\n\nCDG\nFRA\nAMS\nIST\n```\n\nHere is one more example where we start by setting the variable *a* to\nthe value that represents the maximum number of routes from any single\nairport. The we use a query to find all the airports that have at least\nas many outgoing routes as 50 fewer than our value *a*.\n\n``` java\na = g.V().local(out('route').count()).max().next()\n\ng.V().hasLabel('airport').where(out().count().is(gt(a-50))).\n      project('apt','routes').by('code').by(out().count())\n\n[apt:ATL,routes:232]\n[apt:ORD,routes:232]\n[apt:CDG,routes:262]\n[apt:FRA,routes:272]\n[apt:DXB,routes:230]\n[apt:PEK,routes:234]\n[apt:AMS,routes:269]\n[apt:MUC,routes:237]\n[apt:IST,routes:270]\n```",
            "children": []
          }
        ]
      }
    ]
  },
  {
    "level": "6",
    "title": "6. MOVING BEYOND THE CONSOLE AND TINKERGRAPH {#beyond}",
    "content": "Most of the examples we have looked at so far were produced using the\nGremlin console and the TinkerGraph in-memory graph all running on a\nsingle machine. However, there are many ways to deploy and interact with\na graph while still using Gremlin and optionally the Gremlin Console,\nand many of them go beyond doing everything on a single machine. The\nApache TinkerPop package for example includes a component called Gremlin\nServer. Gremlin Server allows you to host a graph database locally or\nremotely and talk to it over HTTP or WebSockets. The Gremlin console\nsupports accessing graphs both locally or remotely or you can access\nthem using your own code or other tools or even command line utilities\nsuch as *curl*.\n\nFor a production environment it is likely you will use a technology such\nas JanusGraph backed by something like HBase or Cassandra and an\nindexing technology such as Solr or Elasticsearch. In these cases the\nway you work with and manage the graph and the way that query results\nare returned will vary.\n\nIn some cases data returned will be in the form of a GraphSON (JSON) in\nothers it might be as variables within a program. There are also ways to\nwork with graphs using Gremlin from a Python Notebook. You might setup\nyour own on-premise graph system or you might use a hosted service. It's\nquite possible you might still wish to connect to a remote graph using\nGremlin Server via the Gremlin Console but you just as likely could use\n*curl* or some other HTTP/REST type of technology. So that is a long\nwinded way of saying that once you move beyond the basics and head\ntowards putting a system into production, there are a lot of options to\nconsider.\n\nIn this section you will find a selection of examples from these more\nsophisticated environments. The focus of this book so far has been to\nteach the Gremlin query and traversal language, using the Gremlin\nConsole and TinkerGraph as our learning environment. However, it would\nbe remiss to end our discussion without at least touching on some of\nthese other environments, how you might configure them and why you might\nuse them. The following sections are an attempt to whet your appetite\nfor moving beyond the Gremlin Console into the world of graph\napplication programming and graph system deployment!",
    "children": [
      {
        "level": "6.1",
        "title": "6.1. Working with TinkerGraph from a Java Application {#javatinker}",
        "content": "So far in this book we have looked at many ways of working with a\nTinkerGraph from within the Gremlin Console. As you start to create more\nsophisticated applications you will find that the Gremlin Console is\njust one of the tools you will need to have available in your toolbox.\nIt is very likely, if not certain, that you will want to write\nstandalone applications that can work with a graph. There are a number\nof different language bindings currently available for TinkerPop 3. One\nof the most widely used is the Java API. Apache TinkerPop itself is\ncoded in Java.\n\n::: note\nYou will find several Java samples at the GitHub repository associated\nwith this book. <https://github.com/krlawrence/graph>\n:::\n\nAs briefly discussed already, when building a commercial application,\nyou may need capabilities such as ACID transactions and would not use\nTinkerGraph as your graph database in those cases. There are however,\nplaces where TinkerGraph may be just what you need. One example might be\ndoing analysis on a static graph that can fit into memory on your\nlaptop. The *air-routes* graph is a good example of such a graph. As a\nfirst step towards writing standalone applications that use different\ngraph database back ends, lets look at a few examples of how you can\ncreate a Java application that uses Gremlin and TinkerGraph.",
        "children": [
          {
            "level": "6.1.1",
            "title": "6.1.1. The Apache TinkerPop interfaces and classes {#tpinterfaces}",
            "content": "There are a number of Java interfaces and classes, defined by the Apache\nTinkerPop project, that you will want to become familiar with. The most\nrecent JavaDoc format API documentation is always available at\n<http://tinkerpop.apache.org/javadocs/current/full>\n\nThe TinkerPop JavaDoc is a bit lacking in terms of English prose but is\nstill a useful source of reference information when it comes to methods,\nparameters and types. Once you have coded up a couple of test programs\nand got them running, you should find it gets easier to make progress\nfaster. To that end I recommend you take a look at the sample code I\nhave included with the book.\n\nWhen using the Gremlin Console your environment is pre-configured for\nyou so you do not have to import any classes or interfaces. However, as\nsoon as you move to the domain of the standalone Java application you\nwill need to start importing the relevant classes that your application\nbuilds upon and learn to do a few other things that you may not have\nrealized that the Gremlin Console was doing on your behalf.\n\nBy way of a reasonable start, here are some imports that will enable us\nto do a number of Gremlin tasks from a Java application. As you add more\ncapabilities to your application you will of course need to add the\nappropriate import statements.\n\nTake particular note of the rather odd import of the class called\n\\\"\\_\\_\\\" (underscore underscore) on the second line. This is required to\nenable calling methods such as *in()* and *out()* in a traversal where\nthere is no prior step to \\\"dot\\\" attach them to (such as inside of a\n*repeat* step). If you prefer you can statically import the \\\"\\_\\_\\\"\nclass which will make explicit use of \\\".\\_\\_\\\" in your code unnecessary\nexcept where you are faced with reserved word conflicts as discussed\nearlier in this book.\n\n``` java\nimport org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.GraphTraversalSource;\nimport org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.__;\nimport org.apache.tinkerpop.gremlin.process.traversal.Path;\nimport org.apache.tinkerpop.gremlin.process.traversal.*;\nimport org.apache.tinkerpop.gremlin.structure.Edge;\nimport org.apache.tinkerpop.gremlin.structure.Vertex;\nimport org.apache.tinkerpop.gremlin.structure.io.IoCore;\nimport org.apache.tinkerpop.gremlin.tinkergraph.structure.*;\nimport java.io.IOException;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.util.Set;\n```",
            "children": []
          },
          {
            "level": "6.1.2",
            "title": "6.1.2. Writing our first TinkerPop Java program {#javatp1}",
            "content": "Now that we have some imports in place, we can start to craft the basic\noutline of a Java application. The code below defines a class called\n*TinkerGraphTest*, and defines a *main* method that creates an in memory\nTinkerGraph and loads the air routes GraphML data. Note that as we are\nnow going to be running as a Java program we have to catch exceptions.\nThis is another thing that is hidden from you when you are working\nwithin the Gremlin Console.\n\n::: tip\nThe source code for TinkerGraphTest.java is available in the\n*sample-code* folder located at\n<https://github.com/krlawrence/graph/tree/main/sample-code>.\n:::\n\nLastly in this initial class definition we create a\n*GraphTraversalSource* and we make a Gremlin query to get the property\n*valueMap* for the Austin airport vertex and print it. The *toString*\nmethod provided by the *Map* should give us some useful output. Take\nnote of the call to *next()*. This terminates the graph traversal and\ncauses the result to be returned. If this call is left off you will not\nget back what you were expecting!\n\n``` java\npublic class TinkerGraphTest\n{\n  public static void main(String[] args)\n  {\n    TinkerGraph tg = TinkerGraph.open() ;\n\n    try\n    {\n      tg.io(IoCore.graphml()).readGraph(\"./air-routes.graphml\");\n    }\n    catch( IOException e )\n    {\n      System.out.println(\"File not found\");\n      System.exit(1);\n    }\n    GraphTraversalSource g = tg.traversal();\n    Map<String,?> aus = g.V().has(\"code\",\"AUS\").valueMap().next();\n    System.out.println(aus);\n  }\n}\n```",
            "children": []
          },
          {
            "level": "6.1.3",
            "title": "6.1.3. Compiling our code {#javacompile}",
            "content": "Before we can test our program we of course need to compile it. The\neasiest way to do this while experimenting is to setup the Java\n*classpath* to include the TinkerPop JAR files. Once you get into\nwriting bigger solutions you will most likely be using a tool like\nApache Maven to control your build. For the purpose of our experiments\nhere, simple use of the *classpath* will suffice.\n\nThe following lines of Bash shell script will setup what you need to\nboth build and run our small test program. Note that the *GREMLIN*\nvariable should be set to point to the root directory of wherever your\nTinkerPop JAR files are. Later when we start using JanusGraph you will\nsee that rather than TinkerGraph we will need to adjust these settings\nto point to the JanusGraph JAR files.\n\n    # Root directory for Gremlin Console install\n    GREMLIN=...\n\n    # Path to Gremlin core JARs\n    LIBPATH=$GREMLIN/lib/*\n\n    # Path to TinkerGraph JARs\n    EXTPATH=$GREMLIN/ext/*\n\n    #Path to additional JARs\n    ADDL=$GREMLIN/ext/tinkergraph-gremlin/lib/*\n\n    # Classpath\n    export CP=$CLASSPATH:$LIBPATH:$EXTPATH:$ADDL\n\n\n    # Compile\n    javac -cp $CP TinkerGraphTest.java\n\nAssuming everything we have coded so far compiled OK, then we can run it\nusing the same *classpath* that we created previously.\n\n    # Run\n    java -cp $CP TinkerGraphTest\n\nThe output we get back should look something like the following. If it\ndoes, take 30 seconds to celebrate as you have just successfully built\nand run your first TinkerPop aware Java app!\n\n``` java\n{country=[US], code=[AUS], longest=[12250], city=[Austin], elev=[542], icao=[KAUS], lon=[-97.6698989868164], type=[airport], region=[US-TX], runways=[2], lat=[30.1944999694824], desc=[Austin Bergstrom International Airport]}\n```",
            "children": []
          },
          {
            "level": "6.1.4",
            "title": "6.1.4. Adding to our Java program {#javaadd}",
            "content": "Now that we have a basic skeleton application that compiles and runs, we\ncan start to add more experiments to it. If we add the two lines below\nwe can extract the city name from the value map that we just generated.\nFrom now on as we add to our program I am just going to show the lines\nthat we add and the additional output that those new lines will\ngenerate.\n\n``` java\nList city = (List)(aus.get(\"city\"));\nSystem.out.println(\"The AUS airport is in \" + city.get(0));\n```\n\nSo when we compile and run again we should now see this additional line\nof output.\n\n``` console\nThe AUS airport is in Austin\n```\n\nIf we wanted to nicely print out all of the values returned in our value\nmap we could do it as follows.\n\n``` java\naus.forEach( (k,v) -> System.out.println(\"Key: \" + k + \": Value: \" + v));\n```\n\nWhich will generate this output.\n\n``` java\nKey: country: Value: [US]\nKey: code: Value: [AUS]\nKey: longest: Value: [12250]\nKey: city: Value: [Austin]\nKey: elev: Value: [542]\nKey: icao: Value: [KAUS]\nKey: lon: Value: [-97.6698989868164]\nKey: type: Value: [airport]\nKey: region: Value: [US-TX]\nKey: runways: Value: [2]\nKey: lat: Value: [30.1944999694824]\nKey: desc: Value: [Austin Bergstrom International Airport]\n```\n\nSo we now know one way to get the property values from a vertex and\nmanipulate them. Let's now add something a bit more interesting to our\nprogram. The following two lines count the number of airports you can\nfly to non stop starting at Dallas Fort Worth (DFW) and print out that\nresult for us.\n\n``` java\nLong n = g.V().has(\"code\",\"DFW\").out().count().next();\nSystem.out.println(\"There are \" + n + \" routes from Dallas\");\n```\n\n``` console\nThere are 221 routes from Dallas\n```\n\nLet's now add some code to retrieve the airport IATA codes of these 221\nairports that we can fly to non stop from DFW. Note that this time we\nended our query with a call to the *toList()* method. This will\nterminate the traversal, and as the name implies, return the results to\nus in a list. An *order* step is used in the traversal so that we get\nthe airport codes back in ascending order.\n\n``` java\nList fromDfw = g.V().has(\"code\",\"DFW\").out().\n                     order().by(\"code\").values(\"code\").toList();\n\nSystem.out.println(fromDfw);\n```\n\nThe new output that we get back should look like this.\n\n``` java\n[ABI, ABQ, ACT, AEX, AGU, AMA, AMS, ANC, ASE, ATL, AUH, AUS, BDL, BHM, BIL, BIS, BJX, BKG, BMI, BNA, BOG, BOI, BOS, BPT, BRO, BTR, BWI, BZE, BZN, CAE, CCS, CDG, CHA, CHS, CID, CLE, CLL, CLT, CMH, CMI, CNM, COS, COU, CRP, CUN, CUU, CVG, CVN, CZM, DAY, DCA, DEN, DOH, DRO, DSM, DTW, DUS, DXB, EGE, ELP, EVV, EWR, EZE, FAR, FAT, FCO, FLL, FRA, FSD, FSM, FWA, GCK, GCM, GDL, GEG, GGG, GIG, GJT, GLH, GPT, GRI, GRK, GRR, GRU, GSO, GSP, GUA, GUC, HDN, HKG, HNL, HOU, HSV, IAD, IAH, ICN, ICT, IND, JAC, JAN, JAX, JFK, JLN, KOA, LAS, LAW, LAX, LBB, LCH, LEX, LFT, LGA, LHR, LIM, LIR, LIT, LRD, MAD, MAF, MBJ, MCI, MCO, MEI, MEM, MEX, MFE, MGA, MGM, MHK, MIA, MID, MKE, MLI, MLM, MLU, MOB, MSN, MSP, MSY, MTJ, MTY, MYR, MZT, NAS, NRT, OAK, OGG, OKC, OMA, ONT, ORD, ORF, PBC, PBI, PDX, PEK, PHL, PHX, PIA, PIB, PIT, PLS, PNS, PSP, PTY, PUJ, PVG, PVR, QRO, RAP, RDU, RIC, RNO, ROW, RSW, RTB, SAF, SAL, SAN, SAT, SAV, SBA, SCL, SDF, SEA, SFO, SGF, SHV, SJC, SJD, SJO, SJT, SJU, SLC, SLP, SMF, SNA, SPI, SPS, STL, SUX, SWO, SYD, TLH, TPA, TRC, TUL, TUS, TVC, TXK, TYR, TYS, UIO, VPS, XNA, YEG, YUL, YVR, YYC, YYZ, ZCL]\n```\n\nThe next lines will find all routes from London Heathrow to any airport\nin the United States. A list of paths will be returned where each path\ncontains the airport codes and the distance between them.\n\n``` java\nList <Path> lhrToUsa = g.V().has(\"code\",\"LHR\").outE().inV().\n                             has(\"country\",\"US\").\n                             path().by(\"code\").by(\"dist\").toList();\n\nlhrToUsa.forEach((k) -> System.out.println(k));\n```\n\nThe output should look like this. I arranged the results in columns to\naid readability.\n\n``` java\n[LHR, 4896, PDX]     [LHR, 4820, IAH]    [LHR, 3665, IAD]\n[LHR, 3980, CLT]     [LHR, 4414, MIA]    [LHR, 3860, RDU]\n[LHR, 3254, BOS]     [LHR, 4001, MSP]    [LHR, 4783, SEA]\n[LHR, 3622, BWI]     [LHR, 3440, JFK]    [LHR, 3939, ORD]\n[LHR, 4198, ATL]     [LHR, 5439, LAX]    [LHR, 5255, PHX]\n[LHR, 4901, AUS]     [LHR, 5469, SAN]    [LHR, 5350, SFO]\n[LHR, 4736, DFW]     [LHR, 4850, SLC]    [LHR, 3753, DTW]\n[LHR, 5352, SJC]     [LHR, 3453, EWR]    [LHR, 4655, DEN]\n[LHR, 4616, MSY]     [LHR, 5213, LAS]    [LHR, 3533, PHL]\n```\n\nThe final part of our first Java program shows how to perform a simple\n*repeat* operation. The code below will look for any cities in the UK\nthat you can get to from Austin with one stop on the way. A key thing to\nnote here is that we have to prefix the call to *out()* with the\nstrangely named class \\\"\\_\\_.\\\" that we mentioned at the start of this\ndiscussion of using Java with TinkerPop. If you do not include the\n\\\"\\_\\_.\\\" prefix you will get a compilation error as the compiler does\nnot know where the *out* step is from.\n\n``` java\nList <Object> eng =\n      g.V().has(\"code\",\"AUS\").repeat(__.out()).times(2).\n            has(\"region\",\"GB-ENG\").values(\"city\").dedup().toList();\n\nSystem.out.println(\"\\nPlaces in England I can get to with one stop from AUS.\\n\");\neng.forEach( (p) -> System.out.print(p + \" \"));\n```\n\nThe code we just added should generate output that looks like this.\n\n``` console\nPlaces in England I can get to with one stop from AUS.\n\nBirmingham Bristol London Manchester Leeds Newcastle\n```",
            "children": []
          },
          {
            "level": "6.1.5",
            "title": "6.1.5. Important Classes and Enums to be aware of {#javastatics}",
            "content": "When you are using the Gremlin Console, as I have already mentioned, a\nfew things are done for you that you need to take care of yourself when\nwriting standalone Java code. A key area that I have found that people\nmaking the jump from the console to Java find confusing is figuring out\nwhich Classes and Enums have been statically imported \\\"behind the\nscenes\\\" and how to access those same capabilities from Java. You should\nalso bookmark the TinkerPop javadoc pages as you can find more detail on\nall of the classes and enums covered below there. The latest javadoc is\nalways available at <http://tinkerpop.apache.org/javadocs/current/full/>\n\n::: tip\nThere is a sample program called TestImports.java in the *sample-code*\nfolder located at\n<https://github.com/krlawrence/graph/tree/main/sample-code> that\ndemonstrates these constructs being used.\n:::\n\nThe tables below show some commonly used Gremlin keywords in the left\ncolumn. The second column shows how you would reference those same\nkeywords explicitly from a Java program. The third column shows an\nexample of the context in which they might be used in a Java program.\nYou may chose to statically import some of these classes into your code.\nI prefer to use the explicit prefix but that is a matter of personal\npreference in many cases. There is a table of all the available\npredicates in the \\\"[Testing values and ranges of values](#tranges)\\\"\nsection. For the special \\\".\\_\\_\\\" class I have just shown a few\nexamples. In general you use this prefix when you have nothing prior in\nthe query that you can \\\"dot chain\\\" to.\n\nIf you need to specify how a property value should be treated when added\nto a vertex you can use one of the keywords defined as part of the\n*Cardinality* enum which is part of the *VertexProperty* interface.\n\n+-------------+-------------+------------------------------------------+\n| single      | Cardin      | proper                                   |\n|             | ality.local | ty(Cardinality.single,\\\"mykey\\\",\\\"ABC\\\") |\n+-------------+-------------+------------------------------------------+\n| list        | Cardi       | prop                                     |\n|             | nality.list | erty(Cardinality.list,\\\"mykey\\\",\\\"ABC\\\") |\n+-------------+-------------+------------------------------------------+\n| set         | Card        | pro                                      |\n|             | inality.set | perty(Cardinality.set,\\\"mykey\\\",\\\"ABC\\\") |\n+-------------+-------------+------------------------------------------+\n\n: Cardinality\n\nWhen local scope needs to be specified as a parameter of sort order\ndirection needs to be specified the statics defined in the *Scope* and\n*Order* Enums can be used.\n\n::: note\nThe *Order.incr* and *Order.decr* enumerations were deprecated in the\nTinkerPop 3.3.4 release in favor of *Order.asc* and *Order.desc* to\nbring the keywords more into line with other commonly used query\nlanguages. As of TinkerPop 3.5.0, *incr* and *decr* were removed from\nthe Gremlin query language altogether.\n:::\n\n+-------------+-------------+------------------------------------------+\n| local       | Scope.local | order(Scope.local)                       |\n+-------------+-------------+------------------------------------------+\n| global      | S           | order(Scope.global)                      |\n|             | cope.global |                                          |\n+-------------+-------------+------------------------------------------+\n| desc        | Order.desc  | order().by(Order.desc)                   |\n+-------------+-------------+------------------------------------------+\n| decr        | Order.decr  | order().by(Order.decr) \\[Deprecated      |\n|             |             | since 3.3.4, removed in 3.5.0\\]          |\n+-------------+-------------+------------------------------------------+\n| asc         | Order.asc   | order().by(Order.asc)                    |\n+-------------+-------------+------------------------------------------+\n| incr        | Order.incr  | order().by(Order.incr) \\[Deprecated      |\n|             |             | since 3.3.4, removed in 3.5.0\\]          |\n+-------------+-------------+------------------------------------------+\n| shuffle     | Or          | order().by(Order.shuffle)                |\n|             | der.shuffle |                                          |\n+-------------+-------------+------------------------------------------+\n\n: Scope and ordering\n\nIf you need to access the keys or values from a map data structure you\ncan use the statics defined in the *Column* enum.\n\n+-------------+-------------+------------------------------------------+\n| keys        | Column.keys | order().by(Column.keys)                  |\n+-------------+-------------+------------------------------------------+\n| values      | Co          | order().by(Column.values)                |\n|             | lumn.values |                                          |\n+-------------+-------------+------------------------------------------+\n\n: Keys and values\n\nWhen accessing the *id* and *label* values from a *valueMap* you need to\nuse the statics defined in the *T* Enum. The same is true if you want to\naccess the keys and values from a set of properties.\n\n+-------------+-------------+------------------------------------------+\n| label       | T.label     | valueMap(true).next().get(T.label)       |\n+-------------+-------------+------------------------------------------+\n| id          | T.id        | valueMap(true).next().get(T.id)          |\n+-------------+-------------+------------------------------------------+\n| key         | T.key       | properties().order().by(T.key)           |\n+-------------+-------------+------------------------------------------+\n| value       | T.value     | properties().order().by(T.value)         |\n+-------------+-------------+------------------------------------------+\n\n: Label and id\n\nWhen there is no previous step to \\\"dot chain\\\" to then we can use the\n\\\".\\_\\_\\\" class as our prefix. If you look at the javadoc for the class\nyou will see it defines static methods that we can use to call Gremlin\nfunctionality in cases like the ones shown below.\n\n+-------------+-------------+------------------------------------------+\n| out         | \\_\\_.out    | repeat(\\_\\_.out())                       |\n+-------------+-------------+------------------------------------------+\n| in          | \\_\\_.in     | order().by(\\_\\_.in(\\\"contains\\\"))        |\n+-------------+-------------+------------------------------------------+\n| constant    | \\_          | union(\\_                                 |\n|             | \\_.constant | \\_.constant(\\\"b\\\"),\\_\\_.constant(\\\"a\\\")) |\n+-------------+-------------+------------------------------------------+\n\n: Anonymous references\n\nWhenever we need to use a predicate to perform a test, we can use the\nstatic methods defined in the *P* class. Not all the methods defined are\nshown below.\n\n+-------------+-------------+------------------------------------------+\n| gt          | P.gt        | has(\\\"runways\\\",P.gt(3))                 |\n+-------------+-------------+------------------------------------------+\n| gte         | P.gte       | has(\\\"runways\\\",P.gte(5))                |\n+-------------+-------------+------------------------------------------+\n| lt          | P.lt        | has(\\\"runways\\\",P.lt(2))                 |\n+-------------+-------------+------------------------------------------+\n| lte         | P.lte       | has(\\\"runways\\\",P.lte(2))                |\n+-------------+-------------+------------------------------------------+\n| eq          | P.eq        | has(\\\"city\\\",P.eq(\\\"Dallas\\\"))           |\n+-------------+-------------+------------------------------------------+\n| neq         | P.neq       | has(\\\"city\\\",P.neq(\\\"Dallas\\\"))          |\n+-------------+-------------+------------------------------------------+\n| within      | P.within    | has(\\                                    |\n|             |             | \"city\\\",P.within(\\\"Dallas\\\",\\\"Austin\\\")) |\n+-------------+-------------+------------------------------------------+\n| without     | P.without   | has(\\\"city\\\",P.without(\\\"Dallas\\\"))      |\n+-------------+-------------+------------------------------------------+\n| inside      | P.inside    | has(\\\"runways\\\",P.inside(3,5))           |\n+-------------+-------------+------------------------------------------+\n| outside     | P.outside   | has(\\\"runways\\\",P.outside(2,5))          |\n+-------------+-------------+------------------------------------------+\n| between     | P.between   | has(\\\"runways\\\",P.between(2,5))          |\n+-------------+-------------+------------------------------------------+\n\n: Predicates\n\nThe Apache TinkerPop release 3.4 introduced some new text predicates and\na new TextP class.\n\n+-------------+-------------+------------------------------------------+\n| s           | TextP.s     | h                                        |\n| tartingWith | tartingWith | as(\\\"city\\\",TextP.startingWith(\\\"Dal\\\")) |\n+-------------+-------------+------------------------------------------+\n| endingWith  | TextP       | has(\\\"city\\\",TextP.endingWith(\\\"as\\\"))   |\n|             | .endingWith |                                          |\n+-------------+-------------+------------------------------------------+\n| containing  | TextP       | has(\\\"city\\\",TextP.containing(\\\"all\\\"))  |\n|             | .containing |                                          |\n+-------------+-------------+------------------------------------------+\n| notS        | TextP.notS  | has(                                     |\n| tartingWith | tartingWith | \\\"city\\\",TextP.notStartingWith(\\\"Dal\\\")) |\n+-------------+-------------+------------------------------------------+\n| no          | TextP.no    | h                                        |\n| tEndingWith | tEndingWith | as(\\\"city\\\",TextP.notEndingWith(\\\"as\\\")) |\n+-------------+-------------+------------------------------------------+\n| no          | TextP.no    | ha                                       |\n| tContaining | tContaining | s(\\\"city\\\",TextP.notContaining(\\\"all\\\")) |\n+-------------+-------------+------------------------------------------+\n\n: Text Predicates\n\nIf a traversal path has multiple values associated with a single label,\nsuch as *\\\"x\\\"* then you can use the *first*, *last* , *all* and *mixed*\nstatics that are defined as part of the *Pop* Enum. As the name suggest,\n*first* returns the first item in a collection. Specifying *last*\nreturns the last item and *all* returns all of the items in a\ncollection. Specifying *mixed* will return a *List* if the collection\nhas more than one item. Otherwise an *Object* will be returned.\n\n+-------------+-------------+------------------------------------------+\n| first       | Pop.first   | select(Pop.first,\\\"x\\\")                  |\n+-------------+-------------+------------------------------------------+\n| last        | Pop.last    | select(Pop.last,\\\"x\\\")                   |\n+-------------+-------------+------------------------------------------+\n| all         | Pop.all     | select(Pop.all,\\\"x\\\")                    |\n+-------------+-------------+------------------------------------------+\n| mixed       | Pop.mixed   | select(Pop.mixed,\\\"x\\\")                  |\n+-------------+-------------+------------------------------------------+\n\n: First, last, all and mixed\n\nWhen working with a *sack* the operators like *sum* and *assign* are\ndefined in the *Operator* Enum.\n\n+-------------+-------------+------------------------------------------+\n| sum         | O           | sack(Operator.sum)                       |\n|             | perator.sum |                                          |\n+-------------+-------------+------------------------------------------+\n| minus       | Ope         | sack(Operator.minus)                     |\n|             | rator.minus |                                          |\n+-------------+-------------+------------------------------------------+\n| mult        | Op          | sack(Operator.mult)                      |\n|             | erator.mult |                                          |\n+-------------+-------------+------------------------------------------+\n| div         | O           | sack(Operator.div)                       |\n|             | perator.div |                                          |\n+-------------+-------------+------------------------------------------+\n| assign      | Oper        | sack(Operator.assign).by(constant(0))    |\n|             | ator.assign |                                          |\n+-------------+-------------+------------------------------------------+\n| min         | O           | sack(Operator.min)                       |\n|             | perator.min |                                          |\n+-------------+-------------+------------------------------------------+\n| max         | O           | sack(Operator.max)                       |\n|             | perator.max |                                          |\n+-------------+-------------+------------------------------------------+\n| addAll      | Oper        | sack(Operator.addAll)                    |\n|             | ator.addAll |                                          |\n+-------------+-------------+------------------------------------------+\n| and         | O           | sack(Operator.and)                       |\n|             | perator.and |                                          |\n+-------------+-------------+------------------------------------------+\n| or          | Operator.or | sack(Operator.or)                        |\n+-------------+-------------+------------------------------------------+\n\n: Operators\n\nThe *Direction* Enum defines constants that are used in association with\nedge direction.\n\n+-------------+-------------+------------------------------------------+\n| IN          | D           | myEdge.vertices(Direction.IN)            |\n|             | irection.IN |                                          |\n+-------------+-------------+------------------------------------------+\n| OUT         | Di          | myEdge.vertices(Direction.OUT)           |\n|             | rection.OUT |                                          |\n+-------------+-------------+------------------------------------------+\n| BOTH        | Dir         | myEdge.vertices(Direction.BOTH)          |\n|             | ection.BOTH |                                          |\n+-------------+-------------+------------------------------------------+\n\n: Direction\n\nThe *Pick* Enum defines constants that are used in association with the\n*branch*, `choose` and `option` steps.\n\n+-------------+-------------+------------------------------------------+\n| none        | Pick.none   | option(none,constant(*no match*))        |\n+-------------+-------------+------------------------------------------+\n| any         | Pick.any    | option(any,constant(*any picked*))       |\n+-------------+-------------+------------------------------------------+\n\n: Pick\n\nAnother useful tip, that was shared on the Gremlin Users mailing list,\nis that you can ask the Gremlin Console to show you a list of everything\nthat has been imported on your behalf \\\"behind the scenes\\\" using the\ncommand *:show imports*. What might typically be returned is shown\nbelow. I included a version check in the output so in case this changes\nin the future you can see which version of Gremlin I queried.\n\n``` java\ngremlin> Gremlin.version\n==>3.4.10\n```\n\nHere is the list of imports that the Gremlin Console has setup for us\nquietly behind the scenes when we started it. Take particular note of\nthe ones that are *static* imports as those are the ones that contain\nthe definitions we discussed above.\n\n``` java\ngremlin> :show imports\nCustom imports:\n  org.apache.tinkerpop.gremlin.structure.*\n  org.apache.tinkerpop.gremlin.structure.util.*\n  org.apache.tinkerpop.gremlin.structure.util.reference.*\n  org.apache.tinkerpop.gremlin.process.traversal.*\n  org.apache.tinkerpop.gremlin.process.traversal.step.*\n  org.apache.tinkerpop.gremlin.process.traversal.step.util.*\n  org.apache.tinkerpop.gremlin.process.remote.*\n  org.apache.tinkerpop.gremlin.structure.util.empty.*\n  org.apache.tinkerpop.gremlin.structure.io.*\n  org.apache.tinkerpop.gremlin.structure.io.graphml.*\n  org.apache.tinkerpop.gremlin.structure.io.graphson.*\n  org.apache.tinkerpop.gremlin.structure.io.gryo.*\n  org.apache.commons.configuration.*\n  org.apache.tinkerpop.gremlin.process.traversal.strategy.decoration.*\n  org.apache.tinkerpop.gremlin.process.traversal.strategy.optimization.*\n  org.apache.tinkerpop.gremlin.process.traversal.strategy.finalization.*\n  org.apache.tinkerpop.gremlin.process.traversal.strategy.verification.*\n  org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.*\n  org.apache.tinkerpop.gremlin.process.traversal.util.*\n  org.apache.tinkerpop.gremlin.process.computer.*\n  org.apache.tinkerpop.gremlin.process.computer.traversal.step.map.*\n  org.apache.tinkerpop.gremlin.process.computer.clustering.connected.*\n  org.apache.tinkerpop.gremlin.process.computer.clone.*\n  org.apache.tinkerpop.gremlin.process.computer.bulkdumping.*\n  org.apache.tinkerpop.gremlin.process.computer.bulkloading.*\n  org.apache.tinkerpop.gremlin.process.computer.clustering.peerpressure.*\n  org.apache.tinkerpop.gremlin.process.computer.traversal.*\n  org.apache.tinkerpop.gremlin.process.computer.ranking.pagerank.*\n  org.apache.tinkerpop.gremlin.process.computer.search.path.*\n  org.apache.tinkerpop.gremlin.process.computer.traversal.strategy.optimization.*\n  org.apache.tinkerpop.gremlin.process.computer.traversal.strategy.decoration.*\n  org.apache.tinkerpop.gremlin.util.*\n  org.apache.tinkerpop.gremlin.util.iterator.*\n  org.apache.tinkerpop.gremlin.util.function.*\n  java.util.*\n  java.sql.*\n  static org.apache.tinkerpop.gremlin.structure.io.IoCore.*\n  static org.apache.tinkerpop.gremlin.process.traversal.P.*\n  static org.apache.tinkerpop.gremlin.process.traversal.AnonymousTraversalSource.*\n  static org.apache.tinkerpop.gremlin.process.traversal.TextP.*\n  static org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.__.*\n  static org.apache.tinkerpop.gremlin.process.computer.Computer.*\n  static org.apache.tinkerpop.gremlin.util.TimeUtil.*\n  static org.apache.tinkerpop.gremlin.util.function.Lambda.*\n  static org.apache.tinkerpop.gremlin.process.traversal.SackFunctions.Barrier.*\n  static org.apache.tinkerpop.gremlin.structure.VertexProperty.Cardinality.*\n  static org.apache.tinkerpop.gremlin.structure.Column.*\n  static org.apache.tinkerpop.gremlin.structure.Direction.*\n  static org.apache.tinkerpop.gremlin.process.traversal.Operator.*\n  static org.apache.tinkerpop.gremlin.process.traversal.Order.*\n  static org.apache.tinkerpop.gremlin.process.traversal.Pop.*\n  static org.apache.tinkerpop.gremlin.process.traversal.Scope.*\n  static org.apache.tinkerpop.gremlin.structure.T.*\n  static org.apache.tinkerpop.gremlin.process.traversal.step.TraversalOptionParent.Pick.*\n  org.apache.tinkerpop.gremlin.driver.*\n  org.apache.tinkerpop.gremlin.driver.exception.*\n  org.apache.tinkerpop.gremlin.driver.message.*\n  org.apache.tinkerpop.gremlin.driver.ser.*\n  org.apache.tinkerpop.gremlin.driver.remote.*\n  org.apache.tinkerpop.gremlin.tinkergraph.structure.*\n  org.apache.tinkerpop.gremlin.tinkergraph.process.computer.*\n```\n\nAs discussed earlier, you can always use the *getClass* method or simply\n*.class* while using the Gremlin Console to, in many cases, find out\nwhere something is defined. As we saw in the examples earlier in this\nsection, lot of the keywords such as *values*, *id* and *local* are\ndefined as Enums so you can use *getClass* on them directly. A few\nexamples are shown below.\n\n``` java\ngremlin> label.getClass()\n==>class org.apache.tinkerpop.gremlin.structure.T$1\ngremlin> key.getClass()\n==>class org.apache.tinkerpop.gremlin.structure.T$3\ngremlin> keys.getClass()\n==>class org.apache.tinkerpop.gremlin.structure.Column$1\ngremlin> values.getClass()\n==>class org.apache.tinkerpop.gremlin.structure.Column$2\ngremlin> local.getClass()\n==>class org.apache.tinkerpop.gremlin.process.traversal.Scope\ngremlin> Order.class\n==>class org.apache.tinkerpop.gremlin.process.traversal.Order\ngremlin> Column.class\n==>class org.apache.tinkerpop.gremlin.structure.Column\n```\n\nIf you compare this output to the tables above you can see that we have\nbeen able to verify that, for example, that *label* and *key* are\ndefined in the *T* Enum. We can also see that *keys* and *values* are\nindeed defined in the *Column* Enum. Lastly, we can see that *local* is,\nas we expected, defined in the *Scope* Enum.",
            "children": []
          },
          {
            "level": "6.1.6",
            "title": "6.1.6. Using Gremlin predicates in a Java application {#javapredicates}",
            "content": "As discussed in the previous section, when you use a Gremlin predicate\nsuch as *eq* or *neq* from a Java program you need to prefix it with a\n*\\\"P.\\\"* which is a reference to the TinkerPop class of the same name\nwhere a set of static methods, representing the Gremlin predicates, are\ndefined.\n\n::: tip\nYou will find a sample program called GraphRegion.java, which contains\nthe code used in this section, in the sample files directory located at\n<https://github.com/krlawrence/graph/tree/main/sample-code>.\n:::\n\nTake a look at the code below. A method called *findByRegion* is defined\nthat takes a String representing a three character airport IATA code as\ninput. The method then uses a Gremlin query to figure out which\ngeographical region the specified airport is in and then returns all\nairports also in that region. Note the use of *P.eq* as part of the\n*where* step. This is another case of where, because we are not running\ninside the Gremlin console, we have to more precisely specify things.\n\n``` java\n// Find all airports in the region of the specified airport\npublic void findByRegion(String iata)\n{\n  System.out.println(\"\\nRegion code lookup for \" + iata );\n\n  List<List<Object>> list =\n  g.V().has(\"code\",iata).values(\"region\").as(\"r\").\n    V().hasLabel(\"airport\").as(\"a\").values(\"region\").\n        where(P.eq(\"r\")).by().\n        local(__.select(\"a\").values(\"city\",\"code\",\"region\").fold()).toList();\n\n  for(List t : list)\n  {\n    System.out.println(t);\n  }\n}\n```\n\nIf we were to call the *findByRegion* method, passing in a parameter of\n*DEN*, representing the airport in Denver Colorado, the following output\nshould be returned.\n\n``` console\nRegion code lookup for DEN\n[COS, Colorado Springs, US-CO]\n[DEN, Denver, US-CO]\n[DRO, Durango, US-CO]\n[GJT, Grand Junction, US-CO]\n[EGE, Eagle, US-CO]\n[HDN, Hayden, US-CO]\n[APA, Denver, US-CO]\n[TEX, Telluride, US-CO]\n[ASE, Aspen, US-CO]\n[ALS, Alamosa, US-CO]\n[CEZ, Cortez, US-CO]\n[GUC, Gunnison, US-CO]\n[MTJ, Montrose, US-CO]\n[PUB, Pueblo, US-CO]\n```",
            "children": []
          },
          {
            "level": "6.1.7",
            "title": "6.1.7. Checking to see if a query returned a result {#javacheck}",
            "content": "It is often important to know if a query returned a result before trying\nto reference it to avoid those pesky Java Null Pointer Exceptions.\nWithout worrying about Java for a second consider the query below purely\nfrom a Gremlin point of view.\n\n``` java\ng.V().has(\"code\",\"AUS\").outE().as(\"edge\").inV().has(\"code\",\"SYD\").\n                        select(\"edge\").by(\"dist\")\n```\n\nThe query finds the Austin (AUS) airport and then looks for an outgoing\nedge connecting Austin with Sydney (SYD) and then returns the distance\nvalue from that edge. The problem here is that there is no direct route\nbetween Austin and Sydney and therefore no edge to retrieve the distance\nfrom. In other words, this query returns no result. Now, within the\nGremlin Console this is not a problem as we just get nothing back and\nlife goes on. However, take a look at the code below which is a first\nattempt at moving the query into Java code.\n\n``` java\nLong result =\n      g.V().has(\"code\",\"AUS\").outE().as(\"edge\").inV().has(\"code\",\"SYD\").\n            select(\"edge\").by(\"dist\").next();\n```\n\nOn the surface, this looks fine. However, were we to execute this code\nwe would get a Null Pointer Exception as when we try to call *next*\nthere is no result to process as there is no edge between Austin and\nSydney and hence no distance value to process.\n\n::: tip\nYou will find a sample program called GraphSearch2.java, which contains\nthe code used in this section, in the sample files directory located at\n<https://github.com/krlawrence/graph/tree/main/sample-code>.\n:::\n\nSo we need a way to check to see if we go a valid result. One such way\nis to store the result of the query into a list. Then, worst case, if no\nresults are found, we will get an empty list back. So, we can rewrite\nthe query as follows.\n\n``` java\nList result =\n      g.V().has(\"code\",\"AUS\").outE().as(\"edge\").inV().has(\"code\",\"SYD\").\n            select(\"edge\").by(\"dist\").toList();\n```\n\nNow that the result is in a list we can safely check to see if we got\nany results.\n\n``` java\nif (result.isEmpty())\n{\n  System.out.println(\"No results were found\");\n}\nelse\n{\n  System.out.println(\"The distance is \" + result.get(0));\n}\n```\n\nIf we wanted a \\\"pure Gremlin\\\" solution, without using a List and\nwithout doing some post processing, one way we could do it is to use the\n*coalesce* step and return a special constant value, in this case minus\none, to indicate that there were no results found.\n\n``` java\nInteger d = (Integer)\n    g.V().has(\"code\",\"AUS\").outE().as(\"edge\").inV().has(\"code\",\"SYD\").\n          select(\"edge\").by(\"dist\").fold().\n          coalesce(__.unfold(),__.constant(-1)).next();\n```\n\nIf the route exists the distance will be found and returned, otherwise a\nvalue of *\\\"-1\\\"* will be returned. This is really using the same\nconcept as the *toList* example except in this case we generate the list\nusing the *fold* step within the query itself. The *unfold* will return\na result if the list is not null, otherwise the constant value will be\nreturned as *coalesce* returns the first to yield a result.\n\nThere are of course many other ways that you might come up with to solve\nthis problem but using lists often provides a fairly easy to use\nsolution.",
            "children": []
          },
          {
            "level": "6.1.8",
            "title": "6.1.8. Creating a new graph from a Java application {#javacreate}",
            "content": "The code below creates a new (empty) TinkerGraph instance, creates a\ngraph traversal source object and then uses a traversal to create a\nsmall graph.\n\n::: tip\nThe full source code for this sample can be found in the file\nCreateGraph.java located at\n<https://github.com/krlawrence/graph/tree/main/sample-code>\n:::\n\nNote the call to *iterate()* at the end of the traversal. When running\nas a standalone application this is necessary. This is another of those\nlittle things that the Gremlin Console does for you without you\nrealizing it that we have to remember to do ourselves when not running\ninside the console.\n\n``` java\n// Create a new (empty) TinkerGrap\nTinkerGraph tg = TinkerGraph.open() ;\n\n// Create a Traversal source object\nGraphTraversalSource g = tg.traversal();\n\n// Add some nodes and vertices - Note the use of \"iterate\".\ng.addV(\"airport\").property(\"code\",\"AUS\").as(\"aus\").\n  addV(\"airport\").property(\"code\",\"DFW\").as(\"dfw\").\n  addV(\"airport\").property(\"code\",\"LAX\").as(\"lax\").\n  addV(\"airport\").property(\"code\",\"JFK\").as(\"jfk\").\n  addV(\"airport\").property(\"code\",\"ATL\").as(\"atl\").\n  addE(\"route\").from(\"aus\").to(\"dfw\").\n  addE(\"route\").from(\"aus\").to(\"atl\").\n  addE(\"route\").from(\"atl\").to(\"dfw\").\n  addE(\"route\").from(\"atl\").to(\"jfk\").\n  addE(\"route\").from(\"dfw\").to(\"jfk\").\n  addE(\"route\").from(\"dfw\").to(\"lax\").\n  addE(\"route\").from(\"lax\").to(\"jfk\").\n  addE(\"route\").from(\"lax\").to(\"aus\").\n  addE(\"route\").from(\"lax\").to(\"dfw\").iterate();\n```\n\nHaving created a new graph we can run some queries to make sure it looks\ncorrect. Firstly, let's check that the vertices were created and look at\nthe IDs that were allocated to them. As with prior examples, a call to\n*valueMap* with a parameter of *true* will return what we need. What we\nwill get back from this code is a list of maps, with each map containing\nkeys for the airport code, the vertex ID and the vertex label.\n\n``` java\nList<Map<Object,Object>> vm = new ArrayList<Map<Object,Object>>() ;\n\nvm = g.V().valueMap(true).toList();\n```\n\nHaving got our list of maps back we can process them. Note that to get\nthe *id* and *label* values from the map I had to prefix the key name\nwith a *\\\"T.\\\"*. This is because while most of property keys are\nStrings, IDs and labels are a special case. If you look at the TinkerPop\ndocumentation you will see that T is a Java Enum that contains\ndefinitions for *T.id*, *T.label*, *T.value* and *T.key*. When working\nwith Gremlin in Java it is important to remember that we need to use the\n*\\\"T.\\\"* prefix in cases where when using the Gremlin Console we would\nnot have to.\n\n``` java\n// Dislpay the code property as well as the label and id.\nfor( Map m : vm)\n{\n  System.out.println(((List)(m.get(\"code\"))).get(0) + \" \" +\n                             m.get(T.id) + \" \" + m.get(T.label));\n}\n```\n\nIf all has gone well during graph creation, we should get back a list\nlike the one below that shows us the ID that has been given to each\nvertex.\n\n``` java\nAUS 0 airport\nDFW 2 airport\nLAX 4 airport\nJFK 6 airport\nATL 8 airport\n```\n\nFinally, let's check that the edges were created correctly by displaying\nall of the paths between vertices in our new graph.\n\n``` java\n// Display the routes in the graph we just created\n\nList<Path> paths = new ArrayList<Path>();\n\npaths = g.V().out().path().by(\"code\").toList();\n\nfor (Path p : paths)\n{\n  System.out.println(p.toString());\n}\n```\n\nOnce again, if everything has worked as expected, here is what we should\nget back.\n\n``` java\n[AUS, DFW]\n[AUS, ATL]\n[DFW, JFK]\n[DFW, LAX]\n[LAX, JFK]\n[LAX, AUS]\n[LAX, DFW]\n[ATL, DFW]\n[ATL, JFK]\n```",
            "children": []
          },
          {
            "level": "6.1.9",
            "title": "6.1.9. Saving a graph from a Java application {#javasave}",
            "content": "Having created our new graph, we may want to save it. The code below\nshows how to save the graph as either GraphSON (TinkerPop's JSON format)\nor as GraphML (XML). This is another instance where we have to do a bit\nmore work as we are running in a standalone program and not inside the\nGremlin Console. Our attempts to save our data have to catch any\nexceptions that may occur. This code is also included as part of the\nCreateGraph.java sample program.\n\n``` java\n// Save the graph we just created as GraphML (XML) or GraphSON (JSON)\ntry\n{\n  // If you want to save the graph as GraphML uncomment the next line\n  tg.io(IoCore.graphml()).writeGraph(\"mygraph.graphml\");\n\n  // If you want to save the graph as JSON uncomment the next line\n  tg.io(IoCore.graphson()).writeGraph(\"mygraph.json\");\n}\ncatch (IOException ioe)\n{\n  System.out.println(\"Graph failed to save\");\n}\n```",
            "children": []
          }
        ]
      },
      {
        "level": "6.2",
        "title": "6.2. Working with TinkerGraph from a Groovy application {#groovyapp}",
        "content": "Earlier in this book, in the \\\"[Making Gremlin even Groovier](#grv)\\\"\nsection we explored the ways that you can use Groovy code within the\nGremlin Console. However, we have not yet looked at how you can use a\nstandalone Groovy application to work with a TinkerGraph.\n\n::: note\nYou will find several Groovy samples at the GitHub repository associated\nwith this book. <https://github.com/krlawrence/graph>\n:::\n\nIn this section we will rewrite parts of the test application we coded\nin Java earlier in Groovy. A lot of what was covered in the \\\"[Working\nwith TinkerGraph from a Java Application](#javatinker)\\\" section is\nequally relevant here and I have not duplicated that material. So even\nif you are writing a Groovy application please also give that section a\nread.\n\n::: tip\nThe examples in this section are taken from a sample program called\nTinkerGraphTest.groovy that you will find in the sample code folder\nlocated at <https://github.com/krlawrence/graph/tree/main/sample-code>.\n:::\n\nIt is assumed that you have downloaded and installed Groovy for your\nenvironment and have set the PATH to point to wherever the Groovy\nbinaries are located. Just as in the Java example, the first thing we\nneed to do is pull in via *import* all of the TinkerPop 3 classes that\nour program will use.\n\n``` java\nimport org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.GraphTraversalSource;\nimport org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.__;\nimport org.apache.tinkerpop.gremlin.process.traversal.Path;\nimport org.apache.tinkerpop.gremlin.process.traversal.*;\nimport org.apache.tinkerpop.gremlin.structure.Edge;\nimport org.apache.tinkerpop.gremlin.structure.Vertex;\nimport org.apache.tinkerpop.gremlin.structure.io.IoCore;\nimport org.apache.tinkerpop.gremlin.tinkergraph.structure.*;\nimport org.apache.tinkerpop.gremlin.tinkergraph.structure.TinkerGraph;\nimport org.apache.tinkerpop.gremlin.util.Gremlin;\nimport java.io.IOException;\n```\n\nHaving imported the classes we need, we can make a start on our\napplication. Initially we are just going to display the version of\nTinkerPop that we are using.\n\n``` java\nprintln \"The Gremlin version is ${Gremlin.version()}\"\n\ndef tg = TinkerGraph.open()\n```\n\nWe are now ready to create a new TinkerGraph instance and try to load\nthe air routes graph. We can do this in Groovy just like we did in the\nJava example. Unlike Java, however, Groovy does not require you to catch\nexceptions that may get thrown but as a best practice it is probably a\ngood idea to still do so when you need to take some specific action if\nan exception does happen.\n\n``` java\nprintln \"Loading the air-routes graph...\\n\"\n\n// Load the air-routes graph\ntry\n{\n  tg.io(IoCore.graphml()).readGraph(\"air-routes.graphml\");\n}\ncatch (IOException e)\n{\n  println \"Could not load the graph file\"\n  System.exit(0);\n}\n```\n\nAssuming we did not get an exception we can go ahead and create our\ngraph traversal object.\n\n``` java\n// Create a graph traversal source object and find the Austin airport vertex\ndef g = tg.traversal()\n```\n\nFirst we just do a simple query to find the vertex representing the AUS\nairport and use *println* to display some information about it.\n\n``` java\ndef aus = g.V().has('code','AUS').valueMap().next()\n\nprintln aus\n```\n\n::: note\nJust as when we were looking at building a Java application, you need to\nterminate your query with a step such as *next*, *toList* or *fill* to\nmake sure you get back the results that you expect.\n:::\n\nNow we have the beginnings of an application it's time to make sure we\ncan compile it. The key thing we need to do is make sure we pickup the\nTinkerPop specific JAR files as shown in the next section.",
        "children": [
          {
            "level": "6.2.1",
            "title": "6.2.1. Compiling our Groovy application {#groovyc}",
            "content": "In the Java example, I included the CLASSPATH on the *javac* invokation\nusing the *-cp* flag. That can also be done when using Groovy, however,\nif you are using Microsoft Windows as your build environment you may\nfind that using *-cp* gives unexpected errors. Therefore, it is\nrecommended to define the CLASSPATH variable in your environment before\nrunning the Groovy compiler.\n\nThe commands below work in a Bash shell but could be easily ported to\nother environments. The GREMLIN variable should point to wherever you\nhave installed and unzipped the Gremlin Console download\n\n    # Root directory for Gremlin Console install\n    GREMLIN=...\n\n    # Path to Gremlin core JARs\n    LIBPATH=$GREMLIN/lib/*\n\n    # Path to TinkerGraph JARs\n    EXTPATH=$GREMLIN/ext/*\n\n    #Path to additional JARs\n    ADDL=$GREMLIN/ext/tinkergraph-gremlin/lib/*\n\n    # Classpath\n    export CLASSPATH=$CLASSPATH:$LIBPATH:$EXTPATH:$ADDL\n\n    # Compile\n    groovyc TinkerGraphTest.groovy",
            "children": []
          },
          {
            "level": "6.2.2",
            "title": "6.2.2. Running our Groovy application {#_running_our_groovy_application}",
            "content": "Assuming everything compiled cleanly we can now run our Groovy\napplication.\n\n``` java\ngroovy TinkerGraphTest\n```\n\nAnd here is the sort of output we should get back.\n\n``` java\nGremlin version is 3.3.1\nLoading the air-routes graph...\n\n[country:[US], code:[AUS], longest:[12250], city:[Austin], elev:[542], icao:[KAUS], lon:[-97.6698989868164], type:[airport], region:[US-TX], runways:[2], lat:[30.1944999694824], desc:[Austin Bergstrom International Airport]]\n```\n\nNow that we have a small skeleton of a test program running, we can\nstart to add a few more interesting features to it.",
            "children": []
          },
          {
            "level": "6.2.3",
            "title": "6.2.3. Adding to our Groovy application {#_adding_to_our_groovy_application}",
            "content": "The code below demonstrates how to work with the *valueMap* for the\nAustin vertex that we created a few lines back in our program.\n\n``` java\n// Retieve the city name property and display it\ndef city = aus['city']\nprintln \"\\nThe AUS airport is in ${city[0]}\\n\"\n\n// Iterate through the keys we got back and print them along with their values\naus.each {println \"${it.key} : ${it.value[0]}\"}\n```\n\nIf we were to re-compile and run our program now, the lines that we\nadded will generate the following output.\n\n``` java\nThe AUS airport is in Austin\n\ncountry : US\ncode : AUS\nlongest : 12250\ncity : Austin\nelev : 542\nicao : KAUS\nlon : -97.6698989868164\ntype : airport\nregion : US-TX\nrunways : 2\nlat : 30.1944999694824\ndesc : Austin Bergstrom International Airport\n```\n\nAs we did in our Java program earlier, we can add a query to see how\nmany routes there are that originate at the DFW airport.\n\n``` java\ndef n = g.V().has(\"code\",\"DFW\").out().count().next()\nprintln \"\\nThere are  ${n} routes from Dallas\"\n\nThere are  221 routes from Dallas\n```\n\nNext we can add some code to find the IATA codes representing the places\nthat we can fly to from DFW.\n\n``` java\n// Where can I fly to from DFW?\ndef fromDfw = g.V().has(\"code\",\"DFW\").out().values(\"code\").toList()\nprintln \"\\nHere are the places you can fly to from DFW\\n\"\nprintln fromDfw\n```\n\nWhen we run the code we should get back some results that look like\nthis.\n\n``` java\nHere are the places you can fly to from DFW\n\n[CID, HNL, HOU, SAN, SNA, SLC, LAS, DEN, SAT, MSY, EWR, DTW, ELP, SJU, CLE, OAK, TUS, SAF, PHL, GEG, BZN, JAC, GCM, MEI, PIB, KOA, SUX, SBA, ASE, CVN, BKG, BIS, GUC, MTJ, TVC, CNM, GLH, SWO, BIL, MAF, BDL, RAP, SDF, SHV, BOI, LBB, RNO, CMH, ICT, ACT, CLL, ABI, SGF, RIC, CCS, TXK, PIA, LEX, GUA, CRP, MTY, AMA, BJX, BMI, BOG, BPT, DSM, MYR, AEX, CZM, AGU, COU, DAY, CUU, DRO, BRO, BTR, BZE, CAE, CHA, CHS, CMI, GCK, GDL, GGG, GJT, GPT, EVV, FAR, FAT, FSD, FSM, FWA, JAN, JLN, YYZ, LAW, YVR, LCH, LHR, LFT, CDG, LIR, GRI, GRK, GRR, GSO, GSP, MLI, PEK, MLM, PVG, MLU, FCO, MOB, AMS, MSN, MAD, MZT, RSW, PBC, FRA, LRD, NRT, MFE, SYD, MGM, DXB, MHK, HKG, QRO, ICN, ROW, GIG, SAL, GRU, SAV, EZE, SJD, LIM, SJT, SCL, SLP, MEX, SPI, YUL, PLS, YEG, PNS, YYC, PTY, DOH, OKC, TYS, ONT, VPS, AUH, XNA, CLT, ZCL, CUN, EGE, PSP, HDN, MEM, UIO, CVG, MID, TYR, ATL, ANC, TLH, SPS, PIT, TRC, PDX, ABQ, MKE, OMA, TUL, PVR, OGG, DUS, LGA, NAS, STL, JFK, LAX, AUS, IND, MGA, BNA, MCI, BOS, BWI, DCA, FLL, IAD, IAH, JAX, PUJ, SJO, SMF, RTB, COS, SJC, HSV, TPA, BHM, LIT, ORF, SFO, MCO, MBJ, MIA, MSP, ORD, PBI, PHX, RDU, SEA]\n```\n\nThe code below will discover all of the airports in the United States\nthat you can fly to from London's Heathrow airport (LHR). Only the first\n10 results are selected using a *limit* step. A *path* step is used to\nnicely return the airport pairs and the distance between them. What we\nget back is a list of paths so we can use a simple Groovy *each* loop to\nprint the results.\n\n``` java\ndef lhrToUsa = g.V().has(\"code\",\"LHR\").outE().inV().\n                     has(\"country\",\"US\").limit(10).\n                     path().by(\"code\").by(\"dist\").toList()\n\nprintln \"\\nFrom LHR to airports in the USA (only 10 shown)\\n\"\n\nlhrToUsa.each {println it}\n```\n\nHere are the 10 routes that were returned when I ran the code having\nadded this new query.\n\n``` java\nFrom LHR to airports in the USA (only 10 shown)\n\n[LHR, 4896, PDX]\n[LHR, 3980, CLT]\n[LHR, 4198, ATL]\n[LHR, 4901, AUS]\n[LHR, 3254, BOS]\n[LHR, 3622, BWI]\n[LHR, 4736, DFW]\n[LHR, 3665, IAD]\n[LHR, 4820, IAH]\n[LHR, 3440, JFK]\n```\n\nFinally, lets write the code to find the airports in England that you\ncan get to from Austin with no more than one stop.\n\n``` java\ndef eng = g.V().has(\"code\",\"AUS\").repeat(__.out()).emit().times(2).\n                has(\"region\",\"GB-ENG\").dedup().values(\"code\").toList();\n\nprintln \"\\nAirports in England reachable with no more than one stop from AUS\"\nprintln \"\\n${eng}\\n\"\n```\n\nHere are the results, looks like we can get to a total of nine different\nairports if we make no more than one stop on the way.\n\n``` java\nAirports in England reachable with no more than one stop from AUS\n\n[LHR, BRS, LGW, STN, MAN, BHX, LBA, NCL, LCY]\n```\n\nNow that we have a somewhat interesting Groovy application up and\nrunning, should you so choose, you can build upon this foundation just\nas we did in the \\\"[Working with TinkerGraph from a Java\nApplication](#javatinker)\\\" section.",
            "children": []
          },
          {
            "level": "6.2.4",
            "title": "6.2.4. Using Gremlin predicates in a Groovy application {#groovypredicates}",
            "content": "Just as we had to do when writing a standalone Java application, when\nyou use a Gremlin predicate such as *eq* or *neq* from a Groovy program\nyou need to prefix it with a *\\\"P.\\\"* which references the TinkerPop\nclass of the same name where a set of static methods, representing the\nGremlin predicates, are defined.\n\n::: tip\nYou will find a sample program called GraphRegion.groovy, which contains\nthe code used in this section, in the sample files directory located at\n<https://github.com/krlawrence/graph/tree/main/sample-code>.\n:::\n\nIn the code below, the *findByRegion* method that we wrote in Java\nearlier has been ported to Groovy. As before a String representing a\nthree character airport IATA code is expected as input. The method then\nuses a Gremlin query to figure out which geographical region the\nspecified airport is in and then returns all airports also in that\nregion. Once again, note the use of *P.eq* as part of the *where* step.\n\n``` java\ndef findByRegion(iata)\n{\n  println(\"\\nRegion code lookup for \" + iata )\n\n  def list =\n    g.V().has(\"code\",iata).values(\"region\").as(\"r\").\n      V().hasLabel(\"airport\").as(\"a\").values(\"region\").\n          where(P.eq(\"r\")).by().\n          local(__.select(\"a\").values(\"city\",\"code\",\"region\").fold()).toList()\n\n  list.each {println it}\n}\n```",
            "children": []
          }
        ]
      },
      {
        "level": "6.3",
        "title": "6.3. Introducing JanusGraph {#janusintro}",
        "content": "So far we have been using the TinkerGraph graph that is included with\nApache TinkerPop in our examples. Once you move beyond learning about\nGremlin and its related technologies and moving towards a production\ndeployment, you will need a graph store that provides capabilities such\nas reliable persistence, the ability to define schemas and support for\nACID transactions. The JanusGraph project, which began in 2016 as an\nopen source fork of the popular Titan graph database, is hosted by the\nLinux Foundation and provides these advanced capabilities.\n\nIn this book I have attempted to provide a reasonable amount of\nJanusGraph coverage but it is still recommended to become familiar with\nthe official JanusGraph documentation where you will find more in depth\ndiscussions of advanced topics and explanations of the many settings\nthat you can manipulate to suit your needs.\n\nJanusGraph can run on a laptop, which is useful for learning and\nexperimenting, but it is designed to handle very large graphs stored on\ndistributed clusters. It can handle graphs containing billions of\nvertices and edges. As we shall discuss, JanusGraph is designed to work\nwith a variety of persistent storage options including Apache Cassandra\nand Apache HBase as well as indexing technology such as Apache Solr and\nElasticsearch.\n\nRuntime download (JAR files and more)\n\n:   <http://janusgraph.org/>\n\nDocumentation\n\n:   <http://docs.janusgraph.org/latest/>.\n\nAPI Documentation\n\n:   <http://docs.janusgraph.org/latest/javadoc.html>\n    <http://javadoc.io/doc/org.janusgraph/janusgraph-core/0.2.0>\n\nIn the following sections we will take an in depth look at JanusGraph\nand other technologies that, when combined, provide a way to build and\ndeploy a massively scalable graph database solution. We will start by\nquickly looking at how to install JanusGraph and access it from the\nGremlin Console before getting into more advanced topics including how\nto create and manage both schemas and indexes and how to use the\ntransactional capabilities provided by JanusGraph.\n\nIt is also recommended that you read and get familiar with the official\nJanusGraph documentation as well as reading what is presented below.",
        "children": [
          {
            "level": "6.3.1",
            "title": "6.3.1. Installing JanusGraph {#janusinstall}",
            "content": "JanusGraph itself is very easy to install. You just have to download the\nZIP file and unzip it into a convenient location. Having done that you\ncan immediately begin to experiment with it if you use the *inmemory*\noption which is explained more in the [Using JanusGraph with the\noption](#janusinmemory) section below. However, for a production\ndeployment you will probably be using JanusGraph in conjunction with\nsome sort of persistent storage, an indexing service and other\ncomponents that will also have to be installed. We will get into that a\nbit later on. The download page has information regarding versions of\nrelated technologies like Apache Cassandra and Apache Solr that\nJanusGraph has been tested with.\n\n::: note\nIt is important to remember that JanusGraph does not have its own\nprocess, it is not a delivered as a service that you run, rather it is a\nset of Java classes that have to be invoked either from your own code,\nthe Gremlin Console hosted using something like Gremlin Server.\n:::\n\nThe install package for JanusGraph is located at\n<http://janusgraph.org/> and is a single ZIP file. Once you have it\ndownloaded and unzipped you are ready to experiment using the Gremlin\nConsole. As will be discussed below, when working with JanusGraph you\nmust use the version of the Gremlin Console that is packaged as part of\nthe JanusGraph download.",
            "children": []
          },
          {
            "level": "6.3.2",
            "title": "6.3.2. Using JanusGraph from the Gremlin Console {#janusconsole}",
            "content": "A version of the Gremlin Console is included as part of the JanusGraph\ndownload. The only major difference between this version of the console\nand the one you get as part of the standard Apache TinkerPop download is\nthat the console has been preconfigured to recognize and find the\nJanusGraph specific classes. A good example of one such class is\n*JanusGraphFactory* that is used from the Console to create a new\nJanusGraph instance.\n\n::: note\nWhen working with JanusGraph you must use the version of the Gremlin\nConsole that is packaged as part of the JanusGraph download.\n:::\n\nAs mentioned above, JanusGraph is not a standalone service, it is a set\nof Java classes that still need to be invoked by a calling process. The\nGremlin Console can play that role. After you have unzipped JanusGraph\nyou will find the `gremlin.sh` and `gremlin.bat` scripts in the `bin`\ndirectory under the JanusGraph parent directory. Once you have started\nthe Gremlin Console you can, as we will explore in the next few\nsections, tell JanusGraph about the environment you will be operating in\nin terms of back end store and index.",
            "children": []
          },
          {
            "level": "6.3.3",
            "title": "6.3.3. Using JanusGraph with the *inmemory* option {#janusinmemory}",
            "content": "For almost all production use cases, you will be using JanusGraph along\nwith a persistent back end store such as Apache Cassandra or Apache\nHBase. However while experimenting with JanusGraph it is incredibly\nuseful to be able to get up and running quickly without having to worry\nabout configuring all of the back end storage components. This is made\npossible by the *inmemory* option that JanusGraph provides. This\nessentially allows us to use JanusGraph in the same way as we have been\nusing TinkerGraph with all of our graph data stored in the memory of the\ncomputer. The one big difference however is that JanusGraph, even while\nusing the *inmemory* storage model, allows us to experiment with\nfeatures that TinkerGraph does not offer, such as schemas and\ntransactions. We will get into those topics a bit later on. First, let's\ncreate an instance of JanusGraph from the Gremlin console that uses the\n*inmemory* storage model.\n\nCreating a JanusGraph instance is very similar to the way we created a\nTinkerGraph instance earlier in the book. The only difference is that we\nuse the *JanusGraphFactory* to create the graph and in this case we\nspecify *inmemory* as the only parameter to tell JanusGraph that we want\nto use the all in memory storage model. We create our graph traversal\nobject *g* in just the same way as before.\n\n``` java\ngraph = JanusGraphFactory.open('inmemory')\ng = graph.traversal()\n```\n\nNote that the *open* command above is a shorthand form of the command\nshown below.\n\n``` java\ngraph = JanusGraphFactory.build().set(\"storage.backend\",\"inmemory\").open()\ng = graph.traversal()\n```\n\nNow that we have a graph instance created, just like with TinkerGraph,\nwe can query which features the graph supports. Earlier in the book in\nthe \\\"[Introducing TinkerGraph](#tgintro)\\\" section we looked at the\nfeatures offered by TinkerGraph. If we compare those features to what\nJanusGraph offers we can spot some key differences.\n\nWe can get the feature set back by calling the *features* method as\nshown below. The first thing that stands out is that the various\nfeatures that involve transactions are now set to *true* indicating that\nJanusGraph supports transactions. We will take a look at how to use\nthese transactional capabilities in the next section. Note that\n*Persistence* still shows as *false* as we are using the *inmemory*\nmode. Another thing to note is that, unlike with TinkerGraph,\n*UserSuppliedIds* is set to false, indicating that JanusGraph will\ncreate its own ID values and ignore any that we provide. The list is\nformatted in two columns to aid readability.\n\n::: formalpara-title\n**JanusGraph features**\n:::\n\n    graph.features()\n\n    > GraphFeatures                            > VertexPropertyFeatures\n    >-- Transactions: true                     >-- AddProperty: true\n    >-- Computer: true                         >-- RemoveProperty: true\n    >-- ConcurrentAccess: true                 >-- NumericIds: false\n    >-- ThreadedTransactions: true             >-- StringIds: true\n    >-- Persistence: false                     >-- UuidIds: false\n    > VariableFeatures                         >-- CustomIds: true\n    >-- Variables: true                        >-- AnyIds: false\n    >-- LongValues: true                       >-- UserSuppliedIds: false\n    >-- BooleanArrayValues: true               >-- Properties: true\n    >-- ByteArrayValues: true                  >-- LongValues: true\n    >-- DoubleArrayValues: true                >-- BooleanArrayValues: true\n    >-- FloatArrayValues: true                 >-- ByteArrayValues: true\n    >-- IntegerArrayValues: true               >-- DoubleArrayValues: true\n    >-- StringArrayValues: true                >-- FloatArrayValues: true\n    >-- LongArrayValues: true                  >-- IntegerArrayValues: true\n    >-- StringValues: true                     >-- StringArrayValues: true\n    >-- MapValues: true                        >-- LongArrayValues: true\n    >-- MixedListValues: false                 >-- StringValues: true\n    >-- SerializableValues: false              >-- MapValues: true\n    >-- UniformListValues: false               >-- MixedListValues: false\n    >-- BooleanValues: true                    >-- SerializableValues: false\n    >-- ByteValues: true                       >-- UniformListValues: false\n    >-- DoubleValues: true                     >-- BooleanValues: true\n    >-- FloatValues: true                      >-- ByteValues: true\n    >-- IntegerValues: true                    >-- DoubleValues: true\n    > VertexFeatures                           >-- FloatValues: true\n    >-- MetaProperties: true                   >-- IntegerValues: true\n    >-- AddVertices: true                      > EdgePropertyFeatures\n    >-- RemoveVertices: true                   >-- Properties: true\n    >-- MultiProperties: true                  >-- LongValues: true\n    >-- AddProperty: true                      >-- BooleanArrayValues: true\n    >-- RemoveProperty: true                   >-- ByteArrayValues: true\n    >-- NumericIds: true                       >-- DoubleArrayValues: true\n    >-- StringIds: false                       >-- FloatArrayValues: true\n    >-- UuidIds: false                         >-- IntegerArrayValues: true\n    >-- CustomIds: false                       >-- StringArrayValues: true\n    >-- AnyIds: false                          >-- LongArrayValues: true\n    >-- UserSuppliedIds: false                 >-- StringValues: true\n    > EdgeFeatures                             >-- MapValues: true\n    >-- RemoveEdges: true                      >-- MixedListValues: false\n    >-- AddEdges: true                         >-- SerializableValues: false\n    >-- AddProperty: true                      >-- UniformListValues: false\n    >-- RemoveProperty: true                   >-- BooleanValues: true\n    >-- NumericIds: false                      >-- ByteValues: true\n    >-- StringIds: false                       >-- DoubleValues: true\n    >-- UuidIds: false                         >-- FloatValues: true\n    >-- CustomIds: true                        >-- IntegerValues: true\n    >-- AnyIds: false\n    >-- UserSuppliedIds: false\n\nNow that we have an empty instance of an *inmemory* JanusGraph we can\nuse it from the Gremlin Console just as we did with TinkerGraph in our\nprior examples. Notice that the ID values that JanusGraph generates look\nquite different (as in they don't start at zero) from what we might\nexpect from TinkerGraph.\n\n``` java\ng.addV('person').property('name','Kelvin')\nv[4232]\n\ng.V().has('name','Kelvin')\nv[4232]\n\ng.V().has('name','Kelvin').id()\n4232\n```\n\nBefore we experiment too much more with JanusGraph there are three\nimportant subjects we need to discuss. One is transactions, another is\ndefining a schema and indexes for our vertices, edges and properties and\nthe third is the JanusGraph management API. We will cover each of these\nkey subjects in the following sections.",
            "children": []
          },
          {
            "level": "6.3.4",
            "title": "6.3.4. JanusGraph transactions {#janustrans}",
            "content": "So far we have been mainly using a TinkerGraph to perform our\nexperiments. TinkerGraph does not provide support for transactions. To\nbe fair, for the type of use cases where TinkerGraph is a good solution\nthis is not really an issue. However, a typical use case for JanusGraph\nmight be storing and mutating (updating) a very large graph persisted by\na back end store. In such an environment, support for transactions\nbecomes a lot more important. If you are used to other databases that\noffer transactional support, and as the JanusGraph documentation points\nout, you should not rely on JanusGraph transactions being fully Atomic,\nConsistent, Isolated and Durable (ACID). The amount of ACID support will\ndepend on the backend store being used. We will take a look at some of\nthe backend storage options in the \\\"[Choosing a persistent storage\ntechnology for JanusGraph](#janusstorage) section\\\".\n\n::: note\nThe official JanusGraph documentation includes detailed coverage of how\ntransactions are processed and techniques to use based on different\nusage scenarios. You will always find the latest version here:\n<http://docs.janusgraph.org/latest/tx.html>\n:::\n\nIn many cases, when using JanusGraph, you do not have to explicitly open\na new transaction. Instead, it will be opened for you as needed. Take a\nlook at the example below. A transaction is opened when *addVertex* is\ncalled and remains open until *commit* is called. Note also that in\norder to access the JanusGraph transaction capabilities, we use the *tx*\nmethod associated with our *graph* instance. The examples below assume\nyou have the Gremlin Console connected to a JanusGraph instance. The\n*inmemory* JanusGraph we created earlier will work fine for these\nexamples as transactions are supported even with *inmemory* JanusGraph\ninstances. Note that I have not shown the warning message that\nJanusGraph will display reminding us that we have not created an index\nfor our new property. We will explore how to create an index in the\n\\\"[JanusGraph indexes](#jaindexintro)\\\" section.\n\n``` java\n// Start a new transaction\nxyz = graph.addVertex()\n\nv[4344]\n\n// Add a property\nxyz.property('name', 'XYZ')\n\n// Commit the transaction\ngraph.tx().commit()\n\n// Check to make sure our new vertex was created\ng.V().has('name','XYZ')\n\nv[4344]\n```\n\nThe example above used the *graph* object to add a vertex. As discussed\nearlier in this book, the TinkerPop documentation recommends against\nthis. Instead it recommends adding vertices as part of a traversal as\nshown below. Note that the *graph* object is still used to *commit* the\ntransaction.\n\n``` java\n// Start a new transaction\ng.addV().property('name','XYZ')\n\nv[4216]\n\n// Commit the transaction\ngraph.tx().commit()\n\n// Check to make sure our new vertex was created\ng.V().has('name','XYZ')\n\nv[4216]\n```\n\nSometimes, it may be necessary to undo or *rollback* what we have done\nrather than continue and *commit* the transaction. This can be achieved\ncalling the *rollback* method as shown below.\n\n``` java\n// Start a new transaction\ng.addV().property('name','ABC')\n\n// Rollback the transaction\ngraph.tx().rollback()\n\n// Nothing will be returned\ng.V().has('code','ABC')\n```\n\nNote that the JanusGraph Management system, that is the subject of the\nnext section, has its own transaction system that is used when creating\nschema entries and otherwise configuring a graph.",
            "children": []
          },
          {
            "level": "6.3.5",
            "title": "6.3.5. The JanusGraph management API {#janusmgmt}",
            "content": "JanusGraph includes a management API that is made available via the\nManagementSystem class. You can use the management API to perform\nvarious important functions that include querying metadata about the\ngraph, defining the edge, vertex and property schema types and creating\nand updating the index.\n\nYou can create an instance of the ManagementSystem object using the\n*openManagement* method call as shown below.\n\n``` java\nmgmt = graph.openManagement()\n```\n\nIn the following sections we will show how to use the management API to\ncreate both a schema and an index for the *air-routes* graph and then\nload it. Before we do that we should take a few minutes to introduce the\nJanusGraph Management API. For the time being, assume we have created an\nin memory JanusGraph instance and loaded the *air-routes* graph into it\nbut have not defined an index or a schema. In this situation, JanusGraph\nwill give us the best defaults it can as it loads the graph for schema\ntypes.\n\nThe example below uses the Management API to get a list of all the\nvertex labels currently defined in graph.\n\n``` java\nmgmt.getVertexLabels()\n\nversion\nairport\ncountry\ncontinent\n```\n\nThis query similarly finds all of the currently defined edge labels.\n\n``` java\nmgmt.getRelationTypes(EdgeLabel.class)\n\nroute\ncontains\n```\n\nThis query will find all of the currently defined property keys. Note\nthat this list will include both vertex and edge property key names\n\n``` java\nmgmt.getRelationTypes(PropertyKey.class)\n\ndist\ncode\ntype\ndesc\ncountry\nlongest\ncity\nelev\nicao\nlon\nregion\nrunways\nlat\n```\n\nWe can query the cardinality of a property.\n\n``` java\nmgmt.getPropertyKey('code').cardinality()\n\nSINGLE\n```\n\nNote that as we have not so far defined a schema for the *air-routes*\ngraph. if we query the dataType for any of the already loaded properties\nwe will get back *Object.class* and by default that is what JanusGraph\nwill use in the absence of a schema having been defined.\n\n``` java\nmgmt.getPropertyKey('code').dataType()\n\nObject.class\n```\n\nWe can also test for the existence of a label definition in the graph.\n\n``` java\nmgmt.containsEdgeLabel('route')\n\ntrue\n\nmgmt.containsEdgeLabel('travels')\n\nfalse\n```",
            "children": []
          },
          {
            "level": "6.3.6",
            "title": "6.3.6. Creating a property with cardinality LIST {#cardlist}",
            "content": "Using the JanusGraph Management API it is possible to specify that a\nproperty can accept as list of values. This can be done by specifying a\ncardinality of *LIST* when the property key is created. Unless we\nexplicitly do this, whenever a property is created the cardinality will\ndefault to *SINGLE*. The code below can be run from a Gremlin Console\nconnected to a JanusGraph instance. A property key called *mylist* is\ncreated that can accept *String* values\\'. Before the key is created,\nits cardinality is specified as *LIST*. Always remember to *commit* the\nmanagement transaction when you are done making changes.\n\n``` java\nmgmt = graph.openManagement()\nmaker = mgmt.makePropertyKey('mylist')\nmaker.dataType(String.class)\nmaker.cardinality(LIST)\nmaker.make()\nmgmt.commit()\n```\n\nNote that the previous steps could be chained together as shown below.\n\n``` java\nmgmt = graph.openManagement()\nmgmt.makePropertyKey('mylist').dataType(String.class).cardinality(LIST).make()\nmgmt.commit()\n```\n\nNow that we have created a new key, when can use the Management API to\ncheck that its cardinality is indeed set to *LIST*. As always, whenever\nwe are done using the API we should close the transaction with a call to\n*commit*.\n\n``` java\nmgmt = graph.openManagement()\nmgmt.getPropertyKey('mylist').cardinality()\n\nLIST\n\nmgmt.commit()\n```\n\nWe can now create a new vertex and add some values using our new\n*mylist* property. Note that as our cardinality is *LIST* and not *SET*\nthat we can have duplicate values associated with our new property.\n\n``` java\nn = g.addV().property('mylist','one').property('mylist','two').next()\n\nv[3043568]\n\ng.V(n).property(list,'mylist','one')\ng.V(n).valueMap()\n\n// Duplicates allowed\n[mylist:[one,one,two]]\n\ngraph.tx().commit()\n```",
            "children": []
          },
          {
            "level": "6.3.7",
            "title": "6.3.7. Creating a property with cardinality SET {#cardset}",
            "content": "Using the JanusGraph Management API we can also specify that a property\ncan contain a *SET* of values. The difference between a cardinality of\n*SET* and a cardinality of *LIST* is that sets do not allow duplicate\nvalues.\n\nLet's create a new property key called *numbers* that will accept a set\nof integer values.\n\n``` java\nmgmt = graph.openManagement()\nmgmt.makePropertyKey('numbers').dataType(Integer.class).cardinality(SET).make()\n```\n\nAs before we can double check the cardinality of our new property.\n\n``` java\nmgmt.getPropertyKey('numbers').cardinality()\n\nSET\n```\n\nAlso as before once we are done making changes we need to commit our\nmanagement transaction.\n\n``` java\nmgmt.commit()\n```\n\nLet's now create a new vertex and do some testing to make sure that\nJanusGraph does enforce the rules we expect from a set. First of all we\ncreate a new vertex and put the values 1,2 and 3 into the property. This\nworks as expected.\n\n``` java\nn = g.addV().property('numbers',1).property('numbers',2).property('numbers',3).next()\n\nv[2846792]\n\ng.V(n).valueMap()\n\n[numbers:[1,2,3]]\n```\n\nNow let's try adding a second value of 2 and see what happens. As you\ncan see, our second 2 was not added to our set as there was already a 2\npresent.\n\n``` java\ng.V(n).property(set,'numbers',2)\ng.V(n).valueMap()\n\n// Duplicates not allowed\n[numbers:[1,2,3]]\n```\n\nLet's try adding a 4 instead. This works as there is no existing value\nof 4 already in the set.\n\n``` java\ng.V(n).property(set,'numbers',4)\ng.V(n).valueMap()\n\n[numbers:[1,2,3,4]]\n```\n\nFinally we can commit our graph transaction as we are all done creating\nproperties.\n\n``` java\ngraph.tx().commit()\n```",
            "children": []
          }
        ]
      },
      {
        "level": "6.4",
        "title": "6.4. Defining a JanusGraph schema for the air-routes graph {#janusschema}",
        "content": "You are not required to define the types and labels of your edges,\nvertices and properties ahead of time but it is strongly recommended\nthat you do so. If you do not define anything and load the air routes\ndata for example, it will work fine but JanusGraph will make assumptions\nabout various things. One thing it will do is default the type of all\nproperty keys to Java's *Object.class* which is not ideal if you want\nthe graph to help you enforce stricter type checking. Also, without a\nschema being defined, JanusGraph will default the usage constraint or\n*multiplicity* setting on all edges to *MULTI*. We will explain what\nthat means in a minute but in essence it means there is no restriction\nby default on how many edges with the same label that can exist between\ntwo vertices.\n\nYou can use the Management API do define your schema. You can add\nadditional property types at any time but once defined you cannot change\ntheir types. The only thing you can do once they have been created is to\nchange the names of the keys.\n\nA best practice when working with JanusGraph is to define your labels\nand property types before you load any data into the graph. As the graph\ngrows if you find you need to add additional property types or labels\nyou are allowed to do that.\n\nUsing the management API you can define the labels that will be used by\nvertices and edges. These values must be unique across the graph. You\ncan also define the type and cardinality (*SINGLE*, *LIST* or *SET*) of\neach property key and for edges you can specify the allowed usage of\nedges for any given label (*MULTI*, *MANY2ONE*, *ONE2MANY*, *ONE2ONE* or\n*SIMPLE*). Property key names must also be unique across the graph.\n\nBefore we can define a schema for our edge labels we need to understand\nwhat each option allows and decide on the best fit for each of our edge\ntypes.\n\nMULTI\n\n:   -   This is the default option if no multiplicity has been defined\n        for an edge with a given label. This setting permits multiple\n        edges of the same label between any pair of vertices. The\n        *air-routes* graph uses a multiplicity of *MULTI* for the\n        *routes* edges between airports.\n\nSIMPLE\n\n:   -   This setting permits at most one edge of a given label between\n        any pair of vertices. In the *air-routes* graph this setting is\n        used for the edges between a continent and an airport as an\n        airport cannot be in more than one continent. The same is used\n        for the edges between airports and countries.\n\nMANY2ONE\n\n:   -   This setting permits at most one outgoing edge of a given label\n        name from any vertex in the graph but places no constraint on\n        the number of incoming edges with this label.\n\nONE2MANY\n\n:   -   This setting permits at most one incoming edge of a given label\n        to any vertex in the graph but places no constraint on the\n        number of outgoing edges\n\nONE2ONE\n\n:   -   This setting permits at most one incoming and one outgoing edge\n        of a given label to and from any vertex in the graph.",
        "children": [
          {
            "level": "6.4.1",
            "title": "6.4.1. Defining edge labels and usage {#_defining_edge_labels_and_usage}",
            "content": "Let's look at how we can use the JanusGraph Management API to specify\nthe multiplicty for the *route* and *contains* edges used by the\n*air-routes* graph.\n\n``` java\n// Define edge labels and usage\nmgmt = graph.openManagement()\nmgmt.makeEdgeLabel('route').multiplicity(MULTI).make()\nmgmt.makeEdgeLabel('contains').multiplicity(SIMPLE).make()\nmgmt.commit()\n```",
            "children": []
          },
          {
            "level": "6.4.2",
            "title": "6.4.2. Defining vertex labels {#_defining_vertex_labels}",
            "content": "Now let's tell JanusGraph about the vertex labels that we are going to\nbe using. The *air-routes* graph has four different vertex types,\nnamely, *version*, *airport*, *country* and *continent* so we will\ncreate a label for each of those.\n\n``` java\n// Define vertex labels\nmgmt = graph.openManagement()\nmgmt.makeVertexLabel('version').make()\nmgmt.makeVertexLabel('airport').make()\nmgmt.makeVertexLabel('country').make()\nmgmt.makeVertexLabel('continent').make()\nmgmt.commit()\n```",
            "children": []
          },
          {
            "level": "6.4.3",
            "title": "6.4.3. Defining vertex property keys {#_defining_vertex_property_keys}",
            "content": "Next we need to define the property keys and data types that our\nvertices will be using. The *air-routes* graph only uses properties that\nhave a cardinality of *SINGLE*.\n\n``` java\n// Define vertex property keys\nmgmt = graph.openManagement()\nmgmt.makePropertyKey('code').dataType(String.class).cardinality(Cardinality.SINGLE).make()\nmgmt.makePropertyKey('icao').dataType(String.class).cardinality(Cardinality.SINGLE).make()\nmgmt.makePropertyKey('type').dataType(String.class).cardinality(Cardinality.SINGLE).make()\nmgmt.makePropertyKey('city').dataType(String.class).cardinality(Cardinality.SINGLE).make()\nmgmt.makePropertyKey('country').dataType(String.class).cardinality(Cardinality.SINGLE).make()\nmgmt.makePropertyKey('region').dataType(String.class).cardinality(Cardinality.SINGLE).make()\nmgmt.makePropertyKey('desc').dataType(String.class).cardinality(Cardinality.SINGLE).make()\nmgmt.makePropertyKey('runways').dataType(Integer.class).cardinality(Cardinality.SINGLE).make()\nmgmt.makePropertyKey('elev').dataType(Integer.class).cardinality(Cardinality.SINGLE).make()\nmgmt.makePropertyKey('lat').dataType(Double.class).cardinality(Cardinality.SINGLE).make()\nmgmt.makePropertyKey('lon').dataType(Double.class).cardinality(Cardinality.SINGLE).make()\nmgmt.commit()\n```",
            "children": []
          },
          {
            "level": "6.4.4",
            "title": "6.4.4. Defining edge property keys {#_defining_edge_property_keys}",
            "content": "We also need to define the property keys and data types that will be\nused on edges. Currently the *air-routes* graph only has one edge\nproperty, *dist* that is used to store the distance between two\nairports.\n\n``` java\n// Define edge property keys\nmgmt = graph.openManagement()\nmgmt.makePropertyKey('dist').dataType(Integer.class).cardinality(Cardinality.SINGLE).make()\nmgmt.commit()\n```\n\nNow that we have defined our schema, we can use the management API to\ndouble check that everything we just did looks correct. The snippet of\ncode below can be run from within the Gremlin console and will display\nthe property keys along with their data types and cardinality settings.\n\n``` java\n// Look at the properties\nmgmt = graph.openManagement()\ntypes = mgmt.getRelationTypes(PropertyKey.class)\ntypes.each{println \"$it\\t: \" +\n                    mgmt.getPropertyKey(\"$it\").dataType() +\n                    \" \" + mgmt.getPropertyKey(\"$it\").cardinality()}\n\nmgmt.commit()\n```\n\nThis is the output we should get back if our schema creation has\nsucceeded. Note that both the edge and vertex property keys are\ndisplayed.\n\n``` java\nlat     : class java.lang.Double SINGLE\nlon     : class java.lang.Double SINGLE\ndist    : class java.lang.Integer SINGLE\nlongest : class java.lang.Object SINGLE\ncode    : class java.lang.String SINGLE\nicao    : class java.lang.String SINGLE\ntype    : class java.lang.String SINGLE\ncity    : class java.lang.String SINGLE\ncountry : class java.lang.String SINGLE\nregion  : class java.lang.String SINGLE\ndesc    : class java.lang.String SINGLE\nrunways : class java.lang.Integer SINGLE\nelev    : class java.lang.Integer SINGLE\n```",
            "children": []
          },
          {
            "level": "6.4.5",
            "title": "6.4.5. Loading air-routes into a JanusGraph instance {#janusload}",
            "content": "Now that we know how to create a schema and an index for the\n*air-routes* graph we can use the same basic steps to load it into a\nJanusGraph instance that we used with TinkerGraph. Note that after\nloading the graph from the XML file we then call *commit* to finalize\nthe transaction.\n\n``` java\ngraph.io(graphml()).readGraph('air-routes.graphml')\ngraph.tx().commit()\n```\n\nNote that had we not defined a schema before loading the *air-routes*\ngraph that JanusGraph would have still created the vertices, edges and\nproperties but using default types and settings. A bit later we will\nlook at creating an index for the *air-routes* graph as well. It is\nstrongly recommended to create the index as well as the schema before\nloading the data but lets examine a few more things before we discuss\nhow to do that.\n\nUnlike TinkerGraph, JanusGraph does not, by default, guarantee to\nrespect user provided vertex and edge ID values. Instead it creates its\nown ID values as vertices and edges are added to the graph. You may have\nnoticed from earlier in the book or from the `air-routes.graphml` file\nif you happened to look in there, that the ID provided for Austin in the\nGraphML markup is 3. However, having loaded *air-routes* into JanusGraph\nif we query the ID for the Austin vertex we can see that it is no longer\n3. There is a setting that can be changed to force JanusGraph to honor\nuser provided ID values but it is not recommended this be used as it\nwill disable some other useful JanusGraph features. If you are\ninterested in learning more about this option this please refer to the\nJanusGraph documentation.\n\n``` java\ng.V().has('code','AUS').id()\n\n4240\n```\n\nHaving the graph system allocate its own ID values is not a big problem\nas we can always query the graph to get the ID but it is a reminder that\nyou should not get into the habit of relying on any user provided ID\nvalues as you work with graphs.\n\nIf necessary, as discussed earlier, we can always store important ID\nvalues in a variable for later use.\n\n``` java\nausid = g.V().has('code','AUS').id().next()\n\ng.V(ausid).values('city','desc','region').join(', ')\n\nAustin Bergstrom International Airport, Austin, US-TX\n```\n\nNote that property values are not necessarily returned in the order you\nrequested. That can be seen by looking at the example above. Our\n*values* step had *city* first but in fact the *desc* properties value\nwas returned first. Gremlin makes no guarantees that items will be\nreturned in the specific order you requested. They are returned in the\norder in which they are found during a traversal. You should not build\nin dependencies to your queries on the order things are returned in. If\nyou need a specific ordering you should sort or otherwise manipulate the\nreturned results of a query to match your needs.",
            "children": []
          }
        ]
      },
      {
        "level": "6.5",
        "title": "6.5. JanusGraph indexes {#jaindexintro}",
        "content": "JanusGraph supports two different types of indexing known as *graph\nindexes* and *vertex centric indexes* respectively. JanusGraph also\nsupports the use of *composite* and *mixed* indexes as well as the use\nof external indexing technologies. All of these concepts will be\ndiscussed and explained in the following sections. Using an index will\ngreatly improve performance of your graph queries and is something you\nshould get familiar with doing for any graphs that you create or manage.\nWhile in many cases use of an index is optional by default, I strongly\nrecommend that you view it as mandatory. The JanusGraph documentation\nprovides some fairly in depth coverage of indexing and can be read by\nvisiting the following URL:\n<http://docs.janusgraph.org/latest/indexes.html>",
        "children": [
          {
            "level": "6.5.1",
            "title": "6.5.1. Graph indexes {#graphindexes}",
            "content": "If you have used other types of database such as a relational database,\nyou may already be familiar with the concept of using an index to speed\nup random access to the entire database. When using JanusGraph that is\nthe role played by a *graph index*. The main job of a *graph index* is\nto get you to the starting point of your query as efficiently as\npossible without having to first search the entire graph to find the\nvertices or edges that you are looking for.\n\nYou should always establish a *graph index* for the property keys, or\ncombinations of keys, you will use regularly in your queries when\nworking with JanusGraph. In some situations you will also need to create\n*vertex centric indexes*, a subject we will discuss next, but most\nlikely this will be part of tuning the performance of your graph rather\nthan from the start. Conversely, You should plan on creating your *graph\nindexes* long with your initial graph schema. The simplest form of\n*graph index* is the composite index that we will see how to create and\nuse soon.",
            "children": []
          },
          {
            "level": "6.5.2",
            "title": "6.5.2. Vertex centric indexes {#vciintro}",
            "content": "A vertex centric index, as the name suggests is an index associated with\na vertex. These are typically used when the number of incident edges on\na given vertex becomes significantly large such that it can impact\nperformance. As mentioned above, it is likely that when you first create\nyour graph and graph schema that you will just create a set of *graph\nindexes* and only create *vertex centric indexes* as the need arises.",
            "children": []
          },
          {
            "level": "6.5.3",
            "title": "6.5.3. Introducing *composite* indexes {#compositeintro}",
            "content": "A composite index can be used to speed up queries where an exact match\nwith the value for given property key is sufficient. For example, the\nquery below could take advantage of a composite index as we are only\nlooking for exact matches where the value associated with the *city* key\nis the value *Paris*.\n\n``` java\ng.V().has('city','Paris')\n```\n\nA composite index can be defined to support queries that use more than\none key. For example we could create an index that can be used for\nqueries that look at the *city* and *country* property keys to help with\na query like the one below that will find the vertex for the airport in\nthe city of London in Ontario, Canada, but not the ones in London,\nEngland.\n\n``` java\ng.V().has('city','London').has('country','CA')\n```\n\nA composite index will not help if we want to get more sophisticated and\nlook for partial matches, use predicates other than *equal to* or use\nregular expressions in our queries. That is where the *mixed index*\ncomes in to play. So for example, a composite index would not help with\nthe following query that looks for airports in the *air-routes* graph\nwith more than five runways.\n\n``` java\ng.V().has('runways',gt(5))\n```",
            "children": []
          },
          {
            "level": "6.5.4",
            "title": "6.5.4. Introducing *mixed* indexes {#mixedintro}",
            "content": "As mentioned above, if the queries that you expect to be writing require\nmore than a simple test for equality then you will need to create what\nis referred to as a *mixed index*. Once you decide to create a mixed\nindex you will also need to configure an indexing backend such as Apache\nSolr or Elasticsearch. We will explore the use of mixed indexes in the\n\\\"[Using an external index with JanusGraph](#extindex)\\\" section.",
            "children": []
          },
          {
            "level": "6.5.5",
            "title": "6.5.5. Building a composite index to speed up exact match searching {#compositeindex}",
            "content": "It is strongly recommended that you create graph indexes for any\nproperty keys that you are likely to be using regularly in queries. An\nindex can greatly speed up searching a graph as without an index being\npresent JanusGraph has to search your entire graph each time you issue a\nquery looking for one or more specific properties. If you issue a query\nthat uses property keys that have not been indexed, the query will still\nwork but unless warnings have been turned off, JanusGraph will remind\nyou that you should consider creating an index to improve the\nperformance of your query.\n\n::: note\nYou should be aware that some graph systems running JanusGraph may have\ndisabled the ability to do a full graph search thus requiring that you\nalways have an index for any property keys that you use in your queries.\n:::\n\nTake a look at the example below. We issue a simple query looking for\nthe airport with a *code* property containing the value *LHR*. Because\nwe have not yet created an index for that property key, JanusGraph gives\nus a warning before also returning the vertex that we are looking for.\nIf the administrator of the JanusGraph system you are using has disabled\nthe ability to do full graph searches (a feature that is on by default\nbut can be disabled) the query below will fail with an error message.\n\n``` java\ng.V().has('code','LHR')\n\nWARN  org.janusgraph.graphdb.transaction.StandardJanusGraphTx\n    - Query requires iterating over all vertices [(code = LHR)].\n      For better performance, use indexes\n\nv[32904]\n```\n\nIf an index is present, before looking at the graph itself, JanusGraph\nwill look at the index. If the property key being searched for has been\nindexed, there will be entries in the index pointing to each occurrence\nof that property key within the graph. This enables JanusGraph to\ndirectly fetch those elements without having to search the entire graph\nlooking for them. With a large graph this can provide a very substantial\nperformance improvement. Depending on your indexing needs you may or may\nnot need to also use an external indexing technology such as Apache Solr\nor Elasticsearch. The subject of using an external index is discussed a\nbit later. First of all let's take a look at the types of index that you\ncan create that JanusGraph can manage by itself without needing help\nfrom an external index.\n\nUsing JanusGraph you can create and manipulate an index using the\nManagement API. The JanusGraph documentation strongly recommends that\nyou always make a call to *graph().tx().rollback()* before you start to\ncreate an index to make sure that no other transactions are currently\nactive.\n\nThe example below shows how to use the Management API to create a new\ncomposite index for the airport *code* property in the *air-routes*\ngraph.\n\n``` java\n// Make sure no other transactions are open\ngraph.tx().rollback()\n\n// Open a new management transaction\nmgmt = graph.openManagement()\n\n// Create a composite index for the code key for use with vertices\nidx = mgmt.buildIndex('airportIndex',Vertex.class)\niata = mgmt.getPropertyKey('code')\nidx.addKey(iata).buildCompositeIndex()\n\n// All done commit our changes to end the transaction\nmgmt.commit()\n```\n\nHaving created the index it is important to wait until it is available\nbefore trying to do anything else. We can do that by calling the\n*awaitGraphIndexStatus* method that is also part of the JanusGraph\nManagement API.\n\n``` java\nmgmt.awaitGraphIndexStatus(graph, 'airportIndex').\n     status(SchemaStatus.REGISTERED).call()\n```\n\nIf we already have data in the graph we now also need to tell JanusGraph\nto perform a re-index. Once again we use the Management API to do this\nbut this time using the *updateIndex* method.\n\n``` java\nmgmt = graph.openManagement()\nmgmt.updateIndex(mgmt.getGraphIndex(\"airportIndex\"), SchemaAction.REINDEX).get()\nmgmt.commit()\n```\n\nIf we re-run the same query we used earlier and got the warning about\nusing indexes from JanusGraph, this time we get the same result but\nwithout the warning. This tells us that JanusGraph was able to satisfy\nour query using the index that we just created.\n\n``` java\ng.V().has('code','LHR')\n\nv[32904]\n```\n\nWe can also use the JanusGraph Management API to query information about\nthe index that we just defined. As you can see below, as we have only\ncreated one index so far, that is all that is returned.\n\n``` java\nmgmt = graph.openManagement()\n\n// What indexes are defined?\nv_idxes = mgmt.getGraphIndexes(Vertex.class)\n\nairportIndex\n\n// Print the key names they are associated with\nv_idxes.each {println it.getFieldKeys()}\n\n[code]\n\nmgmt.commit()\n```\n\nIt is also possible to define an index that will support a query\ncontaining more than one key. For example we might want to create an\nindex that would be used to help with queries like the one below which\nis essentially a query looking for any vertex that has a *city* property\nwith a value of *London* AND a country property with a value of *CA*.\n\n``` java\ng.V().has('city','London').has('country','CA')\n```\n\nWe could define an index to support such a query using the code that\nfollows. Note that the only differences from the prior example are that\nwe add two keys rather than one to the index. Note also that the\n*addKey* methods are called with the *country* key coming before the\n*city* key which is the reverse order to which we expect the Gremlin\nquery to use the keys.\n\n``` java\n// Make sure no other transactions are active\ngraph.tx().rollback()\n\n// Start a new management transaction\nmgmt = graph.openManagement()\n\n// Find the property keys that we need to index\ncity = mgmt.getPropertyKey('city')\ncountry = mgmt.getPropertyKey('country')\n\n// Create a new index and add our keys\nindex = mgmt.buildIndex('byCityAndCountry', Vertex.class)\nindex.addKey(country).addKey(city).buildCompositeIndex()\n\n// All done\nmgmt.commit()\n\n// Wait for the index to be active\nmgmt.awaitGraphIndexStatus(graph, 'byCityAndCountry').call()\n\n// Force a re-index\nmgmt = graph.openManagement()\nmgmt.updateIndex(mgmt.getGraphIndex(\"byCityAndCountry\"), SchemaAction.REINDEX).get()\nmgmt.commit()\n```\n\nWe can use the Gremlin *profile* step to verify that JanusGraph is\nindeed now using our new index. I have truncated some of the output so\nit will fit on the page but you can see from the output that the query\ndid indeed use our new index.\n\n``` java\ng.V().has('city','London').has('country','CA').profile()\n```\n\nHere is the output returned by the query.\n\n``` console\nTraversal Metrics\nStep                                              Traversers  Time (ms)\n========================================================================\nJanusGraphStep([],[city.eq(London), country.eq(...      1          1.036\n    \\_condition=(city = London AND country = CA)\n    \\_isFitted=true\n    \\_query=multiKSQ[1]@2147483647\n    \\_index=byCityAndCountry\n    \\_orders=[]\n    \\_isOrdered=true\n  optimization                                                     0.741\n  backend-query                                         1          0.085\n    \\_query=byCityAndCountry:multiKSQ[1]@2147483647\n                                            >TOTAL      -          1.036\n```",
            "children": []
          },
          {
            "level": "6.5.6",
            "title": "6.5.6. A script to automate schema creation, indexing and graph loading {#_a_script_to_automate_schema_creation_indexing_and_graph_loading}",
            "content": "In the sample code directory of my GitHub project for this book you will\nfind a small Gremlin (Groovy) script in a file called\n*janusgraph-inmemory.groovy*. You can get to the file by visiting this\nURL:\n<https://github.com/krlawrence/graph/blob/main/sample-code/janus-inmemory.groovy>\n\nThe script will create an *inmemory* JanusGraph instance, define the\nschema, create several indexes and load the `air-routes.graphml` file so\nthat you can try some queries using the Gremlin Console. You might find\nthat a good way to experiment with the concepts that we have covered in\nthis discussion of JanusGraph so far.",
            "children": []
          }
        ]
      },
      {
        "level": "6.6",
        "title": "6.6. Additional JanusGraph text search predicates {#janpred}",
        "content": "We have already looked, in the \\\"[Testing values and ranges of\nvalues](#tranges) section, at the predicates TinkerPop defines such as\n*neq*, *gte* and *lte*. JanusGraph offers an additional set of\npredicates that can be used when looking for specific patterns within\ntext in a graph.\n\nThe methods that include the word *Contains* in their name look for\nwhole words that match the specified search pattern. The methods that do\nnot include *Contains* in the name look at the entire string being\ninspected for matches.\n\nThe table below summarizes the additional text search predicates that\nJanusGraph provides.\n\n+-------------+--------------------------------------------------------+\n| t           | True if a whole word matches the search string         |\n| extContains | provided.                                              |\n+-------------+--------------------------------------------------------+\n| textCon     | True if at least one word starts with the search       |\n| tainsPrefix | string provided.                                       |\n+-------------+--------------------------------------------------------+\n| textCo      | True if at least one word matches the regular          |\n| ntainsRegex | expression provided.                                   |\n+-------------+--------------------------------------------------------+\n| textCo      | True if a word matches the fuzzy search text provided. |\n| ntainsFuzzy |                                                        |\n+-------------+--------------------------------------------------------+\n| textPrefix  | True if the string being inspected starts with the     |\n|             | search text.                                           |\n+-------------+--------------------------------------------------------+\n| textRegex   | True if the string being inspected matches the regular |\n|             | expression provided.                                   |\n+-------------+--------------------------------------------------------+\n| textFuzzy   | True if the string being inspected matches the fuzzy   |\n|             | search text.                                           |\n+-------------+--------------------------------------------------------+\n\n: Additional JanusGraph text search predicates\n\nLet's take a look at each of these predicates and what they offer with\nexamples of each being used. First off, the query below will find any\nvertex that has a *desc* (description) property that contains the word\n*\\\"Dallas\\\"*. Note that this matches *Dallas* followed by any word break\ncharacter such as a space or a forward slash.",
        "children": [
          {
            "level": "6.6.1",
            "title": "6.6.1. Text comparison predicates {#_text_comparison_predicates}",
            "content": "The simplest of the search predicates allow you to specify an exact\nmatch that string must be present either as a whole word (complete word\nmatch) or as part of the entire text being examined. These searches are\n**not** case sensitive.\n\n``` java\ng.V().has('desc',textContains(\"Dallas\")).values('desc')\n```\n\nHere is what the query should return.\n\n``` console\nDallas/Fort Worth International Airport\nDallas Love Field\n```\n\nThe word being searched for using *textContains* does not have to be the\nfirst word within the string. It just has to exist as a whole word. The\nquery below looks for the word *\\\"Love\\\"* appearing anywhere in the\n*desc* property.\n\n``` java\ng.V().has('desc',textContains(\"Love\")).values('desc')\n```\n\nHere is what the query returns.\n\n``` console\nDallas Love Field\nErnest A. Love Field\n```\n\nIn this example the word *fort* is found no matter where it occurs in\nthe *city* name so long as it occurs as a standalone word.\n\n``` java\ng.V().has('city',textContains(\"fort\")).values('city')\n```\n\nAs you can see in the results below *Vieux Fort* was found as well as\nall of the cities with names that start with *Fort*.\n\n``` console\nFort Myers           Fort Worth\nFort-de-France       Fort McMurray\nFort Lauderdale      Fort Sandeman\nFort Wayne           Fort Smith\nFort St.John         Fort Yukon\nFort Nelson          Fort Albany\nFort Chipewyan       Fort Hood/Killeen\nFort Mcpherson       Vieux Fort\nFort Smith           Fort Good Hope\nFort Severn          Fort Frances\nFort Simpson         Fort Hope\nFort Leonard Wood    Fort Dodge\n```\n\nThe query below does not match any whole word in any description\nanywhere in the graph so no results will be returned.\n\n``` java\n// Matches no whole word so no results\ng.V().has('desc',textContains(\"Dalla\")).values('desc')\n```\n\nIf we use *textContainsPrefix* instead of *textContains*, the search\nwill look for whole words that start with the specified text and we will\nget some results. Take a look at the next query and the results it\ngenerates.\n\n::: tip\nSearches using *textContains* and *textContainsPrefix* are **not** case\nsensitive.\n:::\n\n``` java\ng.V().has('desc',textContainsPrefix(\"dalla\")).values('desc')\n```\n\nHere is what the query returns. This time we got some results as\n*Dallas* starts with the characters *dalla*. Again, remember these are\ncase insensitive queries.\n\n``` console\nDallas/Fort Worth International Airport\nDallas Love Field\n```\n\nWe could use a *textContains* query to find airports that have the word\n*Regional* as part of their description. An example of such a query is\ngiven below. Only the first five matching airport descriptions found are\nreturned.\n\n``` java\ng.V().has('desc',textContains('Regional')).values('desc').limit(5)\n```\n\nHere are the descriptions returned by the query.\n\n``` console\nRapid City Regional Airport\nAbilene Regional Airport\nGrand Junction Regional Airport\nSan Luis County Regional Airport\nLiberal Mid-America Regional Airport\n```\n\nWe could adjust the regional airport query we did above to use\n*textContainsPrefix* if we wanted to be a bit less specific and look for\nany airport with *Reg* at the start of any word in its description.\n\n``` java\ng.V().has('desc',textContainsPrefix('Reg')).values('desc').limit(5)\n```\n\nWe still get the same five results back.\n\n``` console\nRapid City Regional Airport\nAbilene Regional Airport\nGrand Junction Regional Airport\nSan Luis County Regional Airport\nLiberal Mid-America Regional Airport\n```\n\nThe *textPrefix* predicate will look at the entire string being\ninspected and compare it to the string you provide and only return a\nresult if the string starts with the specified pattern. So in this case\nwe look at just the start of the whole string and not at individual\nwords within it. The query below looks for any cities whose name starts\nwith the characters *Los*.\n\n``` java\ng.V().has('city',textPrefix('Los')).values('city')\n```\n\n::: tip\nSearches using *textPrefix* **are** case sensitive.\n:::\n\nThis is what we get back from the query.\n\n``` console\nLos Alamos\nLos Angeles\nLos Mochis\nLosuia\n```\n\nNotice how the query did not find the city of *Chapelco/San Martin de\nlos Andes* as in this case the *Los* is not at the start of the name. If\nwe did want to also have that city discovered we could use\n*textContainsPrefix* instead as shown below.\n\n``` java\ng.V().has('city',textContainsPrefix('Los')).values('city')\n```\n\nAs you can see this time we also found *Chapelco/San Martin de los Ande*\nand it is part of the results returned. As before the case of the search\nterm is ignored.\n\n``` console\nLos Alamos\nChapelco/San Martin de los Andes\nLos Angeles\nLos Mochis\nLosuia\n```",
            "children": []
          },
          {
            "level": "6.6.2",
            "title": "6.6.2. Regular expression predicates {#_regular_expression_predicates}",
            "content": "The JanusGraph regular expression predicates recognize the syntax\ndefined as part of the Java 1.8 Pattern class that is documented at\n<https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html>.\nThe Java regular expression syntax may be different than the one you are\nused to so it is worth taking a few minutes to study the documentation\nat that URL.\n\nThe query below uses a *textContainsRegex* predicate to search for any\ncity name that contains a word starting with *for*, while ignoring case.\n\n``` java\ng.V().has('city',textContainsRegex(\"(?i)for.*\")).values('city')\n```\n\nNotice how names that start with *For* such as *Fort Myers* as well as\ncity names containing words that start with the text *For* in a\nsubsequent word are found. For example *La Fortuna* and *View Fort* are\nalso found.\n\n``` console\nFort Myers                Fort Worth\nLa Fortuna/San Carlos     Fort McMurray\nFort-de-France            Fort Sandeman\nFort Lauderdale           Fortaleza\nFort Wayne                Fort Smith\nJerez de la Forntera      Fort Yukon\nFort St.John              Fort Albany\nFort Nelson               Fort Hood/Killeen\nFort Chipewyan            Vieux Fort\nFormosa                   Fort Good Hope\nFort Mcpherson            Grand Forks\nFort Smith                Fort Frances\nJuiz de Fora              Fort Hope\nFort Severn               Fort Dodge\nFort Simpson              Fort Leonard Wood\n```\n\nThe query below shows another way of searching for the word *dallas* at\nthe start of a string of text while ignoring case. This time we use a\nvery simple regular expression. Of course, in reality, this yields the\nsame result that we could achieve by simply using *textContainsPrefix*.\n\n``` java\n// Matches dallas ignoring case\ng.V().has('city',textRegex(\"(?i)dallas\")).valueMap('code','city')\n```\n\nAs we can see the query worked as expected.\n\n``` console\n[code:[DFW],city:[Dallas]]\n[code:[DAL],city:[Dallas]]\n```\n\nIf we wanted to expand our search a bit we could modify the regular\nexpression, as shown below, to find an city name that starts with the\ncharacters *dal*.\n\n``` java\n// Matches any city that contains dal followed by anything, ignoring case.\ng.V().has('city',textRegex('(?i)dal.*')).values('city')\n```\n\nThis time we get some additional cities back.\n\n``` console\nDallas\nDallas\nDalcahue\nDalat\nDalaman\nDalanzadgad\nDalian\n```\n\nIf we instead wanted to get more specific we could again adjust the\nregular expression. This time we look for any city name that starts with\nany three characters followed by the characters *cah* followed by any\nnumber of other characters.\n\n``` java\n// Anything that matches 3 characters followed by 'cah' followed by anything.\ng.V().has('city',textRegex(\".{3}cah.*\")).values('city')\n```\n\nUsing our modified, and much more specific search pattern we find just\none city that matches the pattern.\n\n``` console\nDalcahue\n```\n\nHere is another example that looks for a city name that starts with any\nthree characters followed by either *cah* or *anz* followed by any\nnumber of characters.\n\n``` java\ng.V().has('city',textRegex(\".{3}(cah|anz).*\")).values('city')\n```\n\nHere is what we get back using this regular expression.\n\n``` console\nDalcahue\nDalanzadgad\n```\n\nHere is another query that uses a regular expression to find airports\nthat have a region code that starts with the characters *US-* followed\nby any of *O*, *R* or *D* followed by any number of characters.\n\n``` java\ng.V().has('region',textRegex(\"US-[ORD].*\")).\n      local(values('code','region').fold()).fold()\n```\n\nHere is what this query returns.\n\n``` java\n[[PVD,US-RI],[LMT,US-OR],[SWO,US-OK],[PDX,US-OR],[EUG,US-OR],[MFR,US-OR],[TOL,US-OH],[PDT,US-OR],[CMH,US-OH],[OTH,US-OR],[YNG,US-OH],[OKC,US-OK],[DAY,US-OH],[LAW,US-OK],[LCK,US-OH],[LUK,US-OH],[RDM,US-OR],[DCA,US-DC],[CLE,US-OH],[TUL,US-OK],[CAK,US-OH],[ILG,US-DE],[BID,US-RI]]\n```\n\nHere is a slightly more complicated query that uses a regular\nexpression. The pattern matches any airport description containing a\nword that starts with any character followed by *al*, optionally\nfollowed by another *l* and then followed by any character that is not\none of *\\\"s,k,e,i\\\"* ignoring case.\n\n``` java\ng.V().has('desc',textContainsRegex(\"(?i).all?[^(s|k|e|i)]\")).values('desc')\n```\n\nHere is the list of airport descriptions that the query returns.\n\n``` console\nDinard-Pleurtuit-Saint-Malo Airport\nWalla Walla Regional Airport\nSalt Lake City\nPalm Springs International Airport\nEduardo Falla Solano Airport\nPalm Beach International Airport\nSalt Cay Airport\nMelville Hall Airport\nHall Beach Airport\n```",
            "children": []
          },
          {
            "level": "6.6.3",
            "title": "6.6.3. Fuzzy search predicates {#_fuzzy_search_predicates}",
            "content": "These predicates use the [Levenshtein\ndistance](https://en.wikipedia.org/wiki/Levenshtein_distance) method to\ndecide if a piece of text is *close enough* to the pattern being looked\nfor. This is based on assessing how many characterss would have to\nchange in the pattern word to achieve a match in the text being\ninspected. For example *pall* would match *palm*, *paul* and *palm*.\n\nThe query below uses a fuzzy sort to find any words that are close to\nthe word *pall*.\n\n``` java\ng.V().has('desc',textContainsFuzzy(\"pall\")).values('desc')\n```\n\nHere are the results from running the query. You can see that airport\ndescriptions that contain the whole words *Paul*, *Palm* and *Hall* have\nbeen found.\n\n``` console\nMinneapolis-St.Paul International Airport\nPalm Beach International Airport\nPalm Springs International Airport\nJohn Paul II International Airport Krakow-Balice Airport\nMelville Hall Airport\nHall Beach Airport\nSt Paul Island Airport\n```\n\nThis query uses *textFuzzy* to find cities whose names are close to\nDublin.\n\n``` java\ng.V().has('city',textFuzzy('Dublin')).values('city')\n```\n\nHere is what the query returns. You can see that the method used by\n*fuzzy* searches is more than just single character replacement. Note\nthat not all of the city names returned are of the same length. To\nbetter understand the *fuzzy search* algorithm it is recommended to look\nat the Wikipedia page mentioned above.\n\n``` console\nYulin\nHubli\nDublin\nLublin\nDubois\nDubai\n```",
            "children": []
          }
        ]
      },
      {
        "level": "6.7",
        "title": "6.7. The JanusGraph GeoSpatial API {#janusgeo}",
        "content": "Earlier, in the \\\"[Using latitude, longitude and geographical region in\nqueries](#latlonmanual)\\\" section, I provided a few examples of how we\ncould write some queries that took advantage of the fact that the\nairports in the *air-routes* graph include their latitude and longitude\namong their properties. When working with JanusGraph there are some\nadditional built in capabilities that we can take advantage of.\n\n::: note\nThe official JanusGraph API documentation is a good place to read up on\nthe GeoShape class and related classes. That documentation can always be\nfound by starting here: <http://docs.janusgraph.org/latest/javadoc.html>\n:::\n\nThe example below shows one way that we could use the GeoSpatial API to\nfind airports within a circle having a 100 kilometer radius with London\nHeathrow (LHR) at the center of that circle. A key class to be aware of\nis the *Geoshape* class. It can be used to create areas that we can use\nwhen testing for other coordinates falling within that area.\n\nNotice in the code below that for each airport in the graph a *point* is\ncreated based on the latitude and longitude of that airport. A test is\nthen performed to see if that *point* lies within our 100km circle. Only\nairports that do are passed on to the *valueMap* step. Notice also how a\n*map* step is used so that we can do some calculations inside of a\nclosure while creating the *point*.\n\n``` java\n// Get the lat/lon for LHR\nlon = g.V().has('code','LHR').values('lon').next()\nlat = g.V().has('code','LHR').values('lat').next()\n\n// Create a 100km radius circle with LHR at the center\nboundary = Geoshape.circle(lat,lon,100)\n\n// Find other airports that are within that circle\ng.V().hasLabel('airport').\n      where(map{a=it.get().value('lat');\n                b=it.get().value('lon');\n                Geoshape.point(a,b).within(boundary)}.is(true)).\n                valueMap('code','lat','lon')\n```\n\nBelow is the output that you might bet back from running the above\nquery. The query can be run as-is from the Gremlin Console connected to\na JanusGraph instance containing the *air-routes* graph.\n\n``` java\n[code:[LGW],lon:[-0.190277993679047],lat:[51.1481018066406]]\n[code:[BZZ],lon:[-1.58361995220184],lat:[51.749964]]\n[code:[STN],lon:[0.234999999404],lat:[51.8849983215]]\n[code:[LTN],lon:[-0.368333011865616],lat:[51.874698638916]]\n[code:[SOU],lon:[-1.35679996013641],lat:[50.9502983093262]]\n[code:[LHR],lon:[-0.461941003799],lat:[51.4706001282]]\n[code:[LCY],lon:[0.055278],lat:[51.505278]]\n[code:[SEN],lon:[0.695555984973907],lat:[51.5713996887207]]\n```\n\nThere are many ways we could optimize our query to avoid creating a\n*point* for every single airport in the graph. In this particular case,\nwe might decide, for example, that we are only interested in airports in\nEngland. To do this we could add a check to our query to make sure that\nonly airports with a region code of *GB-ENG* are tested. Here is the\nquery modified with that check added.\n\n``` java\n// Find other airports that within 100km of LHR\ng.V().has('airport','region','GB-ENG').\n      where(map{a=it.get().value('lat');\n                b=it.get().value('lon');\n                Geoshape.point(a,b).within(boundary)}.is(true)).\n                valueMap('code','lat','lon')\n```\n\nHere is the output from running the query again. Other than the order in\nwhich results were returned being different we got the same results.\nHowever this query is more efficient as it is able to take advantage of\nthe index that we created earlier for the *region* property to filter\nout all airports not in the region *GB-ENG*.\n\n``` java\n[code:[LGW],lon:[-0.190277993679047],lat:[51.1481018066406]]\n[code:[LHR],lon:[-0.461941003799],lat:[51.4706001282]]\n[code:[LCY],lon:[0.055278],lat:[51.505278]]\n[code:[STN],lon:[0.234999999404],lat:[51.8849983215]]\n[code:[LTN],lon:[-0.368333011865616],lat:[51.874698638916]]\n[code:[SOU],lon:[-1.35679996013641],lat:[50.9502983093262]]\n[code:[SEN],lon:[0.695555984973907],lat:[51.5713996887207]]\n[code:[BZZ],lon:[-1.58361995220184],lat:[51.749964]]\n```\n\nUsing the GeoSpatial API we can create shapes representing different\ngeographic regions and compare them. The example below shows how to\ncreate a 100km circle with Longdon heathrow (LHR) at the center and a\nsecond circle with Manchester (MAN) at the center. The *intersect*\nmethod is then used to see if any points appear in both circles.\n\n``` java\n// Create a 100km radius circle with LHR at the center\n\nlon_lhr = g.V().has('code','LHR').values('lon').next()\nlat_lhr = g.V().has('code','LHR').values('lat').next()\n\nlhr_circ = Geoshape.circle(lat_lhr,lon_lhr,100)\n\n// Create a 100km radius circle with MAN at the center\n\nlat_man = g.V().has('code','MAN').values('lat').next()\nlon_man = g.V().has('code','MAN').values('lon').next()\n\nman_circ = Geoshape.circle(lat_man,lon_man,100)\n\n// Do any points in the two circles intersect?\n\nlhr_circ.intersect(man_circ)\n\nfalse\n```\n\nAs you can see the test returns *false* indicating that there are no\nshared points. To prove that the tests work when points do overlap,\nlet's create another 100km circle with Liverpool (LPL) in the middle and\ncompare that one with the Manchester circle.\n\n``` java\n// Create a 100km radius circle with LPL at the center\n\nlat_lpl = g.V().has('code','LPL').values('lat').next()\nlon_lpl = g.V().has('code','LPL').values('lon').next()\n\nlpl_circ = Geoshape.circle(lat_lpl,lon_lpl,100)\n\n// Do any points in the two circles intersect?\n\nlpl_circ.intersect(man_circ)\n\ntrue\n```\n\nThe *Geoshape* class provides a number of useful methods. If we wanted\nto verify that the latitude and longitude values we got back from the\nLHR vertex were valid, meaning they do indeed represent a point\nsomewhere on Earth, we could do so as follows.\n\n``` java\nGeoshape.isValidCoordinate(lat,lon)\n\ntrue\n```\n\nEarlier, in the \\\"[Using latitude, longitude and geographical region in\nqueries](#latlonmanual)\\\" section I demonstrated the query below. The\nquery finds all airports within a conceptual rectangle around the London\nHeathrow (LHR) airport. The rectangle is defined by adding or\nsubtracting one degree of latitude and longitude to the opposite\ndiagonals with LHR at the center.\n\n``` java\nlat = g.V().has('code','LHR').values('lat').next()\nlon = g.V().has('code','LHR').values('lon').next()\n\ng.V().hasLabel('airport').has('lon',between(lon-1,lon+1)).\n                          has('lat',between(lat-1,lat+1)).\n                          valueMap('code','lat','lon')\n```\n\nHere is the output that query produced.\n\n``` java\n[code:[LHR],lon:[-0.461941003799],lat:[51.4706001282]]\n[code:[LGW],lon:[-0.190277993679047],lat:[51.1481018066406]]\n[code:[LCY],lon:[0.055278],lat:[51.505278]]\n[code:[STN],lon:[0.234999999404],lat:[51.8849983215]]\n[code:[LTN],lon:[-0.368333011865616],lat:[51.874698638916]]\n[code:[SOU],lon:[-1.35679996013641],lat:[50.9502983093262]]\n```\n\nWe can use the JanusGraph Geoshape class to rewrite the query as shown\nbelow. Instead of using a *circle* this time we will create a *box*\nrepresenting a geographical region around London Heathrow (LHR).\n\n``` java\n// Define a box around LHR with opposite diagonal corners\n// each one degree from LHR.\nbox = Geoshape.box(lat_lhr-1,lon_lhr-1,lat_lhr+1,lon_lhr+1)\n\n// Find other airports that within the box\ng.V().has('airport','region','GB-ENG').\n      where(map{a=it.get().value('lat');\n                b=it.get().value('lon');\n                Geoshape.point(a,b).within(box)}.is(true)).\n                valueMap('code','lat','lon')\n```\n\nThe results from running our new query are shown below. As you can see\nthe same airports were found.\n\n``` java\n[code:[LGW],lon:[-0.190277993679047],lat:[51.1481018066406]]\n[code:[LHR],lon:[-0.461941003799],lat:[51.4706001282]]\n[code:[LCY],lon:[0.055278],lat:[51.505278]]\n[code:[STN],lon:[0.234999999404],lat:[51.8849983215]]\n[code:[LTN],lon:[-0.368333011865616],lat:[51.874698638916]]\n[code:[SOU],lon:[-1.35679996013641],lat:[50.9502983093262]]\n```\n\nI have just shown a few examples of the many things that you can do\nusing the JanusGraph GeoSpatial API. If this is an area that interests\nyou I recommend reading the API documentation for the *Geoshape* and\nrelated classes.",
        "children": []
      },
      {
        "level": "6.8",
        "title": "6.8. Choosing a persistent storage technology for JanusGraph {#janusstorage}",
        "content": "So far we have concentrated on examples where the graph data resides in\nthe memory of the computer system. The only form of persistence we have\nso far looked at is saving an entire graph as JSON or XML and reading it\nback into memory at a future date. Clearly, for many production systems,\nwe need a better story for data persistence. As delivered, JanusGraph\nsupports a number of different back end databases that can be used to\npersist graph data. A bit later, in the \\\"[Using Docker to experiment\nwith Cassandra and JanusGraph](#dockercass)\\\" section, we will explore a\nsimple way to experiment with one of these database options.\n\nOnce JanusGraph has been downloaded and installed (unzipped) you will\nfind a directory called /conf below the directory where JanusGraph was\ninstalled. In this directory you will find a number of Java properties\nfiles that can be used to connect JanusGraph to different back end data\nstores. Depending upon your configuration these property files may work\nunchanged or may need to be edited. Each property file has detailed\ncomments that explain what the various setting do.\n\n::: note\nThe official JanusGraph documentation provides detailed configuration\ninformation for each of the currently supported back end stores.\n<http://docs.janusgraph.org/latest/storage-backends.html>\n:::\n\nLet's now take a brief look at some of the persistent storage options\navailable to us when using JanusGraph.",
        "children": [
          {
            "level": "6.8.1",
            "title": "6.8.1. Oracle Berkley DB {#berkleyintro}",
            "content": "Oracle Berkely DB may be a good choice if your application runs on a\nsingle machine but needs a persistent store. All data is persisted to\nthe same local disk of the system where your application runs. Berkley\nDB is popular with developers who want to develop and test graph\napplications on a single machine using more than an in-memory back end.\nAssuming you are developing an application using Java or Groovy, the\nJava version of Berkley DB, known as Berkley DB Java Edition, is\nprovided as a set of libraries that you embed with your application and\nrun using the same JVM as your application. Because Berkley DB JE runs\non a single machine, the amount of graph data that you can store will\ndepend on the size of the disk available on that machine.\n\nFor production systems that only need a modest sized graph this may also\nbe a valid choice. If your application is likely to generate very large\ngraphs in excess of 100 million vertices you will probably need to\ninvestigate some of the other, multi node cluster capable, storage\noptions that we will discuss next. Berkley DB is probably not a good\nchoice if you need multiple users to be accessing and changing the graph\nconcurrently.\n\nThe JanusGraph */conf* directory contains a file called\n*janusgraph-berkleyje.properties* that can be used to create a new\ninstance of a JanusGraph backed by Berkley as follows.\n\n``` java\ngraph = JanusGraphFactory.open(\"conf/janusgraph-berkleyje.properties\")\n```\n\nAlternatively, as there is not much to configure when using Berkley DB,\nyou could decide to pass the properties directly to JanusGraph as\nfollows. The second *set* command specifies where your data will be\nstored on the disk.\n\n``` java\ngraph = JanusGraphFactory.build().\n          set(\"storage.backend\",\"berkleyje\").\n          set(\"storage.directory\",\"/mydata\").\n          open()\n```\n\nOracle Berkley DB can be downloaded from the Oracle web site from the\nfollowing URL.\n<http://www.oracle.com/technetwork/database/database-technologies/berkeleydb/overview/index.html>",
            "children": []
          },
          {
            "level": "6.8.2",
            "title": "6.8.2. Apache Cassandra {#cassandraintro}",
            "content": "If a single machine storage solution, such as that offered by Berkley\nDB, is insufficient for your needs then there are several other choices\nthat offer horizontal scaling and high availability. Apache Cassandra is\none such choice. Which storage solution you chose will depend on many\nfactors that go beyond the scope of this book. However, if you already\nhave Apache Cassandra deployed in your organization or data center and\nhave people that know how to manage and configure it, it might be the\nright choice for your JanusGraph back end storage needs. Like any big\ndata system Apache Cassandra requires tuning and maintenance to get the\nbest performance for your workload type. That potentially requires\ndeveloping new skills and doing some experimentation. Apache Cassandra\nis written in Java and it is important to keep a careful eye on the\namount of garbage collection taking place within the virtual machines\nthat are running your Cassandra instances. Excessive garbage collection\ncan significantly impact your graph's performance. There are many ways\nthat Cassandra can be deployed ranging from a single instance on your\nlocal machine to a multi node cluster. How you deploy it will depend on\nyour scalability and redundancy needs. Note that Cassandra, like Berkley\nDB can, if needed, also run in embedded mode.\n\n::: note\nFor detailed configuration information you should refer to the official\nJanusGraph documentation located at\n<http://docs.janusgraph.org/latest/storage-backends.html>.\n:::\n\nA bit later, in the \\\"[Using Docker to experiment with Cassandra and\nJanusGraph](#dockercass)\\\" section, we will take a look at deploying a\nsingle node instance of Cassandra using Docker containers which provides\na nice environment for development and testing.\n\nThe JanusGraph */conf* directory contains several property files that\ncan be used when working with Apache Cassandra. Which one you use will\ndepend on the way you chose to deploy Cassandra. Later on we will look\nat the additional steps you need to take to configure your environment\nwhen external indexes are used. However, if you were using Cassandra\nwithout an external index being needed you might connect to it as\nfollows.\n\n``` java\ngraph = JanusGraphFactory.open(\"conf/janusgraph-cassandra.properties\")\n```\n\nYou will need to edit the properties file to contain the host name and\nIP address of your Cassandra system. By default the properties file is\nconfigured for use with *localhost*.\n\nApache Cassandra can be downloaded from the Apache web site from the\nfollowing URL. <http://cassandra.apache.org/>",
            "children": []
          },
          {
            "level": "6.8.3",
            "title": "6.8.3. ScyllaDB {#scyllaintro}",
            "content": "ScyllaDB is API compatible with Apache Cassandra but implemented in C++.\nThe same configuration files that you use when working with Apache\nCassandra should also work with ScyllaDB.\n\nScyllaDB can be downloaded from the following URL.\n<http://www.scylladb.com/>",
            "children": []
          },
          {
            "level": "6.8.4",
            "title": "6.8.4. Apache HBase {#hbaseintro}",
            "content": "If you already have a Hadoop and HDFS environment setup or are planning\nto deploy one, then Apache HBase may be a good choice for your\nJanusGraph data store. Apache HBase, like Apache Cassandra, is a\ndatabase that supports very large tables. There are several properties\nfiles in the */conf* directory that can be used to connect JanusGraph to\nan Apache HBase store.\n\n::: note\nFor detailed configuration information you should refer to the official\nJanusGraph documentation located at\n<http://docs.janusgraph.org/latest/storage-backends.html>.\n:::\n\nWhich properties file you use will depend on whether or not you need to\nuse an external index. However, if you were using HBase without an\nexternal index being needed you might connect to it as follows.\n\n``` java\ngraph = JanusGraphFactory.open(\"conf/janusgraph-hbase.properties\")\n```\n\nAs with the Cassandra properties file, The HBase properties file is\npreconfigured to connect to *localhost*. You will need to edit it and\nupdate the hostname and IP address as appropriate before calling *open*\nif you want to connect to a different machine.\n\nApache HBase can be downloaded from the Apache web site at the following\nURL. <https://hbase.apache.org/>",
            "children": []
          },
          {
            "level": "6.8.5",
            "title": "6.8.5. Google Bigtable {#_google_bigtable}",
            "content": "All of the options discussed so far are open source alternatives that\nyou could download and run in-house. For the sake of completeness I am\nincluding a few pointers to some \\\"for fee\\\" alternatives to hosting\nyour JanusGraph data in house. Google Bigtable is API compatible with\nApache HBase. It offers a hosted alternative to hosting your own HBase\ncluster for use with JanusGraph. Of course you will have to decide if\npaying for a hosted database service is the way you want to go versus\nhosting your graph data in house or setting up your own environment that\nyou manage on a hosting service of your choice.\n\nYou can read more about Google Bigtable at the following URL.\n<https://cloud.google.com/bigtable/>",
            "children": []
          },
          {
            "level": "6.8.6",
            "title": "6.8.6. IBM Compose for JanusGraph {#_ibm_compose_for_janusgraph}",
            "content": "IBM offers a hosted and managed JanusGraph environment via its Compose\nplatform. In this environment IBM manages the whole environment for you\nwhich includes JanusGraph backed by a ScyllaDB cluster. As with Google\nBigtable this is a hosted service that you pay to use. If the idea of\nmanaging a Cassandra compatible cluster for use with JanusGraph yourself\nis not something you want to take on this is an option you can consider.\n\nYou can read more about this service at the following URL.\n<https://www.ibm.com/cloud/compose/janusgraph>",
            "children": []
          },
          {
            "level": "6.8.7",
            "title": "6.8.7. Other TinkerPop compatible products and services {#_other_tinkerpop_compatible_products_and_services}",
            "content": "There are now several other products and cloud hosted environments that\ndo not offer JanusGraph support per-se but do offer TinkerPop and\nGremlin support backed by other stores. There are a selection of both\nhosted and in-house options to choose from. The Apache TinkerPop project\nmaintains a list of TinkerPop compatible graph stores. You can find that\nlist here <http://tinkerpop.apache.org/providers.html>.\n\nWhat is really good to see is that ApacheTinkerpop, and in particular\nthe Gremlin query and traversal language, has become one of the primary\nways that people are building and interacting with, graph databases.",
            "children": []
          }
        ]
      },
      {
        "level": "6.9",
        "title": "6.9. Using Docker to experiment with Cassandra and JanusGraph {#dockercass}",
        "content": "I find that using Docker containers can be a great way to quickly get\nthings running when you are experimenting with new ideas or new\ntechnology, or as if often the case, both at the same time! There is a\nvery useful containerized implementation of Apache Cassandra available\nthat you can download and get running in a few seconds and use to test\nthings with JanusGraph. In this section I will walk you through the\nsteps that I use to get a single Cassandra node up and running and use\nit with JanusGraph to setup the *air-routes* graph. I am going to make\nthe assumption that you have already downloaded and installed the\nnecessary Docker runtime for your platform. I do most of my Docker\ntesting using Linux systems but there are runtimes available for Windows\nand Mac OS as well. Assuming you have docker installed, Cassandra can be\ninstalled using a simple *docker pull* command as shown below.\n\nNote that to make it clearer where commands need to be entered commands\nthat need to be entered into the Linux terminal shell are prefixed with\n*\\\"sh\\>\\\"* and commands that are entered into the Gremlin Console have\nthe *\\\"gremlin\\>\\\"* prefix.\n\n``` console\nsh> docker pull cassandra\n```",
        "children": [
          {
            "level": "6.9.1",
            "title": "6.9.1. Starting the Cassandra container {#cassstart}",
            "content": "Once Docker has downloaded the Cassandra image for you, it is quite\nsimple to get a single instance of Cassandra up and running. There are\ndifferent ways that you can use to configure Docker. To keep things\nsimple I am going to just use command line parameters. The command does\nseveral things as shown in the notes below it. I split the command over\nfour lines to make it easier to read.\n\n``` console\nsh> docker run -d -p 7001:7001 -p 7199:7199 -p 9042:9042 -p 9160:9160 \\    \n-v  /var/lib/cassandra:/var/lib/cassandra \\  \n-e CASSANDRA_START_RPC=true \\  \n--name cass  cassandra   \n```\n\n-   Starts a new instance of the Cassandra container.\n\n-   Runs the command in the background using the *\\\"-d\\\"* flag.\n\n-   Exposes the key ports that Cassandra uses so that JanusGraph can\n    connect to this Cassandra instance (*\\\"-p\\\"* flags).\n\n-   Maps (mounts) the Cassandra volume to the local disk. This is where\n    the data will be stored. If we did not do this the data would be\n    lost whenever the container gets deleted (*\\\"-v\\\"* flag).\n\n-   Enables Thrift support using the *-e CASSANDRA_START_RPC=true*\n    setting. This is not needed if you use CQL which is enabled by\n    default.\n\n-   Names the container \\\"cass\\\" which makes it easier for us to refer\n    to it later.\n\nIf you want to check on the progress of your new container at any time\nyou can just check the logs using the command below.\n\n``` console\nsh> docker logs cass\n```\n\nAs with other Docker containers, our Cassandra container can be stopped\nand started as needed using the following commands. Care should be taken\nnot to stop the container if JanusGraph is still busy writing data.\n\n``` console\nsh> docker stop cass\n\nsh> docker start cass\n```",
            "children": []
          },
          {
            "level": "6.9.2",
            "title": "6.9.2. Connecting JanusGraph to Cassandra {#cassconnect}",
            "content": "Now that we have an instance of a Cassandra running, it's time to start\nthe Gremlin Console that is included with the JanusGraph download and\nconnect to Cassandra. Cassandra supports different protocols that can be\nused when connecting to it. These include Astyanax (from Netflix),\nThrift and CQL. In this section I am just going to discuss Thrift and\nCQL. An in depth study of these protocols is beyond the scope of this\nbook but if you want to read more about them a few web searches will\nfind you plenty of documentation. It should be noted that both Thrift\nand Astyanax are being deprecated in favor of CQL. At some point in the\nfuture support for the older protocols is likely to be dropped so it is\nprobably a good idea to get comfortable using CQL as the primary way\nthat you connect JanusGraph to Cassandra,\n\n::: tip\nA script called *janus-cassandra.groovy* is available in the sample-code\nfolder at <https://github.com/krlawrence/graph/tree/main/sample-code>.\nThe script will automate everything that we are about to discuss in this\nsection and you are encouraged to study it.\n:::\n\nA number of properties files are included with the JanusGraph download.\nThey are located in the */conf* folder below the root of the JanusGraph\nfolder. The properties files can be used to help connect JanusGraph to a\nnumber of different back end technologies. These properties files can be\nedited as needed but so long as you are using the default Cassandra\nports with Cassandra running on your local machine (localhost) you\nshould not have to edit anything for the purpose of this discussion.\n\n::: note\nIf you decide to run Cassandra on a remote machine, you will need to\nedit the properties file, or create a new one, so that it contains the\nappropriate host names and IP addresses of the remote system.\n:::\n\nIf you want to connect JanusGraph to Cassandra using the CQL protocol\nyou can use the *janusgraph-cql.properties* file as shown below.\n\n``` java\ngremlin> graph = JanusGraphFactory.open('conf/janusgraph-cql.properties')\n```\n\nYou may see a warning message followed by a long stack trace when you\nissue this command. Despite looking like something horrible has happened\nthis can be ignored and things will still work. I believe that this is a\nknown issue in the community.\n\nAside from a potential warning message, if all goes well you should see\nsomething like the output below after the command has run. This shows\nthat we have a CQL connection to our Cassandra instance running on or\nlocal machine at 127.0.0.1.\n\n``` java\ngraphtraversalsource[standardjanusgraph[cql:[127.0.0.1]], standard]\n```\n\nIf you want to connect JanusGraph to Cassandra using the Thrift protocol\nyou can use the *janusgraph-cassandra.properties* file as shown below.\n\n``` java\ngremlin> graph = JanusGraphFactory.open('conf/janusgraph-cassandra.properties')\n```\n\nIf the command succeeds, you should get back some output that looks like\nthis.\n\n``` java\nstandardjanusgraph[cassandrathrift:[127.0.0.1]]\n```\n\nWhen either of these commands are run, a new JanusGraph instance will be\ncreated and JanusGraph will attempt to connect to Cassandra using the\nspecified protocols. The first time you connect to a brand new (empty)\nCassandra instance you should first define the graph's schema by\ncreating key definitions and create any indexes that you need before\ncreating any vertices, edges or properties. If you would like to\nexperiment with the *air-routes* data using Cassandra as the backing\nstore, the script called `janus-cassandra.groovy` from the `sample-code`\nfolder can be used for this. If you prefer you can experiment yourself\nfrom the console using the JanusGraph management API to create keys and\nindexes and creating a traversal source object before adding any\nvertices and edges.\n\nIf you choose run the `janus-cassandra.groovy` script it will create the\nkeys and indexes needed and then load the *air-routes* graph and also\nrun a few tests to make sure everything is working. Note that you only\nneed to do this setup step once as next time the data will have already\nbeen loaded and the schema defined.\n\n::: note\nAs we are storing our graph into an instance of Cassandra where the data\nis being persisted on our local file system, the next time you start\nJanusGraph and re-connect to Cassandra your data will be waiting for\nyou!\n:::\n\nTo run the script from the Gremlin Console you can just use the *:load*\ncommand to load it as shown below.\n\n``` java\ngremlin> :load janus-cassandra.groovy\n```\n\nIf the script works as expected you should now be able to query the\ngraph.\n\n``` java\ngremlin> g.V().has('type','airport').count()\n\n==>3379\n```\n\nWhenever you are finished working with the graph, it is a good idea to\nclose it. Once closed you will have to reconnect using one of the two\n*open* steps shown above before you can start working with it again.\n\n``` java\ngremlin> graph.close()\n```\n\nIf you are reconnecting to your graph, having previously loaded some\ndata and closed it, you can use the following commands. If you are using\nThrift instead of CQL you would use the\n*janusgraph-cassandra.properties* file instead.\n\n``` java\n// Reconnect using CQL\ngremlin> graph = JanusGraphFactory.open('conf/janusgraph-cql.properties')\n\ngremlin> g = graph.traversal()\n```\n\nA common requirement when testing and experimenting is to throw\neverything away and start again. The easiest way to do this is to use\nthe command shown below. This will remove all of your data, indexes and\nschema definitions so only do this if you really want to start over.\n\n``` java\ngremlin> JanusGraphFactory.drop(graph)\n```\n\nHaving done a *drop* operation, if you previously loaded the\n*air-routes* data using the janus-cassandra.groovy script, you will need\nto run the script again to get the data, indexes and schema back.\n\nOne other thing to realize is that using the techniques shown in this\nsection we are connecting the Gremlin Console and JanusGraph directly to\nCassandra. This means that we can issue commands directly from the\nGremlin Console without needing to use any additional configuration or\nsetup steps other than telling JanusGraph how to connect to Cassandra\nusing a properties file. Later in the book we will introduce the Gremlin\nServer that allows you to front end a graph with an HTTP server.\nRemember also that JanusGraph is really a set of Java libraries (JAR\nfiles). It does not create any processes of its own and does not run as\na service. So in this instance JanusGraph is running on the process of\nthe Gremlin Console. Cassandra of course is running as a standalone\nservice.",
            "children": []
          },
          {
            "level": "6.9.3",
            "title": "6.9.3. Finding nodetool {#nodetool}",
            "content": "If for any reason you need to check on Cassandra settings or overall\nstatus, you typically use the *nodetool* command. Because in this case\nwe are using a containerized version of the Cassandra code, to run\n*nodetool* you need to start a shell session inside the container. This\ncan be done using the *docker exec* command as shown below. Once you are\ninside the container you will find *nodetool* available on the default\npath. The examples below show how to start a bash session and enter a\nfew *nodetool* commands. Finally we exit the session.\n\n``` console\nsh> docker exec -it cass bash\n```\n\nOnce the shell process has started the prompt will change and you are\nnow running inside the context of the container.\n\n``` console\nroot@115ed53ef189:/\n```\n\nWe can now enter *nodetool* commands. I have truncated the output a bit\nto aid reading. First, let's check the version of Cassandra we are\nrunning.\n\n``` console\nroot@115ed53ef189:/ nodetool version\n\nReleaseVersion: 3.11.1\n```\n\nLet's check to see that Thrift is running.\n\n``` console\nroot@115ed53ef189:/ nodetool statusthrift\n\nrunning\n```\n\nIf you want more information about the overall state of things you can\nuse the *nodetool info* command. I have truncated this output.\n\n``` console\nroot@115ed53ef189:/ nodetool info\n\nID                     : 094e9a8c-99af-4d32-94da-49ed8c61b9fd\nGossip active          : true\nThrift active          : true\nNative Transport active: true\nLoad                   : 3.64 MiB\nGeneration No          : 1517842270\nUptime (seconds)       : 2636\nHeap Memory (MB)       : 102.43 / 1956.00\nOff Heap Memory (MB)   : 0.03\nData Center            : datacenter1\nRack                   : rack1\nExceptions             : 0\n```\n\nOnce we are done with the container typing *exit* will return us to the\nLinux terminal session we entered the container from.\n\n``` console\nroot@115ed53ef189:/ exit\n\nsh>\n```",
            "children": []
          }
        ]
      },
      {
        "level": "6.10",
        "title": "6.10. Using an external index with JanusGraph {#extindex}",
        "content": "JanusGraph allows an external index to be created using a technology\nsuch as ElasticSearch or Apache Solr. You would create such an index in\ncases where you need to do more sophisticated pattern matching as part\nof a graph query. This topic is currently a little beyond the main focus\nof this book which is to give a detailed introduction to the Gremlin\nQuery and Traversal language and some of the ways that technology can be\ndeployed. You can find a detailed explanation of how to create an\nexternal index in the JanusGraph documentation which is located at the\nfollowing URLs: <https://docs.janusgraph.org/latest/indexes.html> and\n<https://docs.janusgraph.org/latest/index-backends.html>.",
        "children": []
      }
    ]
  },
  {
    "level": "7",
    "title": "7. INTRODUCING GREMLIN SERVER {#gremlinserver}",
    "content": "So far in this book we have looked at a few different ways to setup a\nTinkerPop enabled graph store. Initially we focussed on running a\nTinkerGraph or a JanusGraph graph locally with the data kept in memory.\nWe also looked at how to configure Cassandra with JanusGraph so that you\ncould connect to it from the Gremlin Console. As you will recall,\nCassandra could be running locally or remotely but either way\nsuccessfully making the connection to it required knowing the specific\ndetails of the back end configuration. This included knowing the IP\naddresses, ports and protocols being used.\n\nWhile this may be acceptable in scenarios where it is OK for the user of\nthe graph to have this level of insight and access into the back end\nthere are many scenarios where it is desirable to keep most of the\nimplementation detail hidden and access secured. This is where Gremlin\nServer comes in.\n\nGremlin Server, as its name suggests, offers a way of setting up access\nto a graph that goes via a front end web server. In this way the user of\nthe graph only has to know the name or IP address of the Gremlin Server\nin order to communicate with a graph. You can set Gremlin Server up on\nyour local machine, which is useful for testing but you can also use it\nto setup a graph on a remote server and allow users to access it.\nGremlin Server supports a number of different connection protocols and\nmethods. You can connect to it from a Gremlin console, from a command\nline using *curl* commands or from an application. Gremlin Server has a\nsecond advantage over allowing us to hide the graph implementation\ndetails. It allows people using programming languages that do not yet\nhave Apache TinkerPop language bindings to work with a graph using\nsimple HTTP protocols.\n\n::: note\nThe official Apache TinkerPop documentation includes in depth coverage\nof configuring and using Gremlin Server.\n<http://tinkerpop.apache.org/docs/current/reference/#gremlin-server>\n:::\n\nGremlin Server offers a lot of valuable capabilities. In this section I\nam going to explain how to take the JanusGraph backed by Cassandra that\nwe built earlier and expose it via Gremlin Server. There are many other\nuseful ways that Gremlin Server can be configured, deployed and used. If\nyou plan to experiment further with Gremlin Server I very much encourage\nyou to read the official documentation.\n\n::: note\nWhen this book was first released, the majority of \\\"real world\\\" use\ncases focussed on directly attached or even in memory graphs. As Apache\nTinkerPop has evolved, it has become a lot more common to connect to a\ngraph remotely via a Gremlin Server.\n:::",
    "children": [
      {
        "level": "7.1",
        "title": "7.1. Configuring Gremlin Server {#serverconfig}",
        "content": "The Gremlin Server runtime is a separate download available from the\nApache TinkerPop Web site. However, if you are going to be using Gremlin\nServer in conjunction with JanusGraph you should use the version of\nGremlin Server that comes bundled as part of the JanusGraph download.\nThe JanusGraph version comes preconfigured to work more easily with the\nJanusGraph runtimes and connect more easily to JanusGraph managed back\nend stores like Cassandra. The simplest way to configure Gremlin Server\nis to use the YAML and properties files that are delivered as part of\nthe Gremlin Server or JanusGraph downloads. Depending on your\nconfiguration, you may need to edit these files.\n\nThe Apache TinkerPop documentation has detailed instructions and\nexamples showing different ways of configuring a Gremlin Server. In this\nsection I am going to focus on setting up a Gremlin Server that can\nfront end the JanusGraph and Dockerized Cassandra instance that we\nconfigured earlier.\n\nIf you look at the files that were installed on your machine when you\nunzipped the JanusGraph download, you will find a path of\n*conf/gremlin-server*. Inside this directory you will find a set of YAML\nand properties files that can be used to start a Gremlin Server working\nwith JanusGraph and a variety of different back end stores.\n\nFor the rest of this discussion I am going to use the\n*gremlin-server.yaml* file as my starting point and make minor\nmodifications to it.\n\nThe Gremlin Server by default is configured for a WebSockets connection\nand that is how the Gremlin Console connects to it. Using WebSockets is\nthe recommended approach when possible as it allows for a long running\nfull duplex connection. However, there are still many use cases where\nsupporting an HTTP connection is desirable. There is also a third option\nthat allows both WebSockets and HTTP connections. In the YAML file that\nis used when starting a Gremlin Server you need to specify one of the\nfollowing.\n\norg.apache.tinkerpop.gremlin.server.channel.WebSocketChannelizer\n\n:   -   The server will expect a WebSockets connection (this is the\n        default).\n\norg.apache.tinkerpop.gremlin.server.channel.HttpChannelizer\n\n:   -   The server will expect an HTTP connection.\n\norg.apache.tinkerpop.gremlin.server.channel.WsAndHttpChannelizer\n\n:   -   The server will accept both WebSockets and HTTP connections.\n\nThe first part of the *gremlin-server.yaml* file, modified to meet our\nneeds is shown below. I did not modify the parts of the file that are\nnot shown but I encourage you to look at the whole file and study the\nsettings. For our current needs the defaults are fine. However, in your\nenvironment the defaults may not meet your needs. The TinkerPop\ndocumentation has detailed coverage of the settings and what they do.\n\nOK so let's look at the parts of the YAML file that are relevant to this\nexperiment. Note that I have chosen to use the *WsAndHttpChannelizer*.\nThis is because I want to allow both the Gremlin Console over WebSockets\nand other applications such as *curl* and *Ruby* over HTTP to connect to\nmy new Gremlin Server.\n\nNotice also that the *janusgraph-cassandra-es.server.properties* file is\nspecified in the *graphs* section. This is a file that is provided as\npart of the JanusGraph download. This is the file that Gremlin Server\nwill use to connect to our JanusGraph backed by Cassandra. Note that the\n*\\\"-es\\\"* in the properties file name refers to Elasticsearch. As we did\nnot configure an external index when we setup our JanusGraph the lines\nreferring to Elasticsearch inside the properties file should be\ncommented out.\n\nThe *scriptEvaluationTimeout* setting is important. It tells the Gremlin\nServer how long to let a query run before terminating it. This\nessentially establishes the maximum amount of time any query will be\nallowed to run, regardless of whether it has completed or not. For this\nexperiment the default setting of 30000 should be more than adequate.\nThe value represents the number of milliseconds allowed. If you want to\nallow queries sent to the server to run for longer you can increase this\nvalue. Just keep in mind that if you have multiple users using the same\nGremlin Server you may not want to allow someone to run a really complex\nquery that might take a long time to complete. As a side note, I have\nseen people increase this value to allow queries to complete when in\nfact what they should have been doing is creating an index in the graph\nto allow the query to run faster and hence take less time! If you want\nto disable the timeout feature you can do that by specifying a timeout\nvalue of 0 (zero).\n\n::: formalpara-title\n**gremlin-server.yaml**\n:::\n\n``` java\nhost: 0.0.0.0\nport: 8182\nscriptEvaluationTimeout: 30000\nchannelizer: org.apache.tinkerpop.gremlin.server.channel.WsAndHttpChannelizer\ngraphs: {\n  graph: conf/gremlin-server/janusgraph-cassandra-es-server.properties\n}\nplugins:\n  - janusgraph.imports\nscriptEngines: {\n  gremlin-groovy: {\n    imports: [java.lang.Math],\n    staticImports: [java.lang.Math.PI],\n    scripts: [scripts/empty-sample.groovy]}}\n# The rest of the file is not shown```\n\nAs well as the YAML file and the properties file, there is a third file\nthat we need to provide when starting a Gremlin Server. This file can\ncontain Groovy code that will be run when the server starts. For our\npurposes the default file is all we need. These files should be placed\nin the *scripts* directory that is part of the standard Gremlin Server\nor JanusGraph install. We will take a look at the default script in a\nmoment.\n\nBy default both Gremlin Server and JanusGraph include a Groovy script\ncalled `empty-sample.groovy`. That name is a bit misleading as the file\nactually does some interesting things. For our purposes the most useful\nthing that the script does is to configure and make available to us in\nthe Gremlin Console, the graph traversal source, *g* object that\nhopefully by now you are very familiar with. This provides you with a\ntemplate for any other *global* variables that you may want to make\navailable to the user of the console connected to your Gremlin Server.\nThe file also configures some default log messages that will be\ngenerated when the server starts and stops. Note that you can add your\nown code to this script or replace it with your own script entirely. You\nwill find additional example scripts included as part of the Gremlin\nServer download. These scripts do things such as create a TinkerGraph\ninstance and load some graph data as part of the server startup process.\nUsing this technique, we could easily add a line to the script so that\nwhen the server starts an empty TinkerGraph is created and the\n*air-routes* data loaded.\n\n::: formalpara-title\n**empty-sample.groovy**\n:::\n\n``` java\n// an init script that returns a Map allows explicit setting of global bindings.\ndef globals = [:]\n\n// defines a sample LifeCycleHook that prints some output to the Gremlin Server console.\n// note that the name of the key in the \"global\" map is unimportant.\nglobals << [hook : [\n        onStartUp: { ctx ->\n            ctx.logger.info(\"Executed once at startup of Gremlin Server.\")\n        },\n        onShutDown: { ctx ->\n            ctx.logger.info(\"Executed once at shutdown of Gremlin Server.\")\n        }\n] as LifeCycleHook]\n\n// define the default TraversalSource to bind queries to - this one will be named \"g\".\nglobals << [g : graph.traversal()]\n```\n\nNow that we have all of our configuration files in place we can start\nthe Gremlin Server by typing the following command into a terminal\nwindow. The *gremlin-server.sh* file is located in the *bin* directory\nof your Gremlin Server or JanusGraph installation.\n\n``` console\nsh> gremlin-server.sh conf/gremlin-server/gremlin-server.yaml\n```\n\nIf all goes well you should see output from the Gremlin Server\ndisplayed. The server will keep running until you kill it. In this case\na simple CTRL-C is all you need to do to kill the server. After you\npress CTRL-C the server will do a bit of cleaning up.\n\n::: tip\nYou can use the *start* keyword to start the Gremlin Server as a\nbackground task.\n:::\n\nYou can also start the Gremlin Server in the background rather than have\nit take over your current terminal window by adding the *start* keyword\nas part of the invocation command as shown below. The examples below\nassume that you are starting the server from the place where you\ninstalled the Gremlin Server zip file.\n\n``` console\nsh> bin/gremlin-server.sh start\n\nServer started 25897\n```\n\nBy default the configuration information for the server being started\nwill be looked for in the file `conf/gremlin-server.yaml`. If you want\nto override this value you need to provide an environment variable\ncalled *GREMLIN_YAML* before starting the server as shown below.\n\n``` console\nsh> export GREMLIN_YAML='conf/mysettings.yaml'\nsh> bin/gremlin-server.sh start\n\nServer started 25897\n```\n\nAs an alternative to defining an environment variable, you can instead\ncreate a file called `bin/gremlin-server.conf` and put the name of your\nYAML file in it. An example is shown below.\n\n``` console\nGREMLIN_YAML='conf/mysettings.yaml'\n```\n\nIf you want to check whether or not the Gremlin Server is currently\nrunning you can use the *status* keyword.\n\n``` console\nsh> bin/gremlin-server.sh status\n\nServer running with PID 25897\n```\n\nTo stop the server you can use the *stop* keyword as follows.\n\n``` console\nsh> bin/gremlin-server.sh stop\n\nServer stopped [25897]\n```",
        "children": []
      },
      {
        "level": "7.2",
        "title": "7.2. Connecting to a Gremlin Server from the Gremlin Console {#serverconsole}",
        "content": "It is fairly straightforward to connect to a running Gremlin Server from\na Gremlin Console. In this case it should not matter whether you are\nusing the Gremlin Console that is part of the Apache TinkerPop download\nor the one that comes as part of the JanusGraph download. This is\nbecause the Gremlin Server very nicely hides the back end implementation\ndetails from us. As far as we are concerned it is just an HTTP or\nWebSockets endpoint that can handle Gremlin queries.\n\nThere is one exception, that I am currently aware of, to my statement\nabout not needing to worry about server side implementation details.\nThis exception is a result of potential version mismatches. Typically,\nthe TinkerPop download, assuming you have the very latest, will be at\nleast a few minor point releases ahead of any given graph store release.\nThis is purely because whenever TinkerPop has a release, it takes a bit\nof time for the GraphDB maintainers to catch up. I will give a concrete\nexample of this in a moment.\n\nAs with Gremlin Server, YAML files can be used to configure a remote\nconnection from the Gremlin Console. The Gremlin Console as well as the\nversion that comes bundled with JanusGraph includes a set of YAML files\nthat can be used as-is or edited as needed. In order to connect the\nGremlin Console to the Gremlin Server that we just configured, the file\n*remote.yaml* can be used. I had to make one change, as shown below. I\ncommented out the *serializer* line and replaced it with a slightly\nmodified version. I had to do this because of the version issues I\nmentioned above. At time of writing, JanusGraph supports version V1d0 of\nthe GyroMessageSerializer that is used as the communication\nserialization protocol between the Gremlin Console and the Gremlin\nServer. However, my Gremlin Console was pre configured with the newer\nversion V3d0 of the serializer. It is essential that the console and the\nserver be using the same version. If I did not make this change, the\nGremlin Console and the Gremlin Server would not be able to correctly\ncommunicate. Note that in *remote.yaml* file we also specify the name\nand port of the Gremlin Server host that we will be connecting to. As we\nare running everything locally the default host name of *localhost* is\nfine. If you are connecting to a remote Gremlin Server the *hosts* value\nneeds to be edited to correctly identify name or IP address of the\nserver where the Gremlin Server is running. Also we can use the default\nport of 8182. By default a Gremlin Server listens on port 8182. The only\nreason you would need to change this value is if you are connecting to a\nGremlin Server using a different port.\n\n::: formalpara-title\n**remote.yaml**\n:::\n\n``` java\nhosts: [localhost]\nport: 8182\n#serializer: { className: org.apache.tinkerpop.gremlin.driver.ser.GryoMessageSerializerV3d0, config: { serializeResultToString: true }}\nserializer: { className: org.apache.tinkerpop.gremlin.driver.ser.GryoMessageSerializerV1d0, config: { serializeResultToString: true }}\n```",
        "children": [
          {
            "level": "7.2.1",
            "title": "7.2.1. Making the remote connection {#remoteconn}",
            "content": "Now that we have our YAML file ready, all that we have to do to\nestablish a connection between our Gremlin Console and the Gremlin\nServer is to issue the following command once the console is running.\n\n``` console\ngremlin> :remote connect tinkerpop.server conf/remote.yaml\n```\n\nNow that we are connected to the Gremlin Server we can issue some\nGremlin commands. Given that the *air-routes* graph is already loaded\ninto our remote graph we can immediately start to issue some queries. In\norder to make sure the query goes to the remote graph, the query needs\nto be prefixed with *\\\":\\>\\\"*.\n\n``` java\ngremlin> :> g.V().count()\n\n==>3624\n```",
            "children": []
          },
          {
            "level": "7.2.2",
            "title": "7.2.2. The Gremlin Console's *result* variable {#resultvar}",
            "content": "When working within the Gremlin console, one other useful thing to be\naware of is that the results of queries sent to a server, when the\nconsole is in *\\\"local mode\\\"*, as well as being displayed are stored in\na variable called *result*. Take a look at the query below.\n\n``` java\ngremlin> :>  g.V().hasLabel('continent').group().by('desc').by(out().count())\n\n==>{South America=305, Asia=941, Europe=596, Africa=298, Antarctica=0, North America=981, Oceania=287}\n```\n\nIf we were to print the contents of the *result* variable we would find\nit contains the results from the query.\n\n``` java\ngremlin> println result\n\n[result{object={South America=305, Asia=941, Europe=596, Africa=298, Antarctica=0, North America=981, Oceania=287} class=java.lang.String}]\n```\n\nAs the console is still in local mode we can use some inline Groovy code\nto post process, in this case pretty print, the contents of *result*.\nThis capability is worth keeping in mind. There are some interesting\nthings it allows you to do such as easily post processing results and\nsaving them to a file locally when working with a remote server.\n\n``` java\ngremlin> for (x in result['object'][0][1..-2].split(', ')) println x\n\nSouth America=305\nAsia=941\nEurope=596\nAfrica=298\nAntarctica=0\nNorth America=981\nOceania=287\n```",
            "children": []
          },
          {
            "level": "7.2.3",
            "title": "7.2.3. Working in remote mode {#remotemode}",
            "content": "As useful as keeping the console in *\\\"local mode\\\"* can be, if you are\ngoing to be issuing a lot of queries to the remote graph, I find it more\nconvenient to put the console into *\\\"remote mode\\\"*. This can be done\nas follows.\n\n``` console\ngremlin> :remote console\n\nAll scripts will now be sent to Gremlin Server - [localhost/127.0.0.1:8182] - type ':remote console' to return to local mode\n```\n\nThe console is now in *\\\"remote mode\\\"*. All queries that you enter will\nbe sent to the Gremlin Server and there is no need to use the *\\\":\\>\\\"*\nprefix.\n\n``` java\ngremlin> g.V().count()\n\n==>3624\n```\n\nOne thing to notice is that the output that comes back from a Gremlin\nServer looks a little different at times from when you use the commands\nusing the Gremlin Console attached to a local TinkerGraph. This is\nbecause Gremlin Console essentially does a *toString()* on the output\nbefore it is shown to the user in these cases.\n\n``` java\ngremlin> g.V().has('code','AUS').valueMap()\n\n==>{country=[US], code=[AUS], longest=[12250], city=[Austin], elev=[542], icao=[KAUS], lon=[-97.6698989868164], type=[airport], region=[US-TX], runways=[2], lat=[30.1944999694824], desc=[Austin Bergstrom International Airport]}\n```\n\nAs an example of the slight differences in the output format, below you\nwill find the results from the same query when the graph was running as\na local, in memory, TinkerGraph.\n\n``` java\n[country:[US],code:[AUS],longest:[12250],city:[Austin],elev:[542],icao:[KAUS],lon:[-97.6698989868164],type:[airport],region:[US-TX],runways:[2],lat:[30.1944999694824],desc:[Austin Bergstrom International Airport]]\n```\n\nOnce you are done sending all commands to the Gremlin Server you can\nswitch out of that mode as follows. Commands will now be sent to your\nlocal console. This means that you can work with a local and remote\ngraph at the same time. The *:remote console* command is therefore a\ntoggle. Each time you use the command the console will switch between\nlocal mode and remote mode or vice versa.\n\n``` console\ngremlin> :remote console\n\n==>All scripts will now be evaluated locally - type ':remote console' to return to\nremote mode for Gremlin Server - [localhost/127.0.0.1:8182]\n```\n\nIf you are completely done with the remote connection for this console\nsession you can truly close it as follows. Having done this you will\nneed to reestablish the connection before the *:remote console* will\nwork again.\n\n``` console\ngremlin> :remote close\n\n==>Removed - Gremlin Server - [localhost/127.0.0.1:8182]\n```",
            "children": []
          }
        ]
      },
      {
        "level": "7.3",
        "title": "7.3. Connecting to a Gremlin Server from the command line {#servercli}",
        "content": "Now that we have a Gremlin Server up and running that supports both HTTP\nand Web Sockets connections, we can, if we wish, communicate with it\nusing nothing more than a *curl* command. The *curl* command below uses\nan HTTP GET to send a query to our Gremlin Server.\n\n``` console\nsh> curl \"http://localhost:8182?gremlin=g.V().has('code','AUS').valueMap()\"\n```\n\nIn response to the HTTP GET request the server sends back the result\npackaged as JSON as follows. I have formatted the output in a way that\nmakes it easier to read. What was actually returned did not have any\nline breaks in it at all and was quite hard to read..\n\n``` java\n{\"requestId\":\"a8ad654a-a5a3-4bb9-8474-69aca3c3db1e\",\n \"status\":{\"message\":\"\",\"code\":200,\"attributes\":{}},\n \"result\":{\"data\":[{\"country\":[\"US\"],\n                       \"code\":[\"AUS\"],\n                    \"longest\":[12250],\n                       \"city\":[\"Austin\"],\n                       \"elev\":[542],\n                       \"icao\":[\"KAUS\"],\n                        \"lon\":[-97.6698989868164],\n                       \"type\":[\"airport\"],\n                     \"region\":[\"US-TX\"],\n                    \"runways\":[2],\n                        \"lat\":[30.1944999694824],\n                       \"desc\":[\"Austin Bergstrom International Airport\"]}],\n           \"meta\":{}}}\n```\n\nThe following example shows how to send the same query, but with the\n*valueMap* step removed, using an HTTP POST. The Apache TinkerPop\ndocumentation states that using POST is the recommended way to send\nqueries over HTTP to a Gremlin Server. Note how in this case we are\nsending the query packaged as JSON and that we have to escape the quote\ncharacters.\n\n``` console\nsh> curl -X POST -d \"{\\\"gremlin\\\":\\\"g.V().has('code','AUS')\\\"}\" \\\n            \"http://localhost:8182\"\n```\n\nAs with the prior query, the HTTP POST form of the query also returns\nthe result packaged as JSON. However, in this case, because I left off\nthe *valueMap* step, the JSON includes additional information in the\nform of the ID values and labels for the vertex and its properties. This\nis because the result represents a vertex this time rather than a map. I\nhave again formatted the output in a way that is easier to read.\n\n``` java\n{\"requestId\":\"64c757b8-27a6-4509-a54c-ea35ba517667\",\n \"status\":{\"message\":\"\",\"code\":200,\"attributes\":{}},\n \"result\":{\n   \"data\":[\n     {\"id\":12352,\n      \"label\":\"airport\",\n      \"type\":\"vertex\",\n      \"properties\":\n        {\"country\":[{\"id\":\"8p4-9j4-8p1\", \"value\":\"US\"}],\n            \"code\":[{\"id\":\"93c-9j4-5j9\", \"value\":\"AUS\"}],\n         \"longest\":[{\"id\":\"9hk-9j4-mx1\", \"value\":12250}],\n            \"city\":[{\"id\":\"9vs-9j4-7wl\", \"value\":\"Austin\"}],\n            \"elev\":[{\"id\":\"aa0-9j4-but\", \"value\":542}],\n            \"icao\":[{\"id\":\"ao8-9j4-6bp\", \"value\":\"KAUS\"}],\n             \"lon\":[{\"id\":\"b2g-9j4-dfp\", \"value\":-97.6698989868164}],\n            \"type\":[{\"id\":\"bgo-9j4-745\", \"value\":\"airport\"}],\n          \"region\":[{\"id\":\"buw-9j4-9hh\", \"value\":\"US-TX\"}],\n         \"runways\":[{\"id\":\"c94-9j4-b2d\", \"value\":2}],\n             \"lat\":[{\"id\":\"cnc-9j4-cn9\", \"value\":30.1944999694824}],\n            \"desc\":[{\"id\":\"d1k-9j4-a9x\",\n                  \"value\":\"Austin Bergstrom International Airport\"}]}}],\n            \"meta\":{}}}\n```\n\nI have included examples of the different types of JSON result that you\nare likely to have to process in the \\\"[More examples of the JSON\nreturned from a Gremlin Server](#serverjson)\\\" section that is coming up\nsoon.",
        "children": []
      },
      {
        "level": "7.4",
        "title": "7.4. Connecting to a Gremlin Server from Java using *withRemote* {#javagsclient}",
        "content": "While it is perfectly possible to work directly with the JSON returned\nfrom a Gremlin Server it is often more desirable to have the results\nplaced directly into variables of the appropriate type. If the\nappropriate Grelmin language driver exists for the programming language\nthat you are using, this is quite easy to setup. In this section we will\nlook at connecting to a Gremlin Server from a Java application and\ntaking advantage of the *withRemote* capability that TinkerPop provides.\n\n::: tip\nThe source code for the example shown in this section comes from the\n*RemoteClient.java* sample located at\n<https://github.com/krlawrence/graph/tree/main/sample-code>.\n:::\n\nLet's look at the small application in sections. First of all it is\nnecessary to import the required classes that we will need to make the\nconnection to the server and retrieve the query results.\n\n``` java\nimport org.apache.tinkerpop.gremlin.driver.Cluster;\nimport org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.GraphTraversalSource;\nimport org.apache.tinkerpop.gremlin.structure.util.empty.EmptyGraph;\nimport org.apache.tinkerpop.gremlin.driver.remote.DriverRemoteConnection;\nimport org.apache.tinkerpop.gremlin.driver.ser.GryoMessageSerializerV1d0;\nimport java.util.Map;\nimport java.util.List;\nimport java.util.ArrayList;\n```\n\nWe can now define a small Java class that we will call *RemoteClient*\nand setup the connection to the Gremlin Server. This is done by first of\nall creating a *Cluster.Builder* instance that will be used to describe\nthe server we are connecting to and the protocol we want to use. It is\nimportant that these settings match what the Gremlin Server is\nconfigured to use. For this simple example we are just using *localhost*\nas the host name but the name of any Gremlin Server that you have access\nto can be used instead. The default Gremlin Server port of *8182* is\nspecified and the *GyroMessageServializerV1d0* serialization format is\nselected. Again, this needs to match both the protocol and the version\nof the protocol that your Gremlin Server is supporting.\n\n``` java\npublic class RemoteClient\n{\n  public static void main( String[] args )\n  {\n    Cluster.Builder builder = Cluster.build();\n    builder.addContactPoint(\"localhost\");\n    builder.port(8182);\n    builder.serializer(new GryoMessageSerializerV1d0());\n```\n\nOnce the Cluster.Builder instance has been setup we can use it to create\nour *Cluster* instance.\n\n``` java\n    Cluster cluster = builder.create();\n```\n\nLastly, we need to setup a GraphTraversalSource object for the Gremlin\nServer hosted graph that we will be working with. The TinkerPop\ndocumentation recommends that an instance of an *EmptyGraph* is used\nwhen creating the traversal. Having done that, the *withRemote* method\ncan be called to establish the remote connection. Note that the cluster\ninstance that we just created is passed in as a parameter. While this\nlooks a little complicated it is really not a lot different than when we\nconnect to a local graph using the Gremlin Console. The only difference\nis that by setting up the remote connection this way, when we start to\nissue queries against the graph, rather than getting JSON objects back,\nthe results will automatically be serialized into Java variables for us.\nThis makes our code a lot easier to write and essentially is the same\ncode from this point onwards that would also work with a local graph\nthat we are directly connected to.\n\n``` java\n    GraphTraversalSource g =\n      EmptyGraph.instance().traversal().\n        withRemote(DriverRemoteConnection.using(cluster));\n```\n\nWe can now use our new graph traversal source object to issue a Gremlin\nquery. The results will be placed directly into the *List* called\n*vmaps*. The query finds the first 10 airports with a region code of\n*GB-ENG* which is short for Great Britain - England.\n\n``` java\n    List <Map<String,Object>> vmaps =\n      g.V().has(\"airport\",\"region\",\"GB-ENG\").limit(10).valueMap().toList();\n\n    System.out.println(\"\\n\\nThe following airports were found\\n\");\n    for (Map <String,Object> m : vmaps)\n    {\n      ArrayList code = (ArrayList) m.get(\"code\");\n      ArrayList desc = (ArrayList) m.get(\"desc\");\n      System.out.println(code.get(0) + \" , \" + desc.get(0));\n    }\n\n    cluster.close();\n  }\n}\n```\n\nWhen the Java application is compiled and run the output should look\nsimilar to that shown below.\n\n``` java\nLEQ , Land's End Airport\nLGW , London Gatwick\nMAN , Manchester Airport\nLHR , London Heathrow\nLCY , London City Airport\nSTN , London Stansted Airport\nEMA , East Midlands Airport\nLPL , Liverpool John Lennon Airport\nLBA , Leeds Bradford Airport\nNCL , Newcastle Airport\n```",
        "children": []
      },
      {
        "level": "7.5",
        "title": "7.5. Connecting to a Gremlin Server from Ruby {#rubyclient}",
        "content": "As far as I know, at time of writing, there is currently no formal\nGremlin language binding support available for Ruby programmers. This is\ntherefore a perfect use case to show how, using a small amount of code,\na Ruby programmer can connect to a Gremlin Server and issue Gremlin\nQueries.\n\n::: tip\nThe source code for the Ruby example, *gremlin-client-http.rb*, as shown\nbelow, is available in the sample-code folder.\n<https://github.com/krlawrence/graph/tree/main/sample-code>\n:::\n\nThe code below represents a complete, standalone Ruby application. It\nuses the standard Ruby libraries. No additional Ruby Gems or third party\nlibraries should be required. The example as shown connects to a Gremlin\nServer running on your local machine. It packages up an HTTP POST\nrequest and sends it to the Gremlin Server. The body of the HTTP request\nis encoded as JSON.\n\n::: formalpara-title\n**gremlin-client-http.rb**\n:::\n\n``` {.ruby .numberLines}\n\n# Simple example of how you can connect to a Gremlin Server and\n# issue queries from a Ruby application.\n\nrequire 'net/http'\nrequire 'uri'\nrequire 'json'\n\nuri = URI.parse(\"http://localhost:8182\")\n\nrequest = Net::HTTP::Post.new(uri)\nreq_options = { use_ssl: uri.scheme == \"https\", }\n\nquery = {\"gremlin\" => \"g.V().has('code','AUS').out().count()\"}\nrequest.body = JSON.dump(query)\n\nresponse = Net::HTTP.start(uri.hostname, uri.port, req_options) do |http|\n  http.request(request)\nend\n\nputs \"Response code from the server was #{response.code}\"\nputs response.body\n```\n\nHere is the output that was returned when I ran the program using Ruby\nversion 2.3.1. As you can see the result body contains a JSON object\njust as when we issued requests using the *curl* command earlier.\n\n``` java\nResponse code from the server was 200\n\n{\"requestId\":\"0129e905-6903-4658-9cfb-23404842ba12\",\n \"status\":{\"message\":\"\",\"code\":200,\"attributes\":{}},\n \"result\":{\"data\":[62],\"meta\":{}}}\n```",
        "children": []
      },
      {
        "level": "7.6",
        "title": "7.6. Configuring a Gremlin Server to use a TinkerGraph {#servertinkergraph}",
        "content": "We have already seen how a Gremlin Server can be configured as a way to\nprovide remote access to a JanusGraph and Cassandra deployment.\nSometimes it can be useful to setup a Gremlin Server with just a basic\nTinkerGraph, in-memory graph, as the backend. This is often a handy way\nto work if you are developing code that will ultimately work with a\nremote TinkerPop enabled graph database but want to do some testing and\ndevelopment locally. A Gremlin Server can of course be configured as a\ngenuinely remote endpoint, perhaps running on a cloud hosted machine,\nbut it can also be configured to run on your local computer. I often set\nit up this way on my laptop while experimenting. In this section I am\ngoing to walk through the steps required to configure a Gremlin Server\nrunning locally that hosts the air-routes dataset in a TinkerGraph.\n\n::: note\nYou will find the configuration files discussed in this section in the\n`sample-data` folder at this location\n<https://github.com/krlawrence/graph/tree/main/sample-data>.\n:::",
        "children": [
          {
            "level": "7.6.1",
            "title": "7.6.1. Creating the configuration files {#TGConfig}",
            "content": "To get our remote TinkerGraph up and running, all we have to do is to\nconfigure a few settings files and start the Gremlin Server. The first\nfile we need to create is the YAML file that will be read by the Gremlin\nServer as it starts. I created a file called\n`gremlin-server-air-routes.yaml` for this purpose. The file actually\nonly contains minor changes from the default `gremlin-server.yaml` file\nthat comes included as part of the Gremlin Server download. The key\nchange is that the file includes a reference to a script in the\n`/scripts` folder called `air-routes.groovy`. The script will load the\nair-routes data set into a TinkerGraph instance once it has been\ncreated.\n\n::: note\nAll folders referenced in this section, such as `/data` and `/script`\nare relative to the location where the Gremlin Server is installed.\n:::\n\nThe `gremlin-server-air-routes.yaml` file should be placed in the\n`/conf` folder.\n\n::: formalpara-title\n**gremlin-server-air-routes.yaml**\n:::\n\n``` java\nhost: localhost\nport: 8182\nscriptEvaluationTimeout: 30000\nchannelizer: org.apache.tinkerpop.gremlin.server.channel.WsAndHttpChannelizer\ngraphs: {\n  graph: conf/tinkergraph-empty.properties}\nscriptEngines: {\n  gremlin-groovy: {\n    plugins: { org.apache.tinkerpop.gremlin.server.jsr223.GremlinServerGremlinPlugin: {},\n               org.apache.tinkerpop.gremlin.tinkergraph.jsr223.TinkerGraphGremlinPlugin: {},\n               org.apache.tinkerpop.gremlin.jsr223.ImportGremlinPlugin: {classImports: [java.lang.Math], methodImports: [java.lang.Math#*]},\n               org.apache.tinkerpop.gremlin.jsr223.ScriptFileGremlinPlugin: {files: [scripts/air-routes.groovy]}}}}\nserializers:\n  - { className: org.apache.tinkerpop.gremlin.driver.ser.GryoMessageSerializerV3d0, config: { ioRegistries: [org.apache.tinkerpop.gremlin.tinkergraph.structure.TinkerIoRegistryV3d0] }}            # application/vnd.gremlin-v3.0+gryo\n  - { className: org.apache.tinkerpop.gremlin.driver.ser.GryoMessageSerializerV3d0, config: { serializeResultToString: true }}                                                                      # application/vnd.gremlin-v3.0+gryo-stringd\n  - { className: org.apache.tinkerpop.gremlin.driver.ser.GraphSONMessageSerializerV1d0, config: { ioRegistries: [org.apache.tinkerpop.gremlin.tinkergraph.structure.TinkerIoRegistryV3d0] }}        # application/json\nmetrics: {\n  slf4jReporter: {enabled: true, interval: 180000}}\nstrictTransactionManagement: false\nidleConnectionTimeout: 0\nkeepAliveInterval: 0\nmaxInitialLineLength: 4096\nmaxHeaderSize: 8192\nmaxChunkSize: 8192\nmaxContentLength: 65536\nmaxAccumulationBufferComponents: 1024\nresultIterationBatchSize: 64\n```\n\nNote that I configured the YAML file so that when JSON is returned it is\nin the original V1 GraphSON format. This is done by specifying that the\n*GraphSONMessageSerializerV1d0* message serializer be used. The main\ndifference between the V1 format and the newer V3 format is that no type\ninformation will be returned as part of the V1 format. I find that users\nfind this format much easier to read while learning Gremlin.\n\nThe properties file that is referenced in the YAML file is unchanged\nfrom the default one that comes with Gremlin Server. It creates an empty\nin-memory TinkerGraph.\n\nThe `tinkergraph-empty.properties` file should also be placed in the\n`/conf` folder.\n\n::: formalpara-title\n**tinkergraph-empty.properties**\n:::\n\n``` java\ngremlin.graph=org.apache.tinkerpop.gremlin.tinkergraph.structure.TinkerGraph\ngremlin.tinkergraph.vertexIdManager=LONG\n```\n\nThe file `air-routes.groovy` invokes the necessary method to load the\n`air-routes.graphml` file from the `/data` folder. The file should be\nplaced in the `/scripts` folder.\n\n::: formalpara-title\n**air-routes.groovy**\n:::\n\n``` java\ndef globals = [:]\n\nglobals << [hook : [\n  onStartUp: { ctx ->\n    ctx.logger.info(\"Loading 'air-routes' graph data.\")\n    graph.io(graphml()).readGraph('data/air-routes.graphml')\n  }\n] as LifeCycleHook]\n\nglobals << [g : graph.traversal()]\n```",
            "children": []
          },
          {
            "level": "7.6.2",
            "title": "7.6.2. Starting the Server {#TGStart}",
            "content": "As discussed in the \\\"[Configuring Gremlin Server](#serverconfig)\\\"\nsection, you can start the Gremlin Server in the foreground or in the\nbackground. For our initial test let's just start the server running in\nthe foregorund.\n\n``` console\n$ bin/gremlin-server.sh conf/gremlin-server-air-routes.yaml\n```",
            "children": []
          },
          {
            "level": "7.6.3",
            "title": "7.6.3. Testing the Server {#TGTest}",
            "content": "Now that the Gremlin Server is up and running you can access it using\n*localhost* as the host name and a port of 8182 just as we did earlier\nwhile setting up a Gremlin Server and JanusGraph. It's always a good\nidea to try a simple *curl* command to make sure that things are\nworking.\n\n``` console\n$ curl \"localhost:8182/gremlin?gremlin=g.V().has('code','SFO').valueMap()\"\n```\n\nHere is the output returned. Note that it is in the GraphSON V1 format\nthat we configured for earlier.\n\n``` java\n{\"requestId\":\"fbcab664-7538-402f-85b4-1b14db88c968\",\"status\":{\"message\":\"\",\"code\":200,\"attributes\":{}},\"result\":{\"data\":[{\"country\":[\"US\"],\"code\":[\"SFO\"],\"longest\":[11870],\"city\":[\"San Francisco\"],\"elev\":[13],\"icao\":[\"KSFO\"],\"lon\":[-122.375],\"type\":[\"airport\"],\"region\":[\"US-CA\"],\"runways\":[4],\"lat\":[37.6189994812012],\"desc\":[\"San Francisco International Airport\"]}],\"meta\":{}}}\n```\n\nThe same Gremlin Console remote connections configuration we looked at\nearlier can also be reused. Likewise, you can connect to your Gremlin\nServer using the host name *localhost* and port 8182. The example below\nassumes that you have already started the Gremlin Console.\n\n``` java\ngremlin> :remote connect tinkerpop.server conf/remote.yaml\n==>Configured localhost/127.0.0.1:8182\n\ngremlin> :remote console\n==>All scripts will now be sent to Gremlin Server - [localhost/127.0.0.1:8182] - type ':remote console' to return to local mode\n\ngremlin> g.V().has('code','SFO').valueMap().unfold()\n==>country=[US]\n==>code=[SFO]\n==>longest=[11870]\n==>city=[San Francisco]\n==>elev=[13]\n==>icao=[KSFO]\n==>lon=[-122.375]\n==>type=[airport]\n==>region=[US-CA]\n==>runways=[4]\n==>lat=[37.6189994812012]\n==>desc=[San Francisco International Airport]\n```\n\nHopefully having read this section you now have an understanding of how\nto setup a Gremlin Server that hosts an in-memory TinkerGraph containing\nthe *air-routes* data set. This can be a useful environment when you\nwant to test queries and code locally that will ultimately need to work\nwith a remote TinkerPop enabled graph database.\n\nIn the next section we will look at ways to make the JSON returned\neasier to work with and also add to our Ruby program to work with the\nJSON.",
            "children": []
          }
        ]
      },
      {
        "level": "7.7",
        "title": "7.7. Tweaking queries to make the JSON returned easier to work with {#servertweaks}",
        "content": "Below is a query that we have seen used earlier in this book. It finds\nall routes longer than 8,000 miles and returns the airport pairs and the\ndistance between them.\n\n``` java\ng.V().as('a').outE().has('dist',gt(8000)).\n      order().by('dist',desc).inV().as('b').\n      filter(select('a','b').by('code').where('a', lt('b'))).\n      path().by('code').by('dist')\n```\n\nWhen we run this query using the Gremlin console with TinkerGraph we get\nback results that have been to a degree *pretty printed* by the Console\nas shown below.\n\n``` java\n[AKL,9025,DOH]    [LAX,8246,RUH]\n[AKL,8818,DXB]    [MEL,8197,YVR]\n[LAX,8756,SIN]    [DXB,8150,IAH]\n[CAN,8754,MEX]    [AUH,8139,SFO]\n[IAH,8591,SYD]    [DFW,8105,HKG]\n[DFW,8574,SYD]    [DXB,8085,SFO]\n[ATL,8434,JNB]    [HKG,8054,JFK]\n[SFO,8433,SIN]    [AUH,8053,DFW]\n[AUH,8372,LAX]    [EWR,8047,HKG]\n[DXB,8321,LAX]    [DOH,8030,IAH]\n[JED,8314,LAX]    [DFW,8022,DXB]\n[DOH,8287,LAX]\n```\n\nHowever, if you were to use a system that returns the full JSON\nresponse, as is the case when using a Gremlin Server over an HTTP\nconnection, you will not get the benefit *\\\"pretty printing\\\"* that the\nGremlin Console does for you. Instead, you will get back something that\nlooks a lot like this from the exact same query as the one we used\nabove.\n\n``` java\n{\"requestId\":\"5acca62c-7351-4b3d-bb20-3660f6feb3cc\",\n \"status\":{\"message\":\"\",\"code\":200,\"attributes\":{}},\n \"result\":{\"data\":\n    [{\"labels\":[[\"a\"],[],[\"b\"]],\"objects\":[\"AKL\",9025,\"DOH\"]},\n    {\"labels\":[[\"a\"],[],[\"b\"]],\"objects\":[\"AKL\",8818,\"DXB\"]},\n    {\"labels\":[[\"a\"],[],[\"b\"]],\"objects\":[\"LAX\",8756,\"SIN\"]},\n    {\"labels\":[[\"a\"],[],[\"b\"]],\"objects\":[\"CAN\",8754,\"MEX\"]},\n    {\"labels\":[[\"a\"],[],[\"b\"]],\"objects\":[\"IAH\",8591,\"SYD\"]},\n    {\"labels\":[[\"a\"],[],[\"b\"]],\"objects\":[\"DFW\",8574,\"SYD\"]},\n    {\"labels\":[[\"a\"],[],[\"b\"]],\"objects\":[\"ATL\",8434,\"JNB\"]},\n    {\"labels\":[[\"a\"],[],[\"b\"]],\"objects\":[\"SFO\",8433,\"SIN\"]},\n    {\"labels\":[[\"a\"],[],[\"b\"]],\"objects\":[\"AUH\",8372,\"LAX\"]},\n    {\"labels\":[[\"a\"],[],[\"b\"]],\"objects\":[\"DXB\",8321,\"LAX\"]},\n    {\"labels\":[[\"a\"],[],[\"b\"]],\"objects\":[\"JED\",8314,\"LAX\"]},\n    {\"labels\":[[\"a\"],[],[\"b\"]],\"objects\":[\"DOH\",8287,\"LAX\"]},\n    {\"labels\":[[\"a\"],[],[\"b\"]],\"objects\":[\"LAX\",8246,\"RUH\"]},\n    {\"labels\":[[\"a\"],[],[\"b\"]],\"objects\":[\"MEL\",8197,\"YVR\"]},\n    {\"labels\":[[\"a\"],[],[\"b\"]],\"objects\":[\"DXB\",8150,\"IAH\"]},\n    {\"labels\":[[\"a\"],[],[\"b\"]],\"objects\":[\"AUH\",8139,\"SFO\"]},\n    {\"labels\":[[\"a\"],[],[\"b\"]],\"objects\":[\"DFW\",8105,\"HKG\"]},\n    {\"labels\":[[\"a\"],[],[\"b\"]],\"objects\":[\"DXB\",8085,\"SFO\"]},\n    {\"labels\":[[\"a\"],[],[\"b\"]],\"objects\":[\"HKG\",8054,\"JFK\"]},\n    {\"labels\":[[\"a\"],[],[\"b\"]],\"objects\":[\"AUH\",8053,\"DFW\"]},\n    {\"labels\":[[\"a\"],[],[\"b\"]],\"objects\":[\"EWR\",8047,\"HKG\"]},\n    {\"labels\":[[\"a\"],[],[\"b\"]],\"objects\":[\"DOH\",8030,\"IAH\"]},\n    {\"labels\":[[\"a\"],[],[\"b\"]],\"objects\":[\"DFW\",8022,\"DXB\"]}],\n    \"meta\":{}}}\n```\n\nWhat is being returned is useful in some cases, for example we can see\nthe *a* and *b* labels that we used in our query but in this case all we\nreally wanted was the last part with the airport codes and the\ndistances. We could decide to write code to process this JSON as-is\n(probably using a JSON helper class) and that is a valid choice you\ncould make. However by tweaking the query slightly, we can enable\nGremlin to give us back what we really wanted. Let's start by looking at\nwhat happens if we add *.toList().toString()* to the end of the query.\nTake a look at the modified form of the query below.\n\n``` java\ng.V().as('a').outE().has('dist',gt(8000)).\n      order().by('dist',desc).inV().as('b').\n      filter(select('a','b').by('code').where('a', lt('b'))).\n      path().by('code').by('dist').toList().toString()\n```\n\nIf we were to send this modified form of the query to our Gremlin\nServer, we should get back something that looks a lot more like the\nresult we got back when working with the Gremlin Console. As shown\nbelow, it is certainly a bit easier to process in your application now.\nHowever, this is still not an ideal result as what we now have is a list\ncontaining a single string with all of our routes in it.\n\n``` java\n{\"requestId\":\"63c660d0-28cf-41fc-86cf-5560a4e2fac0\",\"status\":{\"message\":\"\",\"code\":200,\"attributes\":{}},\"result\":{\"data\":[\"[[AKL, 9025, DOH], [AKL, 8818, DXB], [LAX, 8756, SIN], [CAN, 8754, MEX], [IAH, 8591, SYD], [DFW, 8574, SYD], [ATL, 8434, JNB], [SFO, 8433, SIN], [AUH, 8372, LAX], [DXB, 8321, LAX], [JED, 8314, LAX], [DOH, 8287, LAX], [LAX, 8246, RUH], [MEL, 8197, YVR], [DXB, 8150, IAH], [AUH, 8139, SFO], [DFW, 8105, HKG], [DXB, 8085, SFO], [HKG, 8054, JFK], [AUH, 8053, DFW], [EWR, 8047, HKG], [DOH, 8030, IAH], [DFW, 8022, DXB]]\"],\"meta\":{}}}\n```\n\nWe can add a little more post processing to split up our single string\ninto an array of strings where each string is a single route of the form\n*\\[AKL,9025,DOH\\]*. One way to do this is to trim off the unwanted\ncharacters at each end of the string and then use split to divide it up.\nAs there are a lot of commas in the string I could not just do a simple\n*split(\\\",\\\")* as that would not have returned what I wanted. To make\nthe split work, I replaced every occurence of *\\],* in the string with\n*\\]x* and then did the split using *split(\\\"x\\\")*. Here is the modified\nquery.\n\n``` java\ng.V().as('a').outE().has('dist',gt(8000)).\n      order().by('dist',desc).inV().as('b').\n      filter(select('a','b').by('code').where('a', lt('b'))).\n      path().by('code').by('dist').toList().toString()[1..-2].\n      replaceAll('],',']x').split('x')\n```\n\nHere is what we now get back in the returned JSON. Each route is now a\nstring in an array of strings. From here it is a simple task to extract\nthe airport names and distances for each route.\n\n``` java\n{\"requestId\":\"9d8324a8-89e4-4c1e-be59-ff433784a3da\",\n \"status\":{\"message\":\"\",\"code\":200,\"attributes\":{}},\n \"result\":{\"data\":[ \" [AKL, 9025, DOH]\",\n                    \" [AKL, 8818, DXB]\",\n                    \" [LAX, 8756, SIN]\",\n                    \" [CAN, 8754, MEX]\",\n                    \" [IAH, 8591, SYD]\",\n                    \" [DFW, 8574, SYD]\",\n                    \" [ATL, 8434, JNB]\",\n                    \" [SFO, 8433, SIN]\",\n                    \" [AUH, 8372, LAX]\",\n                    \" [DXB, 8321, LAX]\",\n                    \" [JED, 8314, LAX]\",\n                    \" [DOH, 8287, LAX]\",\n                    \" [LAX, 8246, RUH]\",\n                    \" [MEL, 8197, YVR]\",\n                    \" [DXB, 8150, IAH]\",\n                    \" [AUH, 8139, SFO]\",\n                    \" [DFW, 8105, HKG]\",\n                    \" [DXB, 8085, SFO]\",\n                    \" [HKG, 8054, JFK]\",\n                    \" [AUH, 8053, DFW]\",\n                    \" [EWR, 8047, HKG]\",\n                    \" [DOH, 8030, IAH]\",\n                    \" [DFW, 8022, DXB]\"]\n```\n\nIt's really a matter of personal preference whether you decide to have\nthe query return less data or just return the full set of data that we\ngot back from the initial query. One advantage to having the query limit\nwhat is returned is that less data, potentially a lot less data, will\nneed to be sent back to your application and stored in memory or on\ndisk. However, as, most programming languages have built in support that\nmakes it easy de serialize JSON objects into native data structures such\nas maps, you may prefer to just have all the JSON be returned and do the\nrest of the processing yourself.\n\nBy way of a simple example, if we added the following lines to our Ruby\napplication that we created in the previous section, and used the\noriginal query from before we added any post processing, we could easily\nget at the parts of the JSON that we are interested in.\n\n``` ruby\nres = JSON.parse(response.body)['result']['data']\n\nres.each do |x|\n  p x['objects']\nend\n```\n\nThe code uses Ruby's *JSON* class to convert the JSON response from the\nGremlin Server into a map data structure. We can then access each part\nof the map by the names contained in the JSON. Note that the code as\nwritten expects a specific set of keywords to be present in the JSON.\nNot all query results contain these keywords. Therefore, it would take a\nlittle more work to turn this into a more general purpose piece of code\nthat could handle any of the possible JSON return formats the server\ncould send to us. Here is the output from running the updated Ruby code.\nNotice that what we have now is a nice collection of lists, each one\ncontaining two strings and an integer. The data is now in a form that is\nreally easy and convenient to process further.\n\n``` java\n[\"AKL\", 9025, \"DOH\"]     [\"LAX\", 8246, \"RUH\"]\n[\"AKL\", 8818, \"DXB\"]     [\"MEL\", 8197, \"YVR\"]\n[\"LAX\", 8756, \"SIN\"]     [\"DXB\", 8150, \"IAH\"]\n[\"CAN\", 8754, \"MEX\"]     [\"AUH\", 8139, \"SFO\"]\n[\"IAH\", 8591, \"SYD\"]     [\"DFW\", 8105, \"HKG\"]\n[\"DFW\", 8574, \"SYD\"]     [\"DXB\", 8085, \"SFO\"]\n[\"ATL\", 8434, \"JNB\"]     [\"HKG\", 8054, \"JFK\"]\n[\"SFO\", 8433, \"SIN\"]     [\"AUH\", 8053, \"DFW\"]\n[\"AUH\", 8372, \"LAX\"]     [\"EWR\", 8047, \"HKG\"]\n[\"DXB\", 8321, \"LAX\"]     [\"DOH\", 8030, \"IAH\"]\n[\"JED\", 8314, \"LAX\"]     [\"DFW\", 8022, \"DXB\"]\n[\"DOH\", 8287, \"LAX\"]\n```\n\nIn the next section you will find more examples of the JSON that can be\nreturned by Gremlin Server and also some examples of how to reduce the\namount of data that is returned.",
        "children": []
      },
      {
        "level": "7.8",
        "title": "7.8. More examples of the JSON returned from a Gremlin Server {#serverjson}",
        "content": "The JSON returned by the Gremlin Server depends on query that is used\nand more specifically, what that query returns. Everything that is\nreturned in the *data* part of the *result* will, at the outermost level\nbe an array. What is inside that array could be a simple number or a\nstring. It could also be a list of strings or other objects including\nmaps. If you plan to write some general purpose code that can handle the\ndifferent possible formats it is important to know what they look like.\nIn the examples that follow I have attempted to show several of the\npossible response formats that you may encounter. I am mainly going to\nfocus of the parts of the JSON that follow the *data* key. Each example\nassumes that the query shown was sent to a Gremlin Server using the HTTP\nprotocol. As always, if you are unsure what JSON a particular query may\ngenerate, you should always run some experiments to find out.\n\nPlease note that some of the queries that follow may not represent the\nbest way to achieve the specific result. I have deliberately picked\nqueries that show different Gremlin steps to give you a feel for the\ntype of JSON result each generates.",
        "children": [
          {
            "level": "7.8.1",
            "title": "7.8.1. No result {#_no_result}",
            "content": "The following query does not return any results. The JSON reflects this\nin the form of the *data* returned being an empty list *\\\"\\[\\]\\\"*.\n\n``` java\ng.V().has('code','AUS').out('route').has('code','SYD')\n\n{\"requestId\":\"e68ce6d6-29a0-4a70-af35-b4e8bb123458\",\n \"status\":{\"message\":\"\",\"code\":200,\"attributes\":{}},\n \"result\":{\"data\":[],\"meta\":{}}}\n```",
            "children": []
          },
          {
            "level": "7.8.2",
            "title": "7.8.2. Integer result {#_integer_result}",
            "content": "A simple query that just returns a single integer result will generate\nJSON as shown below. The *result* section of the JSON will contain a\n*data* section with the single integer value encoded as a list with one\nmember.\n\n``` java\ng.V().count()\n\n{\"requestId\":\"25fc4d45-3e58-4f72-99b1-fe1c6575fdd0\",\n \"status\":{\"message\":\"\",\"code\":200,\"attributes\":{}},\n \"result\":{\"data\":[3624],\"meta\":{}}}\n```",
            "children": []
          },
          {
            "level": "7.8.3",
            "title": "7.8.3. String result {#_string_result}",
            "content": "As with integer results, a query that just returns a single string\nresult will generate JSON as shown below. The *result* section of the\nJSON will contain a *data* section with the single string value encoded\nas a list with one member.\n\n``` java\ng.V().has('code','DFW').values('city')\n\n{\"requestId\":\"0ae1e2af-adea-487c-b365-7ef76bb56791\",\n \"status\":{\"message\":\"\",\"code\":200,\"attributes\":{}},\n \"result\":{\"data\":[\"Dallas\"],\"meta\":{}}}\n```",
            "children": []
          },
          {
            "level": "7.8.4",
            "title": "7.8.4. List of strings {#_list_of_strings}",
            "content": "The query below generates a *data* array containing a list of strings\nrepresenting airport codes.\n\n``` java\ng.V().has('code','SAF').out().values('code')\n\n{\"requestId\":\"264cbaf8-6679-43b0-936c-f65b9f6fd0ed\",\n\"status\":{\"message\":\"\",\"code\":200,\"attributes\":{}},\n\"result\":{\"data\":[\"PHX\",\"DFW\",\"LAX\",\"DEN\"],\"meta\":{}}}\n```",
            "children": []
          },
          {
            "level": "7.8.5",
            "title": "7.8.5. List of integers {#_list_of_integers}",
            "content": "The query below generates a *data* array containing a list of integers\nrepresenting runway counts. Note that in reality you would not use a\n*sack* for this, a simple *values* step will generate the same results,\nbut I wanted to show an example that uses a *sack* step.\n\n``` java\ng.withSack(0).V().has('code','SAF').out().sack(sum).by('runways').sack()\n\n{\"requestId\":\"23598951-ffa4-440d-910f-eebc6d5f620a\",\n \"status\":{\"message\":\"\",\"code\":200,\"attributes\":{}},\n \"result\":{\"data\":[3,7,4,6],\"meta\":{}}}\n```",
            "children": []
          },
          {
            "level": "7.8.6",
            "title": "7.8.6. List of mixed types {#_list_of_mixed_types}",
            "content": "It is common for a query result to contain a variety of different data\ntypes. The example below generates a list containing a string, and\ninteger and a double. Note, as we have seen before, TinkerPop does not\nguarantee the order in which results are returned so do not create any\ndependencies on that.\n\n``` java\ng.V().has('code','LGW').values('city','lat','runways')\n\n{\"requestId\":\"6043ce66-221b-49b8-a3f9-6131eef3b9c2\",\n \"status\":{\"message\":\"\",\"code\":200,\"attributes\":{}},\n \"result\":{\"data\":[\"London\",2,51.1481018066406],\"meta\":{}}}\n```",
            "children": []
          },
          {
            "level": "7.8.7",
            "title": "7.8.7. Value map {#_value_map}",
            "content": "As you might expect, when a *valueMap* is used to generate the result\nfrom a query, the JSON generated also contains a map. Note how each\nproperty value is encoded in a list even if there is only one value.\n\n``` java\ng.V().has('code','CDG').valueMap()\n\n{\"requestId\":\"c989a182-aa97-4ed7-bddb-7f0e3ad237d6\",\n    \"status\":{\"message\":\"\",\"code\":200,\"attributes\":{}},\n    \"result\":{\"data\":[{\n       \"country\":[\"FR\"],\n          \"code\":[\"CDG\"],\n       \"longest\":[13829],\n          \"city\":[\"Paris\"],\n          \"elev\":[392],\n          \"icao\":[\"LFPG\"],\n           \"lon\":[2.54999995232],\n          \"type\":[\"airport\"],\n        \"region\":[\"FR-J\"],\n       \"runways\":[4],\n           \"lat\":[49.0127983093],\n          \"desc\":[\"Paris Charles de Gaulle\"]}],\"meta\":{}}}\n```",
            "children": []
          },
          {
            "level": "7.8.8",
            "title": "7.8.8. Single vertex {#_single_vertex}",
            "content": "When your query returns a vertex, unlike in the Gremlin Console where\nyou would get back something like \\\"*v\\[51\\]*\\\" when talking to the\nGremlin Server what you get back is a JSON object representing\neverything that is known about the vertex including its ID , label,\nproperties and the ID of each property. If you do not need the entire\nvertex returned it might be worth writing your query in a way such that\nyou only get back the properties that you are interested in. This is\nespecially pertinent if your query could potentially return a lot of\nvertices in the result.\n\n``` java\ng.V().has('code','CDG')\n\n{\"requestId\":\"a70cab32-73a5-492f-a00b-0c7d66485b18\",\n    \"status\":{\"message\":\"\",\"code\":200,\"attributes\":{}},\n    \"result\":{\"data\":\n       [{\"id\":69736,\n      \"label\":\"airport\",\n      \"type\":\"vertex\",\n\"properties\":\n     {\"country\":[{\"id\":\"2e4t-1ht4-8p1\", \"value\":\"FR\"}],\n         \"code\":[{\"id\":\"2ej1-1ht4-5j9\",\"value\":\"CDG\"}],\n      \"longest\":[{\"id\":\"2ex9-1ht4-mx1\",\"value\":13829}],\n         \"city\":[{\"id\":\"2fbh-1ht4-7wl\",\"value\":\"Paris\"}],\n         \"elev\":[{\"id\":\"2fpp-1ht4-but\",\"value\":392}],\n         \"icao\":[{\"id\":\"2g3x-1ht4-6bp\",\"value\":\"LFPG\"}],\n         \" lon\":[{\"id\":\"2gi5-1ht4-dfp\",\"value\":2.54999995232}],\n         \"type\":[{\"id\":\"2gwd-1ht4-745\",\"value\":\"airport\"}],\n       \"region\":[{\"id\":\"2hal-1ht4-9hh\",\"value\":\"FR-J\"}],\n      \"runways\":[{\"id\":\"2hot-1ht4-b2d\",\"value\":4}],\n          \"lat\":[{\"id\":\"2i31-1ht4-cn9\",\"value\":49.0127983093}],\n         \"desc\":[{\"id\":\"2ih9-1ht4-a9x\",\"value\":\"Paris Charles de Gaulle\"}]}}],\n    \"meta\":{}}}\n```",
            "children": []
          },
          {
            "level": "7.8.9",
            "title": "7.8.9. Selected vertex information {#_selected_vertex_information}",
            "content": "One way to limit the amount of JSON we get back is shown below. Let's\nassume for a selection of airport vertices, all we are interested in is\nthe ID, airport code and city name. We can construct a query, as shown\nbelow, that will return just those values for each vertex.\n\n``` java\ng.V().hasLabel('airport').sample(3).\n      union(id(),values('code','city'))\n\n{\"requestId\":\"4d308287-9725-4fa6-8c2b-b7e517ca5009\",\n \"status\":{\"message\":\"\",\"code\":200,\"attributes\":{}},\n \"result\":{\"data\":[45096,\"SCL\",\"Santiago\",\n                  610336,\"YWK\",\"Wabush\",\n                  163880,\"CAK\",\"Akron\"],\"meta\":{}}}\n```",
            "children": []
          },
          {
            "level": "7.8.10",
            "title": "7.8.10. Single edge {#_single_edge}",
            "content": "Just as when we queried a single vertex, when we query a single edge, we\nget back a lot of information including its label and ID and information\nabout the vertices the edge is connected to.\n\n``` java\ng.V().has('code','SAF').outE().limit(1)\n\n{\"requestId\":\"cac0a975-33a0-4714-a797-1be782201a27\",\n \"status\":{\"message\":\"\",\"code\":200,\"attributes\":{}},\n \"result\":{\"data\":[{\"\n        id\":\"2xhcd-1560-pat-39s\",\n    \"label\":\"route\",\n     \"type\":\"edge\",\"inVLabel\":\"airport\",\n                  \"outVLabel\":\"airport\",\"\n                         inV\":4240,\n                       \"outV\":53352,\n                 \"properties\":{\"dist\":369}}],\"meta\":{}}}\n```",
            "children": []
          },
          {
            "level": "7.8.11",
            "title": "7.8.11. New vertex {#_new_vertex}",
            "content": "When a new vertex and some properties are added the returned JSON will\ncontain all of the information about the vertex including its ID, label\nand type as well as its properties.\n\n``` java\ng.addV('test').property('fruit','apple')\n\n{\"requestId\":\"accd4354-0db9-417d-927f-c0945e1721dc\",\n \"status\":{\"message\":\"\",\"code\":200,\"attributes\":{}},\n \"result\":{\"data\":[{\"id\":4248,\n          \"label\":\"test\",\n           \"type\":\"vertex\",\n     \"properties\":{\"fruit\":[{\"id\":\"177-3a0-28lh\",\n                          \"value\":\"apple\"}]}}],\"meta\":{}}}\n```",
            "children": []
          },
          {
            "level": "7.8.12",
            "title": "7.8.12. New vertex only returning the ID {#_new_vertex_only_returning_the_id}",
            "content": "When adding a new vertex, if you are not really interested in getting\nback the entire new vertex and its properties, you can write the query\nto only return the ID of the new vertex as shown below.\n\n``` java\ng.addV('test').as('a').property('fruit','apple').select('a').id()\n\n{\"requestId\":\"c50d0fa7-5caa-4294-8eca-310f032b1c42\",\n \"status\":{\"message\":\"\",\"code\":200,\"attributes\":{}},\n \"result\":{\"data\":[8344],\"meta\":{}}}\n```",
            "children": []
          },
          {
            "level": "7.8.13",
            "title": "7.8.13. Path by value (list of strings) {#_path_by_value_list_of_strings}",
            "content": "The query below returns a path between two airports as a list of airport\ncodes. Note the new *objects* key that is used when the returned JSON\nrepresents a path.\n\n``` java\ng.V().has('code','SAF').out().path().by('code').limit(1)\n\n{\"requestId\":\"b9a1655f-1b14-4313-96d0-085858f47de7\",\n \"status\":{\"message\":\"\",\"code\":200,\"attributes\":{}},\n \"result\":{\"data\":[{\"labels\":[[],[]],\n                   \"objects\":[\"SAF\",\"PHX\"]}],\"meta\":{}}}\n```",
            "children": []
          },
          {
            "level": "7.8.14",
            "title": "7.8.14. Path by values (list of strings and integers) {#_path_by_values_list_of_strings_and_integers}",
            "content": "Similar to the previous query but this time the path also includes the\ndistance between the airports.\n\n``` java\ng.V().has('code','SAF').outE().inV().path().by('code').by('dist').limit(1)\n\n\n{\"requestId\":\"c4eb3141-be1e-4335-aa04-50843f73838b\",\n    \"status\":{\"message\":\"\",\"code\":200,\"attributes\":{}},\n    \"result\":{\"data\":[{\"labels\":[[],[],[]],\n                      \"objects\":[\"SAF\",369,\"PHX\"]}],\"meta\":{}}}\n```",
            "children": []
          },
          {
            "level": "7.8.15",
            "title": "7.8.15. Two vertex path {#_two_vertex_path}",
            "content": "The query below returns a path but does not include a *by* modulator so\nwhat is returned is the two vertices along with their IDs, labels and\nproperties.\n\n``` java\ng.V().has('code','SAF').out().path().limit(1)\n\n{\"requestId\":\"bcdc3113-d1f6-41cf-b2ad-b1409646677e\",\n    \"status\":{\"message\":\"\",\"code\":200,\"attributes\":{}},\n    \"result\":{\"data\":[{\"labels\":[[],[]],\n           \"objects\":[{\n              \"id\":53352,\n           \"label\":\"airport\",\n            \"type\":\"vertex\",\n      \"properties\":{\n         \"country\":[{\"id\":\"1s0d-1560-8p1\",\"value\":\"US\"}],\n             \"code\":[{\"id\":\"1sel-1560-5j9\",\"value\":\"SAF\"}],\n          \"longest\":[{\"id\":\"1sst-1560-mx1\",\"value\":8366}],\n             \"city\":[{\"id\":\"1t71-1560-7wl\",\"value\":\"Santa Fe\"}],\n             \"elev\":[{\"id\":\"1tl9-1560-but\",\"value\":6348}],\n             \"icao\":[{\"id\":\"1tzh-1560-6bp\",\"value\":\"KSAF\"}],\n              \"lon\":[{\"id\":\"1udp-1560-dfp\",\"value\":-106.088996887}],\n             \"type\":[{\"id\":\"1urx-1560-745\",\"value\":\"airport\"}],\n           \"region\":[{\"id\":\"1v65-1560-9hh\",\"value\":\"US-NM\"}],\n          \"runways\":[{\"id\":\"1vkd-1560-b2d\",\"value\":3}],\n              \"lat\":[{\"id\":\"1vyl-1560-cn9\",\"value\":35.617099762}],\n             \"desc\":[{\"id\":\"1wct-1560-a9x\",\"value\":\"Santa Fe\"}]}},\n\n             {\"id\":4240,\n           \"label\":\"airport\",\n            \"type\":\"vertex\",\n      \"properties\":{\n          \"country\":[{\"id\":\"176-39s-8p1\",\"value\":\"US\"}],\n             \"code\":[{\"id\":\"1le-39s-5j9\",\"value\":\"PHX\"}],\n          \"longest\":[{\"id\":\"1zm-39s-mx1\",\"value\":11489}],\n             \"city\":[{\"id\":\"2du-39s-7wl\",\"value\":\"Phoenix\"}],\n             \"elev\":[{\"id\":\"2s2-39s-but\",\"value\":1135}],\n             \"icao\":[{\"id\":\"36a-39s-6bp\",\"value\":\"KPHX\"}],\n              \"lon\":[{\"id\":\"3ki-39s-dfp\",\"value\":-112.012001037598}],\n             \"type\":[{\"id\":\"3yq-39s-745\",\"value\":\"airport\"}],\n           \"region\":[{\"id\":\"4cy-39s-9hh\",\"value\":\"US-AZ\"}],\n          \"runways\":[{\"id\":\"4r6-39s-b2d\",\"value\":3}],\n              \"lat\":[{\"id\":\"55e-39s-cn9\",\"value\":33.4342994689941}],\n             \"desc\":[{\"id\":\"5jm-39s-a9x\",\n              \"value\":\"Phoenix Sky Harbor International Airport\"}]}}]}],\n      \"meta\":{}}}\n```",
            "children": []
          },
          {
            "level": "7.8.16",
            "title": "7.8.16. Path with two vertices and an edge {#_path_with_two_vertices_and_an_edge}",
            "content": "The following query is similar to the previous one but also includes an\nedge. You can hopefully see here how the JSON can rapidly get large if\nwe are not more specific in our queries about what results we really\nneed back. Notice how, because this is a path result, most of the data\nis contained inside an *objects* key.\n\n``` java\ng.V().has('code','SAF').outE().inV().path().limit(1)\n\n{\"requestId\":\"171d0f30-2f93-4ae6-a421-4601a35388a2\",\n \"status\":{\"message\":\"\",\"code\":200,\"attributes\":{}},\n  \"result\":{\"data\":[{\"labels\":[[],[],[]],\n  \"objects\":[\n       {\"id\":53352,\"label\":\"airport\",\"type\":\"vertex\",\n       \"properties\":\n           {\"country\":[{\"id\":\"1s0d-1560-8p1\",\"value\":\"US\"}],\n           \"code\":[{\"id\":\"1sel-1560-5j9\",\"value\":\"SAF\"}],\n           \"longest\":[{\"id\":\"1sst-1560-mx1\",\"value\":8366}],\n           \"city\":[{\"id\":\"1t71-1560-7wl\",\"value\":\"Santa Fe\"}],\n           \"elev\":[{\"id\":\"1tl9-1560-but\",\"value\":6348}],\n           \"icao\":[{\"id\":\"1tzh-1560-6bp\",\"value\":\"KSAF\"}],\n           \"lon\":[{\"id\":\"1udp-1560-dfp\",\"value\":-106.088996887}],\n           \"type\":[{\"id\":\"1urx-1560-745\",\"value\":\"airport\"}],\n           \"region\":[{\"id\":\"1v65-1560-9hh\",\"value\":\"US-NM\"}],\n           \"runways\":[{\"id\":\"1vkd-1560-b2d\",\"value\":3}],\n           \"lat\":[{\"id\":\"1vyl-1560-cn9\",\"value\":35.617099762}],\n           \"desc\":[{\"id\":\"1wct-1560-a9x\",\"value\":\"Santa Fe\"}]}},\n\n       {\"id\":\"2xhcd-1560-pat-39s\",\n        \"label\":\"route\",\n        \"type\":\"edge\",\n        \"inVLabel\":\"airport\",\n        \"outVLabel\":\"airport\",\n        \"inV\":4240,\"outV\":53352,\n            \"properties\":{\"dist\":369}},\n\n       {\"id\":4240,\"label\":\"airport\",\"type\":\"vertex\",\n       \"properties\":\n           {\"country\":[{\"id\":\"176-39s-8p1\",\"value\":\"US\"}],\n            \"code\":[{\"id\":\"1le-39s-5j9\",\"value\":\"PHX\"}],\n            \"longest\":[{\"id\":\"1zm-39s-mx1\",\"value\":11489}],\n            \"city\":[{\"id\":\"2du-39s-7wl\",\"value\":\"Phoenix\"}],\n            \"elev\":[{\"id\":\"2s2-39s-but\",\"value\":1135}],\n            \"icao\":[{\"id\":\"36a-39s-6bp\",\"value\":\"KPHX\"}],\n            \"lon\":[{\"id\":\"3ki-39s-dfp\",\"value\":-112.012001037598}],\n            \"type\":[{\"id\":\"3yq-39s-745\",\"value\":\"airport\"}],\n            \"region\":[{\"id\":\"4cy-39s-9hh\",\"value\":\"US-AZ\"}],\n            \"runways\":[{\"id\":\"4r6-39s-b2d\",\"value\":3}],\n            \"lat\":[{\"id\":\"55e-39s-cn9\",\"value\":33.4342994689941}],\n            \"desc\":[{\"id\":\"5jm-39s-a9x\",\n              \"value\":\"Phoenix Sky Harbor International Airport\"}]}}]}],\n      \"meta\":{}}}\n```",
            "children": []
          },
          {
            "level": "7.8.17",
            "title": "7.8.17. Selection map {#_selection_map}",
            "content": "If a query ends with a *select* step that references labels defined\nearlier in the query, what is returned is a map where the labels are the\nkeys and the values are the things that the labels were attached to in\nthe query.\n\n``` java\ng.V().has('code','SAF').as('a').out().has('code','DFW').as('b').\n      select('a','b').by('code')\n\n{\"requestId\":\"af8de8e6-4137-4378-bb31-921e134d0661\",\n \"status\":{\"message\":\"\",\"code\":200,\"attributes\":{}},\n \"result\":{\"data\":[{\"a\":\"SAF\",\"b\":\"DFW\"}],\"meta\":{}}}\n```",
            "children": []
          },
          {
            "level": "7.8.18",
            "title": "7.8.18. Projected map {#_projected_map}",
            "content": "The *project* step also generates a map just as the *select* step did in\nthe previous example.\n\n``` java\ng.V().has('code','LGW').project('a','b').by('code').by(out().count())\n\n\n{\"requestId\":\"57819d0b-c27e-40d7-a89a-e69a6b4872a1\",\n \"status\":{\"message\":\"\",\"code\":200,\"attributes\":{}},\n \"result\":{\"data\":[{\"a\":\"LGW\",\"b\":204}],\"meta\":{}}}\n```",
            "children": []
          },
          {
            "level": "7.8.19",
            "title": "7.8.19. Strings and a map {#_strings_and_a_map}",
            "content": "The following path query returns a list containing two strings\nrepresenting airport codes and the full JSON object representing an\nedge.\n\n``` java\ng.V().has('code','SAF').outE().inV().limit(1).path().by('code').by()\n\n{\"requestId\":\"5102bb14-e594-41ec-8643-89882377b1e7\",\n \"status\":{\"message\":\"\",\"code\":200,\"attributes\":{}},\n \"result\":{\"data\":[{\"labels\":[[],[],[]],\n           \"objects\":[\"SAF\",\n                      {\"id\":\"2xhcd-1560-pat-39s\",\n                      \"label\":\"route\",\n                      \"type\":\"edge\",\n                      \"inVLabel\":\"airport\",\n                      \"outVLabel\":\"airport\",\n                      \"inV\":4240,\n                      \"outV\":53352,\n                      \"properties\":{\"dist\":369}},\n                      \"PHX\"]}],\"meta\":{}}}\n```",
            "children": []
          },
          {
            "level": "7.8.20",
            "title": "7.8.20. Nested lists {#_nested_lists}",
            "content": "When using the console or issuing Gremlin commands via the TinkerPop API\nfrom an application program, ending a query with a *fold* step can be a\nnice way to put all the results into a list. When working with a Gremlin\nServer, ending a query with a *fold* step in many cases is redundant as\nthe results will be placed in a list inside the JSON anyway. In the\nexample below, the *fold* step simply caused an extra list to be nested\ninside the one that was generated while the JSON was being assembled.\n\n``` java\ng.V().has('region','US-OK').values('code').fold()\n\n\n{\"requestId\":\"edcea305-086d-4f8d-b79a-ff72c5a26847\",\n \"status\":{\"message\":\"\",\"code\":200,\"attributes\":{}},\n \"result\":{\"data\":[[\"OKC\",\"TUL\",\"LAW\",\"SWO\"]],\"meta\":{}}}\n```",
            "children": []
          }
        ]
      }
    ]
  },
  {
    "level": "8",
    "title": "8. COMMON GRAPH SERIALIZATION FORMATS {#serialize}",
    "content": "There are a number of ways that graph data can be stored in a file. In\nthis section I have provided a brief overview of a few of them. As you\nwill see there are a number of ways you can represent graph data using\nsimple CSV files. There are also XML format, JSON formats and many more.\nOf these, the one that still seems to be supported across most tools and\nplatforms is GraphML. Not all of the features offered by Apache\nTinkerPop can be expressed using GraphML however. So let's take a look\nat some of the more commonly used formats.",
    "children": [
      {
        "level": "8.1",
        "title": "8.1. Comma Separated Values (CSV) {#csv}",
        "content": "There are a number of ways that a graph can be stored using CSV files.\nThere is no single preferred format that I am aware of. However, a\ncommon and convenient way, especially when vertices contain lots of\nproperties is to use two CSV files. One will contain all of the vertex\ndata and the other will contain all of the edge data.",
        "children": [
          {
            "level": "8.1.1",
            "title": "8.1.1. Using two CSV files to represent the air-routes data {#csvair}",
            "content": "If we were to store the airport data from the *air-routes* graph in CSV\nformat we might do something like the example below. Note that to\nimprove readability I have not included every property (or indeed every\nairport) in this example. Notice how each vertex has a unique ID\nassigned. This is important as when we define the edges we will need the\nvertex IDs to build the connections.\n\n    \"ID\",\"LABEL\",\"CODE\",\"IATA\",\"CITY\",\"REGION\",\"RUNWAYS\",\"LONGEST\",\"ELEV\",\"COUNTRY\"\n    \"1\",\"airport\",\"ATL\",\"KATL\",\"Atlanta\",\"US-GA\",\"5\",\"12390\",\"1026\",\"US\"\n    \"2\",\"airport\",\"ANC\",\"PANC\",\"Anchorage\",\"US-AK\",\"3\",\"12400\",\"151\",\"US\"\n    \"3\",\"airport\",\"AUS\",\"KAUS\",\"Austin\",\"Austin\",\"US-TX\",\"2\",\"12250\",\"542\",\"US\"\n    \"4\",\"airport\",\"BNA\",\"KBNA\",\"Nashville\",\"US-TN\",\"4\",\"11030\",\"599\",\"US\"\n    \"5\",\"airport\",\"BOS\",\"KBOS\",\"Boston\",\"US-MA\",\"6\",\"10083\",\"19\",\"US\"\n    \"6\",\"airport\",\"BWI\",\"KBWI\",\"Baltimore\",\"US-MD\",\"3\",\"10502\",\"143\",\"US\"\n    \"7\",\"airport\",\"DCA\",\"KDCA\",\"Washington D.C.\",\"US-DC\",\"3\",\"7169\",\"14\",\"US\"\n    \"8\",\"airport\",\"DFW\",\"KDFW\",\"Dallas Ft. Worth\",\"US-TX\",\"7\",\"13401\",\"607\",\"US\"\n    \"9\",\"airport\",\"FLL\",\"KFLL\",\"Fort Lauderdale\",\"US-FL\",\"2\",\"9000\",\"64\",\"US\"\n\nFor the route data, the edges in our graph, we might use a format like\nthe one below. I did not include an edge ID as we typically let the\ngraph system assign those. For completeness I did include a label\nhowever when every edge is of the same type you could choose to leave\nthis out so long as the program ingesting the data knew what label to\nassign. Most graph systems require edges to have a label even if it is\noptional for vertices. This is equally true for the airport data.\nHowever, in cases where vertices and edges within the same CSV file are\nof different types then clearly for those cases it is best to always\ninclude the label for each entry.\n\n    \"LABEL\",\"FROM\",\"TO\",\"DIST\"\n    \"route\",1,3,811\n    \"route\",1,4,214\n    \"route\",2,8,3036\n    \"route\",3,4,755\n    \"route\",4,6,586\n    \"route\",5,1,945\n\nSome graph systems provide ingestion tools that, when presented with a\nCSV file like the ones we have shown here can figure out how to process\nthem and build a graph. However, in many other situations you may also\nfind yourself writing your own scripts or small programs to do it.\n\nI often find myself writing Ruby or Groovy scripts that can generate CSV\nor GraphML files so that a graph system can ingest them. In some cases I\nhave used scripts to take CSV or GraphML data and generate the Gremlin\nstatements that would create the graph. This is very similar to another\ncommon practice, namely, using a script to generate *INSERT* statements\nwhen working with SQL databases.\n\nI have also written Java and Groovy programs that will read the CSV file\nand use the TinkerPop API or the Gremlin Server REST API to insert\nvertices and edges into a graph. If you work with graph systems for a\nwhile you will probably find yourself also doing similar things.",
            "children": []
          },
          {
            "level": "8.1.2",
            "title": "8.1.2. Adjacency matrix format {#_adjacency_matrix_format}",
            "content": "The examples shown above of how a CSV file can be used to store data\nabout vertices and edges presents a convenient way to do it. However,\nthis is by no means the only way you could do it. For graphs that do not\ncontain properties you could lay the graph out using an *adjacency\nmatrix* as shown below. The letters represent the vertex labels and a 1\nindicates there is an edge between them and a zero indicates no edge.\nThis format can be useful if your vertices and edges do not have\nproperties and if the graph is small but in general is not a great way\nto try and represent large graphs.\n\n    A,B,C,D,E,F,G\n    A,0,1,1,0,1,0,1\n    B,1,0,0,1,0,1,0\n    C,1,1,0,1,1,0,1\n    D,0,1,1,0,1,0,1\n    E,0,0,0,1,0,1,0\n    F,1,1,0,1,0,0,1\n    G,1,1,1,0,1,1,0",
            "children": []
          },
          {
            "level": "8.1.3",
            "title": "8.1.3. Adjacency List format {#_adjacency_list_format}",
            "content": "The adjacency matrix shown above could also be represented as an\n*adjacency list*. In this case, the first column of each row represents\na vertex. The remaining parts of each row represent all of the other\nvertices that this vertex is connected to.\n\n    A,C,D,F,G\n    B,A,D,F\n    C,A,B,D,E,1\n    D,B,C,E,G\n    E,D,E\n    F,A,B,D,G\n    G,A,B,C,E,F\n\nWhile this is a simple example, it is possible to represent a more\ncomplex graph such as the *air-routes* graph in this way. We could build\na more complex CSV file where the vertex and its properties are listed\nfirst, followed by all of the other vertices it connects to and the\nproperties for those edges.\n\nSome graph database systems actually store their graphs to disk using a\nvariation of this format. JanusGraph in fact uses a system a lot like\nthis when storing vertex and edge data to its persistent store.",
            "children": []
          },
          {
            "level": "8.1.4",
            "title": "8.1.4. Edge List format {#_edge_list_format}",
            "content": "When using an *edge list* format, each line represents an edge. So our\nsimple example could be represented as follows. Only a few edges are\nshown.\n\n    A,C\n    A,D\n    A,F\n    A,G\n    B,A\n    B,D\n    B,F\n    C,A\n    C,B\n\nThere are many ways you could construct an edge list. By way of another\nsimple example we could represent routes in the *air-routes* graph in a\nformat similar to that shown below. In this case we also include the\nlabel of the edge between each of the vertices. The vertices are\nrepresented by their ID value.\n\n    [1,route,623]\n    [1,route,624]\n    [1,route,625]\n    [1,route,626]\n    [1,route,627]\n    [1,route,628]\n    [1,route,629]\n    [1,route,630]\n    [1,route,631]\n    [1,route,632]\n\nIf you wanted to export a very simple version of the *air-routes* graph,\nusing just the airport IATA codes and the edge labels you could write a\nGremlin query to do it for you as follows. Only the first 10 results\nreturned are shown.\n\n``` java\ng.V().outE().inV().path().by('code').by(label)\n\n[ATL,route,MBS]\n[ATL,route,MCN]\n[ATL,route,MEI]\n[ATL,route,MLB]\n[ATL,route,MSL]\n[ATL,route,PHF]\n[ATL,route,PIB]\n[ATL,route,SBN]\n[ATL,route,TRI]\n[ATL,route,TTN]\n```\n\n::: tip\nThere is a sample program called GraphFromCSV.java in the sample\nprograms folder that shows how to read a CSV file like the one above and\ncreate a graph from it.\n:::\n\nIf you wanted to print the list without the containing square brackets\nyou could take advantage of the Java *forEachRemaining* method from the\nIterator interface to add a bit of post processing to the end of the\nquery. Once again only the first 10 results are shown.\n\n``` java\ng.V().outE().inV().path().by('code').by(label).\n      forEachRemaining{println it[0] + ',' + it[1] + ',' + it[2]}\n\nATL,route,MBS\nATL,route,MCN\nATL,route,MEI\nATL,route,MLB\nATL,route,MSL\nATL,route,PHF\nATL,route,PIB\nATL,route,SBN\nATL,route,TRI\nATL,route,TTN\n```",
            "children": []
          }
        ]
      },
      {
        "level": "8.2",
        "title": "8.2. GraphML {#_graphml}",
        "content": "To be written\n\n``` xml\n<?xml version='1.0' ?>\n<!-- ******************************************************* -->\n<!-- Small sample taken from the air-routes.graphml file.    -->\n<!-- ******************************************************* -->\n\n<graphml xmlns='http://graphml.graphdrawing.org/xmlns'>\n  <key id='type'    for='node' attr.name='type'    attr.type='string'></key>\n  <key id='code'    for='node' attr.name='code'    attr.type='string'></key>\n  <key id='icao'    for='node' attr.name='icao'    attr.type='string'></key>\n  <key id='desc'    for='node' attr.name='desc'    attr.type='string'></key>\n  <key id='region'  for='node' attr.name='region'  attr.type='string'></key>\n  <key id='runways' for='node' attr.name='runways' attr.type='int'></key>\n  <key id='longest' for='node' attr.name='longest' attr.type='int'></key>\n  <key id='elev'    for='node' attr.name='elev'    attr.type='int'></key>\n  <key id='country' for='node' attr.name='country' attr.type='string'></key>\n  <key id='city'    for='node' attr.name='city'    attr.type='string'></key>\n  <key id='lat'     for='node' attr.name='lat'     attr.type='double'></key>\n  <key id='lon'     for='node' attr.name='lon'     attr.type='double'></key>\n  <key id='dist'    for='edge' attr.name='dist'    attr.type='int'></key>\n  <key id='labelV'  for='node' attr.name='labelV'  attr.type='string'></key>\n  <key id='labelE'  for='edge' attr.name='labelE'  attr.type='string'></key>\n\n  <graph id='routes' edgedefault='directed'>\n\n    <node id='1'>\n    <data key='labelV'>airport</data>\n    <data key='type'>airport</data>\n    <data key='code'>ATL</data>\n    <data key='icao'>KATL</data>\n    <data key='city'>Atlanta</data>\n    <data key='desc'>Hartsfield - Jackson Atlanta International Airport</data>\n    <data key='region'>US-GA</data>\n    <data key='runways'>5</data>\n    <data key='longest'>12390</data>\n    <data key='elev'>1026</data>\n    <data key='country'>US</data>\n    <data key='lat'>33.6366996765137</data>\n    <data key='lon'>-84.4281005859375</data>\n  </node>\n\n  <edge id='3610' source='1' target='3'>\n    <data key='labelE'>route</data>\n    <data key='dist'>811</data>\n  </edge>\n\n  </graph>\n</graphml>\n```",
        "children": []
      },
      {
        "level": "8.3",
        "title": "8.3. GraphSON {#_graphson}",
        "content": "As discussed in the \\\"[Working with GraphML and\nGraphSON](#graphmlandjsonintro)\\\" section, since TinkerPop 3.2.2 there\nhave been multiple versions of the GraphSON format. The original 1.0\nversion did not contain any type information. Version 2.0 introduced the\nconcept of including data types within the JSON. As part of TinkerPop\n3.3 GraphSON 3.0 was introduced to add a few additional types. All three\nformats are still supported. The default is now GraphSON 3.0.\n\nTo be written\n\n``` java\ngraph=TinkerGraph.open()\ng=graph.traversal()\ng.addV('airport').property('code','AUS').as('aus').\n  addV('airport').property('code','DFW').as('dfw').\n  addV('airport').property('code','LAX').as('lax').\n  addV('airport').property('code','JFK').as('jfk').\n  addV('airport').property('code','ATL').as('atl').\n  addE('route').from('aus').to('dfw').\n  addE('route').from('aus').to('atl').\n  addE('route').from('atl').to('dfw').\n  addE('route').from('atl').to('jfk').\n  addE('route').from('dfw').to('jfk').\n  addE('route').from('dfw').to('lax').\n  addE('route').from('lax').to('jfk').\n  addE('route').from('lax').to('aus').\n  addE('route').from('lax').to('dfw')\n```",
        "children": [
          {
            "level": "8.3.1",
            "title": "8.3.1. Adjacency list format GraphSON {#_adjacency_list_format_graphson}",
            "content": "To be written\n\n``` json\n{\"id\":0,\"label\":\"airport\",\"inE\":{\"route\":[{\"id\":17,\"outV\":4}]}, ... }\n{\"id\":2,\"label\":\"airport\",\"inE\":{\"route\":[{\"id\":18,\"outV\":4}, ... ]}}\n{\"id\":4,\"label\":\"airport\",\"inE\":{\"route\":[{\"id\":15,\"outV\":2}]}, ... }\n{\"id\":6,\"label\":\"airport\",\"inE\":{\"route\":[{\"id\":16,\"outV\":4}, ... ]}}\n{\"id\":8,\"label\":\"airport\",\"inE\":{\"route\":[{\"id\":11,\"outV\":0}]}, ... }\n```\n\n``` json\n{\n    \"id\": 0,\n    \"label\": \"airport\",\n    \"inE\": {\n        \"route\": [{\n            \"id\": 17,\n            \"outV\": 4\n        }]\n    },\n    \"outE\": {\n        \"route\": [{\n            \"id\": 10,\n            \"inV\": 2\n        }, {\n            \"id\": 11,\n            \"inV\": 8\n        }]\n    },\n    \"properties\": {\n        \"code\": [{\n            \"id\": 1,\n            \"value\": \"AUS\"\n        }]\n    }\n}\n```\n\n``` json\n{\"id\":197,\"label\":\"airport\",\"inE\":{\"contains\":[{\"id\":46566,\"outV\":3378},{\"id\":49931,\"outV\":3608}],\"route\":[{\"id\":9524,\"outV\":55,\"properties\":{\"dist\":520}},{\"id\":9753,\"outV\":57,\"properties\":{\"dist\":903}},{\"id\":22158,\"outV\":231,\"properties\":{\"dist\":1036}}]},\"outE\":{\"route\":[{\"id\":20448,\"inV\":231,\"properties\":{\"dist\":1036}},{\"id\":20446,\"inV\":55,\"properties\":{\"dist\":520}},{\"id\":20447,\"inV\":57,\"properties\":{\"dist\":903}}]},\"properties\":{\"country\":[{\"id\":2356,\"value\":\"AU\"}],\"code\":[{\"id\":2357,\"value\":\"MCY\"}],\"longest\":[{\"id\":2358,\"value\":5896}],\"city\":[{\"id\":2359,\"value\":\"Maroochydore\"}],\"elev\":[{\"id\":2360,\"value\":15}],\"icao\":[{\"id\":2361,\"value\":\"YBSU\"}],\"lon\":[{\"id\":2362,\"value\":153.091003418}],\"type\":[{\"id\":2363,\"value\":\"airport\"}],\"region\":[{\"id\":2364,\"value\":\"AU-QLD\"}],\"runways\":[{\"id\":2365,\"value\":2}],\"lat\":[{\"id\":2366,\"value\":-26.6033000946}],\"desc\":[{\"id\":2367,\"value\":\"Sunshine Coast Airport\"}]}}\n```",
            "children": []
          },
          {
            "level": "8.3.2",
            "title": "8.3.2. Wrapped adjacency list format GraphSON {#_wrapped_adjacency_list_format_graphson}",
            "content": "To be written\n\n``` json\n{\n    \"vertices\": [{\n        \"id\": 0,\n        \"label\": \"airport\",\n        \"inE\": {\n            \"route\": [{\n                \"id\": 17,\n                \"outV\": 4\n            }]\n        },\n        \"outE\": {\n            \"route\": [{\n                \"id\": 10,\n                \"inV\": 2\n            }, {\n                \"id\": 11,\n                \"inV\": 8\n            }]\n        },\n        \"properties\": {\n            \"code\": [{\n                \"id\": 1,\n                \"value\": \"AUS\"\n            }]\n        }\n    }, {\n        \"id\": 2,\n        \"label\": \"airport\",\n        \"inE\": {\n            \"route\": [{\n                \"id\": 18,\n                \"outV\": 4\n            }, {\n                \"id\": 10,\n                \"outV\": 0\n            }, {\n                \"id\": 12,\n                \"outV\": 8\n            }]\n        },\n        \"outE\": {\n            \"route\": [{\n                \"id\": 14,\n                \"inV\": 6\n            }, {\n                \"id\": 15,\n                \"inV\": 4\n            }]\n        },\n        \"properties\": {\n            \"code\": [{\n                \"id\": 3,\n                \"value\": \"DFW\"\n            }]\n        }\n    }, {\n        \"id\": 4,\n        \"label\": \"airport\",\n        \"inE\": {\n            \"route\": [{\n                \"id\": 15,\n                \"outV\": 2\n            }]\n        },\n        \"outE\": {\n            \"route\": [{\n                \"id\": 16,\n                \"inV\": 6\n            }, {\n                \"id\": 17,\n                \"inV\": 0\n            }, {\n                \"id\": 18,\n                \"inV\": 2\n            }]\n        },\n        \"properties\": {\n            \"code\": [{\n                \"id\": 5,\n                \"value\": \"LAX\"\n            }]\n        }\n    }, {\n        \"id\": 6,\n        \"label\": \"airport\",\n        \"inE\": {\n            \"route\": [{\n                \"id\": 16,\n                \"outV\": 4\n            }, {\n                \"id\": 13,\n                \"outV\": 8\n            }, {\n                \"id\": 14,\n                \"outV\": 2\n            }]\n        },\n        \"properties\": {\n            \"code\": [{\n                \"id\": 7,\n                \"value\": \"JFK\"\n            }]\n        }\n    }, {\n        \"id\": 8,\n        \"label\": \"airport\",\n        \"inE\": {\n            \"route\": [{\n                \"id\": 11,\n                \"outV\": 0\n            }]\n        },\n        \"outE\": {\n            \"route\": [{\n                \"id\": 12,\n                \"inV\": 2\n            }, {\n                \"id\": 13,\n                \"inV\": 6\n            }]\n        },\n        \"properties\": {\n            \"code\": [{\n                \"id\": 9,\n                \"value\": \"ATL\"\n            }]\n        }\n    }]\n}\n```",
            "children": []
          }
        ]
      }
    ]
  },
  {
    "level": "9",
    "title": "9. FURTHER READING {#fr}",
    "content": "Below you will find a selection of links to additional material related\nto the topics covered in this book. The links include additional web\nsites maintained by the Apache TinkerPop community as well as some\nmailing lists where Gremlin and related topics are discussed daily.",
    "children": [
      {
        "level": "9.1",
        "title": "12.1. Additional Apache TinkerPop community links {#tplinks}",
        "content": "::: formalpara-title\n**Official Apache TinkerPop home page and Gremlin downloads**\n:::\n\n<http://tinkerpop.apache.org/>\n\n::: formalpara-title\n**Apache TinkerPop Getting Started guide**\n:::\n\n<http://tinkerpop.apache.org/docs/current/tutorials/getting-started/>\n\n::: formalpara-title\n**Current Apache TinkerPop documention**\n:::\n\n<http://tinkerpop.apache.org/docs/current/reference/>\n\n::: formalpara-title\n**Apache TinkerPop JavaDoc API reference material**\n:::\n\n<http://tinkerpop.apache.org/javadocs/current/core/>\n\n<http://tinkerpop.apache.org/javadocs/current/full/>\n\n::: formalpara-title\n**Gremlin IO serialization and file formats documentation**\n:::\n\n<http://tinkerpop.apache.org/docs/current/dev/io/>\n\n::: formalpara-title\n**Useful Gremlin \\\"recipies\\\"**\n:::\n\n<http://tinkerpop.apache.org/docs/current/recipes/>\n\n::: formalpara-title\n**Apache TinkerPop documentation describing new features per release**\n:::\n\n<http://tinkerpop.apache.org/docs/current/upgrade/>\n\n::: formalpara-title\n**Apache TinkerPop documentation for graph database providers**\n:::\n\n<http://tinkerpop.apache.org/docs/current/dev/provider/>",
        "children": [
          {
            "level": "9.1.1",
            "title": "9.1.1. Tutorials",
            "content": "There are a series of tutorials that can be found at the link below.\n\n::: formalpara-title\n**Apache TinkerPop Tutorials**\n:::\n\n<http://tinkerpop.apache.org/docs/current/tutorials/>\n\nThe tutorials include the following\n\nGetting started\n\n:   -   <http://tinkerpop.apache.org/docs/current/tutorials/getting-started/>\n\nGremlin language variants\n\n:   -   <http://tinkerpop.apache.org/docs/current/tutorials/gremlin-language-variants/>\n\nGremlin's anatomy\n\n:   -   <http://tinkerpop.apache.org/docs/current/tutorials/gremlins-anatomy/>\n\nThe Gremlin console\n\n:   -   <http://tinkerpop.apache.org/docs/current/tutorials/the-gremlin-console/>",
            "children": []
          }
        ]
      },
      {
        "level": "9.2",
        "title": "9.2. Gremlin related mailing lists and discussion groups {#gremlindiscussionlists}",
        "content": "::: formalpara-title\n**Public mailing list for Gremlin users**\n:::\n\n<https://groups.google.com/forum/#!forum/gremlin-users>\n\n::: formalpara-title\n**Apache TinkerPop developers mailing list archive**\n:::\n\n<https://lists.apache.org/>\n\n::: formalpara-title\n**Stack Overflow posts tagged with \\\"gremlin\\\"**\n:::\n\n<https://stackoverflow.com/questions/tagged/gremlin>",
        "children": []
      },
      {
        "level": "9.3",
        "title": "9.3. JanusGraph links {#janusgraphlinks}",
        "content": "::: formalpara-title\n**JanusGraph home page**\n:::\n\n<http://janusgraph.org/>\n\n::: formalpara-title\n**JanusGraph overview documentation**\n:::\n\n<http://docs.janusgraph.org/latest/>\n\n::: formalpara-title\n**JanusGraph API documentation**\n:::\n\n<http://docs.janusgraph.org/latest/javadoc.html>\n\n::: formalpara-title\n**Public mailing list for JanusGraph users**\n:::\n\n<https://groups.google.com/forum/#!forum/janusgraph-users>\n\n::: formalpara-title\n**Stack Overflow posts tagged with \\\"janusgraph\\\"**\n:::\n\n<https://stackoverflow.com/questions/tagged/janusgraph>",
        "children": []
      }
    ]
  }
]