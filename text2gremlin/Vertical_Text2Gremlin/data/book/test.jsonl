{"chunk_content": "We can also run a similar query to find out the distribution of edge\nlabels in the graph. An example of the type of result we would get back\nis also shown.\n\n``` java\n// How many of each type of edge are there?\ng.E().groupCount().by(label)\n\n[contains:6748,route:43400]\n```\n\nAs before we could rewrite the query as follows.\n\n``` java\n// How many of each type of edge are there?\ng.E().label().groupCount()\n\n[contains:6748,route:43400]\n```", "metadata": {"source_file": "Gremlin-Graph-Guide.md", "hierarchy": {"level_1_title": "3. WRITING GREMLIN QUERIES {#gq}", "level_2_title": "3.2. Some fairly basic Gremlin queries {#bq}", "level_3_title": "3.2.4. Counting groups of things {#countgroup}"}, "chunk_id": "C3_2_4_chunk_3", "word_count": 78}}
{"chunk_content": "``` java\n// How many of each type of edge are there?\ng.E().label().groupCount()\n\n[contains:6748,route:43400]\n```\n\nBy way of a side note, the examples above are shorthand ways of writing\nsomething like this example which also counts vertices by label.\n\n``` java\n// As above but using group()\ng.V().group().by(label).by(count())\n\n[continent:7,country:237,version:1,airport:3374]\n```\n\nWe can be more selective in how we specify the groups of things that we\nwant to count. In the examples below we first count how many airports\nthere are in each country. This will return a map of key:value pairs\nwhere the key is the country code and the value is the number of\nairports in that country. As the fourth and fifth examples show, we can\nuse *select* to pick just a few values from the whole group that got\ncounted. Of course if we only wanted a single value we could just count\nthe airports connected to that country directly but the last two\nexamples are intended to show that you can count a group of things and\nstill selectively only look at part of that group.", "metadata": {"source_file": "Gremlin-Graph-Guide.md", "hierarchy": {"level_1_title": "3. WRITING GREMLIN QUERIES {#gq}", "level_2_title": "3.2. Some fairly basic Gremlin queries {#bq}", "level_3_title": "3.2.4. Counting groups of things {#countgroup}"}, "chunk_id": "C3_2_4_chunk_4", "word_count": 194}}
{"chunk_content": "We can be more selective in how we specify the groups of things that we\nwant to count. In the examples below we first count how many airports\nthere are in each country. This will return a map of key:value pairs\nwhere the key is the country code and the value is the number of\nairports in that country. As the fourth and fifth examples show, we can\nuse *select* to pick just a few values from the whole group that got\ncounted. Of course if we only wanted a single value we could just count\nthe airports connected to that country directly but the last two\nexamples are intended to show that you can count a group of things and\nstill selectively only look at part of that group.\n\n``` java\n// How many airports are there in each country?\ng.V().hasLabel('airport').groupCount().by('country')\n\n// How many airports are there in each country? (look at country first)\ng.V().hasLabel('country').group().by('code').by(out().count())\n```\n\nWe can easily find out how many airports there are in each continent\nusing *group* to build a map of continent codes and the number of\nairports in that continent. The output from running the query is shown\nbelow also.\n\n``` java\n// How many airports are there in each continent?\ng.V().hasLabel('continent').group().by('code').by(out().count())\n\n[EU:583,AS:932,NA:978,OC:284,AF:294,AN:0,SA:303]\n```", "metadata": {"source_file": "Gremlin-Graph-Guide.md", "hierarchy": {"level_1_title": "3. WRITING GREMLIN QUERIES {#gq}", "level_2_title": "3.2. Some fairly basic Gremlin queries {#bq}", "level_3_title": "3.2.4. Counting groups of things {#countgroup}"}, "chunk_id": "C3_2_4_chunk_5", "word_count": 242}}
{"chunk_content": "``` java\n// How many airports are there in each continent?\ng.V().hasLabel('continent').group().by('code').by(out().count())\n\n[EU:583,AS:932,NA:978,OC:284,AF:294,AN:0,SA:303]\n```\n\nThese queries show how *select* can be used to extract specific values\nfrom the map that we have created. Again you can see the results we get\nfrom running the query.\n\n``` java\n// How many airports are there in France (having first counted all countries)\ng.V().hasLabel('airport').groupCount().by('country').select('FR')\n\n58\n\n// How many airports are there in France, Greece and Belgium respectively?\ng.V().hasLabel('airport').groupCount().by('country').select('FR','GR','BE')\n\n[FR:58,GR:39,BE:5]\n```\n\nThe *group* and *groupCount* steps are very useful when you want to\ncount groups of things or collect things into a group using a selection\ncriteria. You will find a lot more examples of grouping and counting\nthings in the section called \\\"[Counting more things](#countmore)\\\".", "metadata": {"source_file": "Gremlin-Graph-Guide.md", "hierarchy": {"level_1_title": "3. WRITING GREMLIN QUERIES {#gq}", "level_2_title": "3.2. Some fairly basic Gremlin queries {#bq}", "level_3_title": "3.2.4. Counting groups of things {#countgroup}"}, "chunk_id": "C3_2_4_chunk_6", "word_count": 161}}
{"chunk_content": "So far we have mostly just explored queries that look at properties on a\nvertex or count how many things we can find of a certain type. Where the\npower of a graph really comes into play is when we start to *walk* or\n*traverse* the graph by looking at the connections (edges) between\nvertices. The term *walking the graph* is used to describe moving from\none vertex to another vertex via an edge. Typically when using the\nphrase *walking a graph* the intent is to describe starting at a vertex\ntraversing one or more vertices and edges and ending up at a different\nvertex or sometimes, back where you started in the case of a *circular\nwalk*. It is very easy to traverse a graph in this way using Gremlin.\nThe journey we took while on our *walk* is often referred to as our\n*path*. There are also cases when all you want to do is return edges or\nsome combination of vertices and edges as the result of a query and\nGremlin allows this as well. We will explore a lot of ways to modify the\nway a graph is traversed in the upcoming sections.\n\nThe table below gives a brief summary of all the steps that can be used\nto *walk* or *traverse* a graph using Gremlin. You will find all of\nthese steps used in various ways throughout the book. Think of a graph\ntraversal as moving through the graph from one place to one or more\nother places. These steps tell Gremlin which places to move to next as\nit traverses a graph for you.\n\nIn order to better understand these steps it is worth defining some\nterminology. One vertex is considered to be *adjacent* to another vertex\nif there is an edge connecting them. A vertex and an edge are considered\n*incident* if they are connected to each other.\n\n+-------------+--------------------------------------------------------+\n\n| out \\*      | Outgoing adjacent vertices.                            |\n+-------------+--------------------------------------------------------+\n| in \\*       | Incoming adjacent vertices.                            |\n+-------------+--------------------------------------------------------+\n| both \\*     | Both incoming and outgoing adjacent vertices.          |\n+-------------+--------------------------------------------------------+\n| outE \\*     | Outgoing incident edges.                               |\n+-------------+--------------------------------------------------------+\n| inE \\*      | Incoming incident edges.                               |\n+-------------+--------------------------------------------------------+\n| bothE \\*    | Both outgoing and incoming incident edges.             |\n+-------------+--------------------------------------------------------+\n| outV        | Outgoing vertex.                                       |\n+-------------+--------------------------------------------------------+\n| inV         | Incoming vertex.                                       |\n+-------------+--------------------------------------------------------+\n| otherV      | The vertex that was not the vertex we came from.       |\n\n+-------------+--------------------------------------------------------+\n\n: Where to move next while traversing a graph\n\nNote that the steps labelled with an *\\** can optionally take the name\nof one or more edge labels as a parameter. If omitted, all relevant\nedges will be traversed.", "metadata": {"source_file": "Gremlin-Graph-Guide.md", "hierarchy": {"level_1_title": "3. WRITING GREMLIN QUERIES {#gq}", "level_2_title": "3.3. Starting to walk the graph {#walk}"}, "chunk_id": "C3_3_chunk_1", "word_count": 399}}
{"chunk_content": "To get us started, in this section we will look at some simple graph\ntraversal examples that use some of the steps that were just introduced.\nThe *out* step is used to find vertices connected by an outgoing edge to\nthat vertex and the *outE* *step* is used when you want to examine the\noutgoing edges from a given vertex. Conversely the *in* and *inE* steps\ncan be used to look for incoming vertices and edges. The *outE* and\n*inE* steps are especially useful when you want to look at the\nproperties of an edge as we shall see in the \\\"[Examining the edge\nbetween two vertices](#exedge)\\\" section. There are several other steps\nthat we can use when traversing a graph to move between vertices and\nedges. These include *bothE*, *bothV* and *otherV*. We will encounter\nthose in the \\\"[Other ways to explore vertices and edges using , , and\n](#otherv)\\\" section.\n\nSo let's use a few examples to help better understand these graph\ntraversal steps. The first query below does a few interesting things.\nFirstly we find the vertex representing the Austin airport (the airport\nwith a property of *code* containing the value *AUS*). Having found that\nvertex we then go *out* from there. This will find all of the vertices\nconnected to Austin by an outgoing edge. Having found those airports we\nthen ask for the values of their *code* properties using the *values*\nstep. Finally the *fold* step puts all of the results into a list for\nus. This just makes it easier for us to inspect the results in the\nconsole.\n\n``` java\n// Where can I fly to from Austin?\ng.V().has('airport','code','AUS').out().values('code').fold()\n```\n\nHere is what you might get back if you were to run this query in your\nconsole.\n\n``` java\n[YYZ, LHR, FRA, MEX, PIT, PDX, CLT, CUN, MEM, CVG, IND, MCI, DAL, STL, ABQ, MDW, LBB, HRL, GDL, PNS, VPS, SFB, BKG, PIE, ATL, BNA, BOS, BWI, DCA, DFW, FLL, IAD, IAH, JFK, LAX, MCO, MIA, MSP, ORD, PHX, RDU, SEA, SFO, SJC, TPA, SAN, LGB, SNA, SLC, LAS, DEN, MSY, EWR, HOU, ELP, CLE, OAK, PHL, DTW]\n```", "metadata": {"source_file": "Gremlin-Graph-Guide.md", "hierarchy": {"level_1_title": "3. WRITING GREMLIN QUERIES {#gq}", "level_2_title": "3.3. Starting to walk the graph {#walk}", "level_3_title": "3.3.1. Some simple graph traversal examples {#_some_simple_graph_traversal_examples}"}, "chunk_id": "C3_3_1_chunk_1", "word_count": 360}}
{"chunk_content": "``` java\n[YYZ, LHR, FRA, MEX, PIT, PDX, CLT, CUN, MEM, CVG, IND, MCI, DAL, STL, ABQ, MDW, LBB, HRL, GDL, PNS, VPS, SFB, BKG, PIE, ATL, BNA, BOS, BWI, DCA, DFW, FLL, IAD, IAH, JFK, LAX, MCO, MIA, MSP, ORD, PHX, RDU, SEA, SFO, SJC, TPA, SAN, LGB, SNA, SLC, LAS, DEN, MSY, EWR, HOU, ELP, CLE, OAK, PHL, DTW]\n```\n\nAll edges in a graph have a label. However, one thing we did not do in\nthe previous query was specify a label for the *out* step. If you do not\nspecify a label you will get back any connected vertex regardless of its\nedge label. In this case it does not cause us a problem as airports only\nhave one type of outgoing edge, labeled *route*. However, in many cases,\nin graphs you create or are working with, your vertices may be connected\nto other vertices by edges with differing labels so it is good practice\nto get into the habit of specifying edge labels as part of your Gremlin\nqueries. So we could change our query just a bit by adding a label\nreference on the *out* step as follows.\n\n``` java\n// Where can I fly to from Austin?\ng.V().has('airport','code','AUS').out('route').values('code').fold()\n```\n\nDespite having just stated that consistently using edge labels in\nqueries is a good idea, unless you truly do want to get back all edges\nor all connected vertices, I will break my own rule quite a bit in this\nbook. The reason for this is purely to save space and make the queries I\npresent shorter.\n\nHere are a few more simple queries similar to the previous one. The\nfirst example can be used to answer the question \\\"Where can I fly to\nfrom Austin, with one stop on the way?\\\". Note that, as written, coming\nback to Austin will be included in the results as this query does not\nrule it out!", "metadata": {"source_file": "Gremlin-Graph-Guide.md", "hierarchy": {"level_1_title": "3. WRITING GREMLIN QUERIES {#gq}", "level_2_title": "3.3. Starting to walk the graph {#walk}", "level_3_title": "3.3.1. Some simple graph traversal examples {#_some_simple_graph_traversal_examples}"}, "chunk_id": "C3_3_1_chunk_2", "word_count": 325}}
{"chunk_content": "Despite having just stated that consistently using edge labels in\nqueries is a good idea, unless you truly do want to get back all edges\nor all connected vertices, I will break my own rule quite a bit in this\nbook. The reason for this is purely to save space and make the queries I\npresent shorter.\n\nHere are a few more simple queries similar to the previous one. The\nfirst example can be used to answer the question \\\"Where can I fly to\nfrom Austin, with one stop on the way?\\\". Note that, as written, coming\nback to Austin will be included in the results as this query does not\nrule it out!\n\n``` java\n// Where can I fly to from Austin, with one stop on the way?\ng.V().has('airport','code','AUS').out('route').out('route').values('code')\n```\n\nThis query uses an *in* step to find all the routes that come into the\nLondon City Airport (LCY) and returns their IATA codes.\n\n``` java\n// What routes come in to LCY?\ng.V().has('airport','code','LCY').in('route').values('code')\n```", "metadata": {"source_file": "Gremlin-Graph-Guide.md", "hierarchy": {"level_1_title": "3. WRITING GREMLIN QUERIES {#gq}", "level_2_title": "3.3. Starting to walk the graph {#walk}", "level_3_title": "3.3.1. Some simple graph traversal examples {#_some_simple_graph_traversal_examples}"}, "chunk_id": "C3_3_1_chunk_3", "word_count": 181}}
{"chunk_content": "``` java\n// What routes come in to LCY?\ng.V().has('airport','code','LCY').in('route').values('code')\n```\n\nThis query is perhaps a bit more interesting. It finds all the routes\nfrom London Heathrow airport in England that go to an airport in the\nUnited States and returns their IATA codes.\n\n``` java\n// Flights from London Heathrow (LHR) to airports in the USA\ng.V().has('code','LHR').out('route').has('country','US').values('code')\n```", "metadata": {"source_file": "Gremlin-Graph-Guide.md", "hierarchy": {"level_1_title": "3. WRITING GREMLIN QUERIES {#gq}", "level_2_title": "3.3. Starting to walk the graph {#walk}", "level_3_title": "3.3.1. Some simple graph traversal examples {#_some_simple_graph_traversal_examples}"}, "chunk_id": "C3_3_1_chunk_4", "word_count": 73}}
{"chunk_content": "A Gremlin method (often called a step) that you will see used a lot in\nthis book is *path*. After you have done some graph walking using a\nquery you can use *path* to get a summary back of where you went. A\nsimple example of a *path* step being used is shown below. Throughout\nthe book you will see numerous examples of *path* being used including\nin conjunction with one or more *by* steps to specify how the path\nresult should be formatted.\n\nThis particular query will return the vertices and outgoing edges\nstarting at the London City (LCY) airport vertex. You can read this\nquery like this: \\\"Start at the LCY vertex, find all outgoing edges and\nalso find all of the vertices that are on the other ends of those\nedges\\\". The *inV* step gives us the vertex at the other end of the\noutgoing edge.\n\n``` java\n// This time, for each route, return both vertices and the edge that connects them.\ng.V().has('airport','code','LCY').outE().inV().path()\n```\n\nIf you run that query as-is you will get back a series of results that\nlook like this. This shows that there is a route from vertex 88 to\nvertex 77 via an edge with an ID of 13698.\n\n``` java\n[v[88],e[13698][88-route->77],v[77]]\n```", "metadata": {"source_file": "Gremlin-Graph-Guide.md", "hierarchy": {"level_1_title": "3. WRITING GREMLIN QUERIES {#gq}", "level_2_title": "3.3. Starting to walk the graph {#walk}", "level_3_title": "3.3.2. What vertices and edges did I visit? - Introducing *path* {#pathintro}"}, "chunk_id": "C3_3_2_chunk_1", "word_count": 223}}
{"chunk_content": "``` java\n[v[88],e[13698][88-route->77],v[77]]\n```\n\nWhile this result is useful, we might want to return something more\nhuman readable such as the IATA codes for each airport and perhaps the\ndistance property from the edge that tells us how far apart the airports\nare. We could add some *by* modulators to our query to do this. The\nApache TinkerPop documentation uses the phrase *modulator* to describe\nsteps that are not really independent steps but instead alter the\nbehavior of the steps that they are associated with.\n\n::: tip\nA *modulator* is a step that influences the behavior of the step that it\nis associated with. Examples of such modulator steps are *by* and *as*.\n:::\n\nTake a look at the modified form of the query shown below and an example\nof the results that it will now return. If this is not fully clear yet\ndon't panic. Both *path* and *by* are used a lot throughout this book.\n\n``` java\ng.V().has('airport','code','LCY').outE().inV().\n      path().by('code').by('dist')\n```\n\nWhen you run this modified version of the query, you will receive a set\nof results that look like the following line.", "metadata": {"source_file": "Gremlin-Graph-Guide.md", "hierarchy": {"level_1_title": "3. WRITING GREMLIN QUERIES {#gq}", "level_2_title": "3.3. Starting to walk the graph {#walk}", "level_3_title": "3.3.2. What vertices and edges did I visit? - Introducing *path* {#pathintro}"}, "chunk_id": "C3_3_2_chunk_2", "word_count": 198}}
{"chunk_content": "When you run this modified version of the query, you will receive a set\nof results that look like the following line.\n\n``` java\n[LCY,456,GVA]\n```\n\nThe *by* modulator steps are processed in a round robin fashion. If\nthere are not enough modulators specified for the total number of\nelements in the path, Gremlin just loops back around to the first *by*\nstep and so on. So even though there were three elements in the path\nthat we wanted to have formatted, we only needed to specify two *by*\nmodulators. This is because the first and third elements in the path are\nof the same type, namely airport vertices, and we wanted to use the same\nproperty name, *code*, in each of those cases. If we instead wanted to\nreference a different property name for each element of the path result,\nwe would need to specify three explicit *by* modulator steps. This would\nbe required if, for example, we wanted to reference the *city* property\nof the third element in the path rather than its *code*.\n\n::: tip\nThe *by* modulator steps are processed in a round robin fashion in cases\nwhere there are more results to apply them to than *by* modulators\nspecified.\n:::\n\nThe example above is equivalent to this longer form of the same query.\n\n``` java\ng.V().has('airport','code','LCY').outE().inV().\n      path().by('code').by('dist').by('code')\n```", "metadata": {"source_file": "Gremlin-Graph-Guide.md", "hierarchy": {"level_1_title": "3. WRITING GREMLIN QUERIES {#gq}", "level_2_title": "3.3. Starting to walk the graph {#walk}", "level_3_title": "3.3.2. What vertices and edges did I visit? - Introducing *path* {#pathintro}"}, "chunk_id": "C3_3_2_chunk_3", "word_count": 232}}
{"chunk_content": "``` java\ng.V().has('airport','code','LCY').outE().inV().\n      path().by('code').by('dist').by('code')\n```\n\nThe example below shows a case where three different *by* modulators are\nused. This time the third *by* modulator step references the *city*\nproperty rather than the airport *code*. As you can see from the sample\noutput, this time the city name *Geneva* appears rather than the airport\ncode *GVA*.\n\n``` java\ng.V().has('airport','code','LCY').outE().inV().\n      path().by('code').by('dist').by('city')\n\n\n[LCY,456,Geneva]\n```\n\nSometimes it is necessary to use a *by* modulator that has no parameter\nas shown below. This is because the element in the path is not a vertex\nor edge containing multiple properties but rather a single value, in\nthis case, an integer.", "metadata": {"source_file": "Gremlin-Graph-Guide.md", "hierarchy": {"level_1_title": "3. WRITING GREMLIN QUERIES {#gq}", "level_2_title": "3.3. Starting to walk the graph {#walk}", "level_3_title": "3.3.2. What vertices and edges did I visit? - Introducing *path* {#pathintro}"}, "chunk_id": "C3_3_2_chunk_4", "word_count": 128}}
{"chunk_content": "Sometimes it is necessary to use a *by* modulator that has no parameter\nas shown below. This is because the element in the path is not a vertex\nor edge containing multiple properties but rather a single value, in\nthis case, an integer.\n\n``` java\ng.V().has('airport','code','LCY').out().limit(5).\n      values('runways').\n      path().by('code').by('code').by()\n```\n\nThe results show the codes for the airports we visited along with a\nnumber representing the number of runways the second airport has.\n\n``` java\n[LCY,AGP,2]\n[LCY,ABZ,4]\n[LCY,JER,1]\n[LCY,BSL,2]\n[LCY,BHD,1]\n```", "metadata": {"source_file": "Gremlin-Graph-Guide.md", "hierarchy": {"level_1_title": "3. WRITING GREMLIN QUERIES {#gq}", "level_2_title": "3.3. Starting to walk the graph {#walk}", "level_3_title": "3.3.2. What vertices and edges did I visit? - Introducing *path* {#pathintro}"}, "chunk_id": "C3_3_2_chunk_5", "word_count": 100}}
{"chunk_content": "``` java\n[LCY,AGP,2]\n[LCY,ABZ,4]\n[LCY,JER,1]\n[LCY,BSL,2]\n[LCY,BHD,1]\n```\n\nIt is also possible to use a traversal inside of a *by* modulator. Such\ntraversals are known as *\\\"anonymous traversals\\\"* as they do not\ninclude a beginning *V* or *E* step.\n\n::: note\nTraversals that do not start with a *V* or *E* step are referred to as\n*\\\"anonymous traversals\\\"*.\n:::\n\nThis capability allows us to do things like combine multiple values\ntogether as part of a path result. The example below finds five routes\nthat start in Austin and creates a path result containing the airport\ncode and city name for both the source and destination airports. In this\ncase, the anonymous traversal contained within the *by* modulator is\napplied to each element in the path.\n\n``` java\ng.V(3).out().limit(5).path().by(values('code','city').fold())\n\n[[AUS,Austin],[YYZ,Toronto]]\n[[AUS,Austin],[LHR,London]]\n[[AUS,Austin],[FRA,Frankfurt]]\n[[AUS,Austin],[MEX,Mexico City]]\n[[AUS,Austin],[PIT,Pittsburgh]]\n```\n\nTo demonstrate that just about any arbitrary traversal can be placed\ninside the *by* modulator here is one more example that counts the\nnumber of outgoing routes for the source and destination airports as\npart of generating the *path* result.", "metadata": {"source_file": "Gremlin-Graph-Guide.md", "hierarchy": {"level_1_title": "3. WRITING GREMLIN QUERIES {#gq}", "level_2_title": "3.3. Starting to walk the graph {#walk}", "level_3_title": "3.3.2. What vertices and edges did I visit? - Introducing *path* {#pathintro}"}, "chunk_id": "C3_3_2_chunk_6", "word_count": 205}}
