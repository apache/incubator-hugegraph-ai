### **切分方案：从Markdown到高质量训练数据块**

#### **总体目标**

将`Gremlin-Graph-Guide.md`源文件，转化为一个由多个独立的、大小适中、语义完整的JSON对象组成的**数据块集合（Chunks）**。每个数据块都将作为后续生成QA训练数据的理想上下文。

-----

#### **第一阶段：结构化解析 (Parsing)**

此阶段的目标是将整个Markdown文件解析成一个内存中的、精确反映其三级目录结构的层级化对象。

1.  **输入**：`Gremlin-Graph-Guide.md` 文件。
2.  **核心逻辑**：
      * **上下文感知解析**：程序将逐行读取文件，并始终维护一个\*\*“是否在代码块内”\*\*的状态开关 (`in_code_block`)。只有在`in_code_block`为**False**时，程序才会尝试将以`#`、`##`或`###`开头的行识别为标题。解决了代码注释被误判为标题的Bug。（待选，可以不需要,本篇书籍中这类情况较少，故而没有考虑）
      * **层级构建**：
          * 遇到` #  `（一级标题），则创建一个新的顶级“章”节点。
          * 遇到` ##  `（二级标题），则在当前的“章”节点下创建一个“节”节点。
          * 遇到` ###  `（三级标题），则在当前的“节”节点下创建一个“小节”节点。
      * **内容归属**：不属于标题的所有行（包括代码块内的所有行）都将被精确地添加到当前所在的最深层级节点的`content`中。这解决了父级标题下的介绍性内容丢失或错位的问题。
      * **标题清洗**：在存入标题时，程序会自动移除`#`标记和行尾的`{#...}`锚点ID，确保标题纯净。
3.  **此阶段产出**：一个内存中的、与`gremlin_book.json`结构类似的、精确的、嵌套的Python字典/列表对象。

-----

#### **第二阶段：细粒度切分 (Chunking)**

此阶段的目标是遍历第一阶段生成的结构化对象，并将其中的`content`字段，按照我们制定的高级规则，切分成最终的数据块。

1.  **输入**：第一阶段生成的层级化对象。
2.  **核心逻辑**：程序将递归遍历每一个节点（章、节、小节）。
      * **A. 最小长度豁免**：

          * 在切分任何一个节点的`content`之前，首先检查其内容的长度。如果内容较短（例如，少于**150个单词**或**5个语义单元**），则不进行切分，其全部内容直接构成一个独立的chunk。

      * **B. 识别并保护“原子块”**：

          * 这是保证语义完整的关键。程序会首先从内容中识别并提取出以下几类不可分割的“原子块”：
              * **代码块**：由` ``` `包裹的全部内容。
              * **表格**：由`|`构成的连续多行。
              * **列表**：由`*`, `-`, `1.`等标记引导的连续行。
              * **块引用**：由`>`引导的连续行。

      * **C. 构建“语义单元”列表**：

          * 一个节点的`content`将被分解为一个由基础部分组成的列表。这个列表中的每一项，要么是一个完整的“原子块”，要么是一个**由连续换行符(`\n\n`)分割的普通段落**。

      * **D. 应用带重叠的滑动窗口**：

          * 程序将在这个“语义单元”列表上进行滑动窗口切分。
          * **可调参数**：
              * `chunk_size`：定义每个chunk包含多少个语义单元（推荐值为**3到5**）。
              * `overlap_size`：定义相邻chunk之间重叠多少个语义单元（推荐值为**1到2**）。
          * **过程**：例如，当`chunk_size=3`, `overlap_size=1`时，第一个chunk包含`[单元1, 单元2, 单元3]`，第二个chunk将包含`[单元3, 单元4, 单元5]`，以此类推。

-----

#### **第三阶段：格式化输出 (Formatting & Output)**

此阶段的目标是将所有切分好的数据块，按照包含丰富元数据的标准格式，保存到本地文件。

1.  **输出文件格式**：**JSON Lines (`.jsonl`)**。这是一种高效的存储格式，文件中的每一行都是一个独立的、完整的JSON对象，便于流式读取和分布式处理。

2.  **单条数据（Chunk）的最终JSON结构**：
    每一行都将遵循以下详细格式：

    ```json
    {
      "chunk_content": "这里是经过切分后，完整保留了原始Markdown格式（包括换行、代码缩进、列表标记等）的文本块内容。例如，它可能包含一个段落、一个完整的代码块、和下一个段落的开头部分。",
      "metadata": {
        "source_file": "Gremlin-Graph-Guide.md",
        "hierarchy": {
          "level_1_title": "3. WRITING GREMLIN QUERIES",
          "level_2_title": "3.4. Limiting the amount of data returned",
          "level_3_title": "3.4.2. Removing duplicates - introducing dedup"
        },
        "chunk_id": "C3_S4_SS2_chunk_1",
        "word_count": 128
      }
    }
    ```

3.  **元数据字段详解 (`metadata`)**：

      * **`source_file`**: 恒为 `"Gremlin-Graph-Guide.md"`，确保数据来源清晰。
      * **`hierarchy`**: 一个描述层级位置的对象。
          * `level_1_title`: 该chunk所属的**一级章节**标题。
          * `level_2_title`: 所属的**二级章节**标题 (如果适用)。
          * `level_3_title`: 所属的**三级章节**标题 (如果适用)。
      * **`chunk_id`**: 程序生成的唯一ID，例如 `C3_S4_SS2_chunk_1` 代表“第3章第4节第2小节的第1个chunk”，提供了极佳的可追溯性。
      * **`word_count`**: 当前chunk的单词数，便于后续按需筛选。