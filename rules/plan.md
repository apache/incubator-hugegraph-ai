### 3. 创建任务清单

在用户批准设计后，根据需求和设计创建一个可操作的实现计划，并附带编码任务的检查清单。
任务文档应基于设计文档，因此请确保设计文档已存在。

**约束条件：**

- 模型必须在尚不存在的情况下，创建一个 '.workflow/{feature_name}/tasks.md' 文件
- 如果用户表示设计需要更改，模型必须**返回到设计步骤**
- 如果用户表示需要补充需求，模型必须**返回到需求步骤 -> 设计步骤**
- 模型必须在 '.workflow/{feature_name}/tasks.md' 创建实现计划
- 模型在创建实现计划时必须遵循以下具体指令：
  将功能设计转化为一系列提示，供代码生成型 LLM 按照测试驱动的方式实现每一步。优先考虑最佳实践、渐进式推进和尽早测试。
- 模型必须将实现计划格式化为最多两级层级结构的编号复选框列表：
- 顶层条目（如史诗级任务）仅在需要时使用
- 子任务应使用小数编号（如 1.1、1.2、2.1）
- 每一项都必须是一个复选框
- 所有复选框在初始创建时必须为未选中状态 `[ ]`
- 建议采用简单结构
- 模型必须确保每个任务项包括：
- 以任务描述形式清晰表述目标，涉及编写、修改或测试代码
- 任务下附加信息作为子项目列出
- 明确引用需求文档中的具体需求（引用到细粒度子需求，而不仅是用户故事）
- 模型必须确保实现计划是一系列离散、可管理的编码步骤
- 在规划任务前，模型必须遵循[研究优先原则](../README.md#研究优先原则)，确保在代码库中搜索是否已有可复用的实现（如错误码、工具函数等），避免不必要的重复实现。
- 模型必须确保每个任务都引用需求文档中的具体需求
- 模型不得包含已经在设计文档中阐述过的过度实现细节
- 模型假定所有上下文文档（功能需求、设计）在实现期间均可用
- 模型必须确保每一步在前一步基础上递进
- 建议模型在适当情况下优先采用测试驱动开发
- 模型必须确保计划覆盖设计中所有可通过代码实现的方面
- 建议模型优先安排能及早通过代码验证核心功能的步骤
- 模型必须确保所有需求都通过实现任务得到覆盖
- 如果在实现规划阶段发现缺口，模型必须主动提供返回前一步（需求或设计）的选项
- 模型只允许包含编码代理可执行的任务（编写代码、创建测试等）
- 模型不得包含与用户测试、部署、性能指标收集或其他非编码活动相关的任务
- 模型必须聚焦于可在开发环境内执行的代码实现任务
- 模型必须依照以下准则确保每项任务都可由编码代理执行：
- 任务应涉及特定代码组件的编写、修改或测试
- 任务应指明需创建或修改的文件或组件
- 任务具体明确，编码代理无需补充说明即可执行
- 任务应聚焦于实现细节，而非高层概念
- 任务应限定在具体编码活动范围内（如“实现 X 函数”而非“支持 X 功能”）
- 模型必须明确避免在实现计划中包括以下类型的非编码任务：
- 用户验收测试或用户反馈收集
- 部署到生产或预发布环境
- 性能指标收集或分析
- 运行应用进行端到端流程测试（但可编写自动化测试来验证端到端用户视角）
- 用户培训或文档创建
- 业务流程或组织变更
- 市场营销或传播活动
- 任何无法通过编写、修改或测试代码完成的任务
- 更新任务文档后，模型必须暂停并询问用户“这些任务看起来可以吗？”
- 如果用户请求修改或未明确批准，模型必须对任务文档进行修改
- 每次编辑任务文档后，模型都必须请求用户明确批准
- 在收到明确批准（如“是”，“批准”，“看起来可以”等）前，模型不得视为工作流已完成
- 模型必须持续执行反馈-修订循环，直到收到明确批准
- 任务文档获得批准后，模型必须停止操作

**本工作流仅用于创建设计和规划工件。功能的实际实现应通过单独的工作流完成。**

- 模型不得尝试在此工作流中实现功能
- 创建设计与规划工件后，模型必须明确告知用户本工作流已完成